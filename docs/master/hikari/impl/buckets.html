<!doctypehtml><html class=sidebar-hidden lang=en><meta charset=utf-8><meta content=width=device-width,initial-scale=1 name=viewport><meta content="pdoc 9.0.1"name=generator><title>hikari.impl.buckets API documentation</title><meta content=website property=og:type><meta content=https://www.hikari-py.dev/logo.png property=og:image><meta content="hikari.impl.buckets API documentation"property=og:title><meta content="A Discord Bot framework for modern Python and asyncio built on good intentions"property=og:description><meta content=#ff029a property=theme-color><link rel="shortcut icon"href=https://www.hikari-py.dev/logo.png type=image/png><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.1.3/css/bootstrap-reboot.css integrity=sha512-MiwRA9Okl+Pah06DKec2BuhcKl6RnH8dFrlmosZPAvUuHAx2grCGHC35eXHrQwSIsDOPvwRteRZzRwFU6Qoj7w== referrerpolicy=no-referrer rel=stylesheet><style>:root{--pdoc-background: #212529;--text: #f7f7f7;--muted: #9d9d9d;--link: #DB61D9 ;--link-hover: #3989ff;--code: #333;--accent: #343434;--accent2: #555;--nav-hover: rgba(0, 0, 0, .1);--def: #ff79c6;--name: #61aeee;--annotation: #DE4F91}body{background-color:var(--pdoc-background)}html,body{width:100%;height:100%;overflow-wrap:break-word;scroll-behavior:smooth;font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}@media (max-width: 1079px){:root{--sidebar-width: 27rem}html{font-size:3.5vw}main,header{padding:2rem 3vw 0 1.5rem}html:not(.sidebar-hidden) body{overflow:hidden!important}html:not(.sidebar-hidden) main{pointer-events:none!important}.sidebar-hidden nav{transform:translate(calc(0px - var(--sidebar-width)))}nav{transition:transform .2s}.sidebar-toggle{position:fixed;top:0;bottom:calc(100% - 6rem);left:var(--sidebar-width);border-left:10px solid grey;border-top:5px solid rgba(0,0,0,0);border-bottom:5px solid rgba(0,0,0,0)}}@media (min-width: 1080px){:root{--sidebar-width: clamp(12.5rem, 37vw, 28rem)}html{font-size:1rem}main,header{padding:3rem 4rem 3rem calc(var(--sidebar-width) + 3rem)}}nav{position:fixed;left:0;top:0;bottom:0;height:100vh;width:var(--sidebar-width);z-index:1}.sidebar{height:100vh;overflow:auto;padding:.5rem 1.5rem 1rem 1rem;background-color:var(--accent);border-right:1px solid var(--accent2);scrollbar-color:var(--accent2) transparent}::-webkit-scrollbar{width:10px;background:var(--accent) transparent}::-webkit-scrollbar-thumb{-webkit-border-radius:1ex;background:var(--accent2)}.sidebar input[type=search]{display:block;outline-offset:0;width:102%}.sidebar ul{list-style:none;padding-left:1rem}.sidebar li{display:block;margin:0;padding:.2rem 0 .2rem .5rem;transition:all .1s}.sidebar>ul>li{padding-left:0}.sidebar li:hover{background-color:var(--nav-hover)}.sidebar a:hover{color:var(--text)}.sidebar a{display:block}.sidebar a.function,.sidebar a.variable{color:#bd93f9}.sidebar>h2:first-of-type{margin-top:1rem}.sidebar .class:before{content:"class ";color:var(--muted)}.sidebar .function:after{content:"()";color:var(--muted)}.sidebar .sidebar-buttons{display:flex;width:103%;margin-bottom:.5rem;align-items:center}.sidebar .sidebar-buttons .push{margin-left:auto}.svg-button>svg{width:1.7rem;margin:0 .3rem;cursor:pointer}.version-selector{background-color:var(--accent);color:var(--text);border:hidden}.version-selector:disabled{-webkit-appearance:none}.version-warning{background-color:#520000;padding:1rem;margin-right:3rem;text-align:center}.version-warning:empty{display:none}.version-warning a{color:#81d9ff}.version-warning a:hover{color:#00b2ff}nav,main{color:var(--text);box-sizing:border-box;line-height:1.5;background:none}h1,h2,h3{font-weight:300;margin:.3em 0;padding:.2em 0}a{text-decoration:none;color:var(--link)}a:hover{color:var(--link-hover)}blockquote{margin-left:2rem}p{font-weight:300;margin-bottom:.5rem}pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto}code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px}a>code{color:inherit}pre>code{display:inline-block;font-size:inherit;background:none;border:none;padding:0}.modulename{color:var(--annotation);font-weight:bold}.modulename a{color:var(--link);transition:.1s all}.modulename a:hover{filter:brightness(80%)}.git-button{float:right;border:solid var(--link) 1px}.git-button:hover{background-color:var(--link);color:var(--pdoc-background)}details{--shift: -2.4rem;text-align:right;margin-top:var(--shift);margin-bottom:calc(0px - var(--shift));clear:both;filter:opacity(1)}details:not([open]){height:0;overflow:visible}details>summary{font-size:.75rem;cursor:pointer;color:var(--muted);border-width:0;padding:0 1rem;display:inline-block;display:inline list-item;user-select:none}details>summary:focus{outline:0}details>div{margin-top:calc(0px - var(--shift) / 2);text-align:left}.docstring{margin:0 0 2rem 2rem}.docstring pre{margin-left:1em;margin-right:1em}.docstring li{margin-bottom:15px}.docstring li:last-child{margin-bottom:0}span.name{color:#61aeee}span.base{color:#8be9fd}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background-color:var(--accent2);box-shadow:-1rem 0 0 0 var(--accent2)}li strong{color:var(--def)}b,strong{font-weight:bold}em{color:orange}h6{padding-top:1rem;font-size:1.7rem;color:#fff}h6#notes{color:orange}h6#raises{color:#f66}div.decorator{color:#61aeee}div:target>.attr,section:target>.attr,dd:target>a{background-color:var(--accent2)}.inherited dt,.inherited dt:before{color:#61aeee}.attr:hover{filter:contrast(.95)}.headerlink{position:absolute;margin-left:-2.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all .1s ease-in-out;opacity:0}*:hover>.headerlink,*:target>.attr>.headerlink{opacity:1}.attr{display:block;color:var(--text);margin:2rem 0 .5rem 1rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent)}.attr:first-of-type{margin-left:0}.member_divisor{margin-left:3rem}.member_divisor>h5{margin-left:-1rem;font-size:1.5rem;color:#a9a9a9}.member_divisor .attr:first-of-type{margin-top:0}.name{color:var(--name);font-weight:bold}.def{color:var(--def);font-weight:bold}.signature{white-space:pre-wrap}.annotation{color:var(--annotation)}.inherited{margin-left:4rem}.inherited div{margin-left:2rem}.inherited dt{font-weight:700}.inherited dt,.inherited dd{display:inline;margin-left:0;margin-bottom:.5rem}.inherited dd:not(:last-child):after{content:", "}.inherited .class:before{content:"class "}.inherited .function a:after{content:"()"}.search-result .docstring{overflow:auto;max-height:25vh}.search-result.focused>.attr{background-color:var(--accent2)}.attribution{margin-top:2rem;display:block;opacity:.5;transition:all .2s;filter:grayscale(100%)}.attribution:hover{opacity:1;color:#fff}.c{color:#6a7aaa}.err{color:#f55;background-color:#1e0010}.k{color:#ff79c6}.l{color:#ae81ff}.n{color:#f8f8f2}.o{color:#ff79c6}.p{color:#f8f8f2}.ch{color:#6a7aaa}.cm{color:#6a7aaa}.cp{color:#6a7aaa}.cpf{color:#6a7aaa}.c1{color:#6a7aaa}.cs{color:#6a7aaa}.gd{color:#6a7aaa}.ge{font-style:italic}.gi{color:#a6e22e}.go{color:#ff79c6}.gp{color:#f92672;font-weight:bold}.gs{font-weight:bold}.gu{color:#75715e}.kc{color:#ff79c6}.kd{color:#bd93f9}.kn{color:#ff79c6}.kp{color:#bd93f9}.kr{color:#ff79c6}.kt{color:#ff79c6}.ld{color:#e6db74}.m{color:#ae81ff}.s{color:#e6db74}.na{color:#a6e22e}.nb{color:#8be9fd}.nc{color:#e6c07b}.no{color:#ff79c6}.ni{color:#ff79c6}.ne{color:#8be9fd}.nf{color:#61aeee}.nl{color:#f8f8f2}.nn{color:#f8f8f2}.nx{color:#a6e22e}.py{color:#f8f8f2}.nt{color:#f92672}.nv{color:#f8f8f2}.ow{color:#ff79c6}.w{color:#f8f8f2}.mb{color:#ae81ff}.mf{color:#ae81ff}.mh{color:#ae81ff}.mi{color:#ae81ff}.mo{color:#ae81ff}.sa{color:#ff79c6}.sb{color:#e6db74}.sc{color:#e6db74}.dl{color:#e6db74}.sd{color:#6272a4}.s2{color:#e6db74}.se{color:#ae81ff}.sh{color:#e6db74}.si{color:#bd93f9}.sx{color:#e6db74}.sr{color:#e6db74}.s1{color:#e6db74}.ss{color:#e6db74}.bp{color:#bd93f9}.fm{color:#bd93f9}.vc{color:#bd93f9}.vg{color:#f8f8f2}.vi{color:#fff}.vm{color:#bd93f9}.il{color:#ae81ff}.nd{color:#61aeee}.kc{color:#bd93f9}</style><body><nav class=pdoc><div class=sidebar id=sidebar><div class=sidebar-buttons><label>Hikari (<select class=version-selector disabled id=version-selector><option>master</select>)</label><div class=push></div><a class=svg-button href=../../index.html><svg viewbox="0 0 576 512"height=32 width=32 xmlns=http://www.w3.org/2000/svg><path d="M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z"fill=#ffffff /></svg></a><a class=svg-button href=https://discord.gg/Jx4cNGG><svg viewbox="0 0 71 55"height=32 width=32 xmlns=http://www.w3.org/2000/svg><path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z"fill=#ffffff /></svg></a><a class=svg-button href=https://github.com/hikari-py/hikari><svg viewbox="0 0 16 16"height=32 width=32 xmlns=http://www.w3.org/2000/svg><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"fill=#ffffff></path></svg></a><a class=svg-button href=https://pypi.org/project/hikari><svg viewbox="0 0 512 512"height=32 width=32 xmlns=http://www.w3.org/2000/svg><path d="M488.6 250.2L392 214V105.5c0-15-9.3-28.4-23.4-33.7l-100-37.5c-8.1-3.1-17.1-3.1-25.3 0l-100 37.5c-14.1 5.3-23.4 18.7-23.4 33.7V214l-96.6 36.2C9.3 255.5 0 268.9 0 283.9V394c0 13.6 7.7 26.1 19.9 32.2l100 50c10.1 5.1 22.1 5.1 32.2 0l103.9-52 103.9 52c10.1 5.1 22.1 5.1 32.2 0l100-50c12.2-6.1 19.9-18.6 19.9-32.2V283.9c0-15-9.3-28.4-23.4-33.7zM358 214.8l-85 31.9v-68.2l85-37v73.3zM154 104.1l102-38.2 102 38.2v.6l-102 41.4-102-41.4v-.6zm84 291.1l-85 42.5v-79.1l85-38.8v75.4zm0-112l-102 41.4-102-41.4v-.6l102-38.2 102 38.2v.6zm240 112l-85 42.5v-79.1l85-38.8v75.4zm0-112l-102 41.4-102-41.4v-.6l102-38.2 102 38.2v.6z"fill=#ffffff /></svg></a></div><input title="Search the documentation"pattern=.+ placeholder=Search... role=searchbox type=search><h2>Contents</h2><ul><li><a href=#what-is-the-theory-behind-this-implementation>What is the theory behind this implementation?</a><li><a href=#body-field-specific-rate-limiting>Body-field-specific rate limiting</a></ul><h2>API Documentation</h2><ul class=memberlist><li><a class=class href=#RESTBucket>RESTBucket</a> <ul class=memberlist><li><a class=function href=#RESTBucket.__init__>__init__</a><li><a class=function href=#RESTBucket.acquire>acquire</a><li><a class=function href=#RESTBucket.close>close</a><li><a class=function href=#RESTBucket.drip>drip</a><li><a class=function href=#RESTBucket.get_time_until_reset>get_time_until_reset</a><li><a class=variable href=#RESTBucket.is_empty>is_empty</a><li><a class=function href=#RESTBucket.is_rate_limited>is_rate_limited</a><li><a class=variable href=#RESTBucket.is_unknown>is_unknown</a><li><a class=variable href=#RESTBucket.limit>limit</a><li><a class=variable href=#RESTBucket.name>name</a><li><a class=variable href=#RESTBucket.period>period</a><li><a class=variable href=#RESTBucket.queue>queue</a><li><a class=variable href=#RESTBucket.remaining>remaining</a><li><a class=variable href=#RESTBucket.reset_at>reset_at</a><li><a class=function href=#RESTBucket.resolve>resolve</a><li><a class=function href=#RESTBucket.throttle>throttle</a><li><a class=variable href=#RESTBucket.throttle_task>throttle_task</a><li><a class=function href=#RESTBucket.update_rate_limit>update_rate_limit</a></ul><li><a class=class href=#RESTBucketManager>RESTBucketManager</a> <ul class=memberlist><li><a class=function href=#RESTBucketManager.__init__>__init__</a><li><a class=function href=#RESTBucketManager.acquire>acquire</a><li><a class=function href=#RESTBucketManager.close>close</a><li><a class=variable href=#RESTBucketManager.closed_event>closed_event</a><li><a class=function href=#RESTBucketManager.do_gc_pass>do_gc_pass</a><li><a class=function href=#RESTBucketManager.gc>gc</a><li><a class=variable href=#RESTBucketManager.gc_task>gc_task</a><li><a class=variable href=#RESTBucketManager.is_started>is_started</a><li><a class=variable href=#RESTBucketManager.max_rate_limit>max_rate_limit</a><li><a class=variable href=#RESTBucketManager.real_hashes_to_buckets>real_hashes_to_buckets</a><li><a class=variable href=#RESTBucketManager.routes_to_hashes>routes_to_hashes</a><li><a class=function href=#RESTBucketManager.start>start</a><li><a class=function href=#RESTBucketManager.update_rate_limits>update_rate_limits</a></ul><li><a class=variable href=#UNKNOWN_HASH>UNKNOWN_HASH</a></ul><a class=attribution href=https://pdoc.dev>built with pdoc v9.0.1</a></div><div class=sidebar-toggle id=sidebar-toggle></div></nav><main class=pdoc><div class=version-warning id=version-warning></div><section><h1 class=modulename><a href=./../../index.html>hikari</a><wbr>.<a href=./../impl.html>impl</a><wbr>.buckets</h1><div class=docstring><p>Rate-limit extensions for RESTful bucketed endpoints.<p>Provides implementations for the complex rate limiting mechanisms that Discord requires for rate limit handling that conforms to the passed bucket headers correctly.<p>This was initially a bit of a headache for me to understand, personally, since there is a lot of "implicit detail" that is easy to miss from the documentation.<p>In an attempt to make this somewhat understandable by anyone else, I have tried to document the theory of how this is handled here.<h2 id=what-is-the-theory-behind-this-implementation>What is the theory behind this implementation?</h2><p>In this module, we refer to a <code><a href=../internal/routes.html#CompiledRoute>hikari.internal.routes.CompiledRoute</a></code> as a definition of a route with specific major parameter values included (e.g. <code>POST /channels/123/messages</code>), and a <code><a href=../internal/routes.html#Route>hikari.internal.routes.Route</a></code> as a definition of a route without specific parameter values included (e.g. <code>POST /channels/{channel}/messages</code>). We can compile a <code><a href=../internal/routes.html#CompiledRoute>hikari.internal.routes.CompiledRoute</a></code> from a <code><a href=../internal/routes.html#Route>hikari.internal.routes.Route</a></code> by providing the corresponding parameters as kwargs, as you may already know.<p>In this module, a "bucket" is an internal data structure that tracks and enforces the rate limit state for a specific <code><a href=../internal/routes.html#CompiledRoute>hikari.internal.routes.CompiledRoute</a></code>, and can manage delaying tasks in the event that we begin to get rate limited. It also supports providing in-order execution of queued tasks.<p>Discord allocates types of buckets to routes. If you are making a request and there is a valid rate limit on the route you hit, you should receive an <code>X-RateLimit-Bucket</code> header from the server in your response. This is a hash that identifies a route based on internal criteria that does not include major parameters. This <code>X-RateLimitBucket</code> is known in this module as an "bucket hash".<p>This means that generally, the route <code>POST /channels/123/messages</code> and <code>POST /channels/456/messages</code> will usually sit in the same bucket, but <code>GET /channels/123/messages/789</code> and <code>PATCH /channels/123/messages/789</code> will usually not share the same bucket. Discord may or may not change this at any time, so hard coding this logic is not a useful thing to be doing.<p>Rate limits, on the other hand, apply to a bucket and are specific to the major parameters of the compiled route. This means that <code>POST /channels/123/messages</code> and <code>POST /channels/456/messages</code> do not share the same real bucket, despite Discord providing the same bucket hash. A real bucket hash is the <code>str</code> hash of the bucket that Discord sends us in a response concatenated to the corresponding major parameters. This is used for quick bucket indexing internally in this module.<p>One issue that occurs from this is that we cannot effectively hash a <code><a href=../internal/routes.html#CompiledRoute>hikari.internal.routes.CompiledRoute</a></code> that has not yet been hit, meaning that until we receive a response from this endpoint, we have no idea what our rate limits could be, nor the bucket that they sit in. This is usually not problematic, as the first request to an endpoint should never be rate limited unless you are hitting it from elsewhere in the same time window outside your <a href=../applications.html>hikari.applications</a>. To manage this situation, unknown endpoints are allocated to a special unlimited bucket until they have an initial bucket hash code allocated from a response. Once this happens, the route is reallocated a dedicated bucket. Unknown buckets have a hardcoded initial hash code internally.<h6 id=initially-acquiring-time-on-a-bucket>Initially acquiring time on a bucket</h6><p>Each time you <code>BaseRateLimiter.acquire()</code> a request timeslice for a given <code><a href=../internal/routes.html#Route>hikari.internal.routes.Route</a></code>, several things happen. The first is that we attempt to find the existing bucket for that route, if there is one, or get an unknown bucket otherwise. This is done by creating a real bucket hash from the compiled route. The initial hash is calculated using a lookup table that maps <code><a href=../internal/routes.html#CompiledRoute>hikari.internal.routes.CompiledRoute</a></code> objects to their corresponding initial hash codes, or to the unknown bucket hash code if not yet known. This initial hash is processed by the <code><a href=../internal/routes.html#CompiledRoute>hikari.internal.routes.CompiledRoute</a></code> to provide the real bucket hash we need to get the route's bucket object internally.<p>The <code>BaseRateLimiter.acquire()</code> method will take the bucket and acquire a new timeslice on it. This takes the form of a <code>asyncio.Future</code> which should be awaited by the caller and will complete once the caller is allowed to make a request. Most of the time, this is done instantly, but if the bucket has an active rate limit preventing requests being sent, then the future will be paused until the rate limit is over. This may be longer than the rate limit period if you have queued a large number of requests during this limit, as it is first-come-first-served.<p>Acquiring a rate limited bucket will start a bucket-wide task (if not already running) that will wait until the rate limit has completed before allowing more futures to complete. This is done while observing the rate limits again, so can easily begin to re-ratelimit itself if needed. Once the task is complete, it tidies itself up and disposes of itself. This task will complete once the queue becomes empty.<p>The result of <code><a href=#RESTBucketManager.acquire>RESTBucketManager.acquire()</a></code> is a tuple of a <code>asyncio.Future</code> to await on which completes when you are allowed to proceed with making a request, and a real bucket hash which should be stored temporarily. This will be explained in the next section.<h6 id=handling-the-rate-limit-headers-of-a-response>Handling the rate limit headers of a response</h6><p>Once you have received your response, you are expected to extract the values of the vital rate limit headers manually and parse them to the correct data types. These headers are:<ul><li><code>X-RateLimit-Limit</code>: an <code>int</code> describing the max requests in the bucket from empty to being rate limited.<li><code>X-RateLimit-Remaining</code>: an <code>int</code> describing the remaining number of requests before rate limiting occurs in the current window.<li><code>X-RateLimit-Bucket</code>: a <code>str</code> containing the initial bucket hash.<li><code>X-RateLimit-Reset-After</code>: a <code>float</code> containing the number of seconds when the current rate limit bucket will reset with decimal millisecond precision.</ul><p>Each of the above values should be passed to the <code>update_rate_limits</code> method to ensure that the bucket you acquired time from is correctly updated should Discord decide to alter their ratelimits on the fly without warning (including timings and the bucket).<p>This method will manage creating new buckets as needed and resetting vital information in each bucket you use.<h6 id=tidying-up>Tidying up</h6><p>To prevent unused buckets cluttering up memory, each <code><a href=#RESTBucketManager>RESTBucketManager</a></code> instance spins up a <code>asyncio.Task</code> that periodically locks the bucket list (not threadsafe, only using the concept of asyncio not yielding in regular functions) and disposes of any clearly stale buckets that are no longer needed. These will be recreated again in the future if they are needed.<p>When shutting down an application, one must remember to <code>close()</code> the <code><a href=#RESTBucketManager>RESTBucketManager</a></code> that has been used. This will ensure the garbage collection task is stopped, and will also ensure any remaining futures in any bucket queues have an <code>asyncio.CancelledError</code> set on them to prevent deadlocking ratelimited calls that may be waiting to be unlocked.<h2 id=body-field-specific-rate-limiting>Body-field-specific rate limiting</h2><p>As of the start of June, 2020, Discord appears to be enforcing another layer of rate limiting logic to their HTTP APIs which is field-specific. This means that special rate limits will also exist on some endpoints that limit based on what attributes you send in a JSON or form data payload.<p>No information is sent in headers about these specific limits. You will only be made aware that they exist once you get ratelimited. In the 429 ratelimited response, you will have the <code>"global"</code> attribute set to <code>False</code>, and a <code>"reset_after"</code> attribute that differs entirely to the <code>X-RateLimit-Reset-After</code> header. Thus, it is important to not assume the value in the 429 response for the reset time is the same as the one in the bucket headers. Hikari's <code><a href=../api/rest.html#RESTClient>hikari.api.rest.RESTClient</a></code> implementation specifically uses the value furthest in the future when working out which bucket to adhere to.<p>It is worth remembering that there is an API limit to the number of 401s, 403s, and 429s you receive, which is around 10,000 per 15 minutes. Passing this limit results in a soft ban of your account.<p>At the time of writing, the only example of this appears to be on the <code>PATCH /channels/{channel_id}</code> endpoint. This has a limit of two changes per 10 minutes. More details about how this is implemented have yet to be released or documented...</div><details><summary>View Source</summary> <div class=codehilite><pre><span></span><span class=c1># -*- coding: utf-8 -*-</span>
<span class=c1># cython: language_level=3</span>
<span class=c1># Copyright (c) 2020 Nekokatt</span>
<span class=c1># Copyright (c) 2021-present davfsa</span>
<span class=c1>#</span>
<span class=c1># Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class=c1># of this software and associated documentation files (the "Software"), to deal</span>
<span class=c1># in the Software without restriction, including without limitation the rights</span>
<span class=c1># to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class=c1># copies of the Software, and to permit persons to whom the Software is</span>
<span class=c1># furnished to do so, subject to the following conditions:</span>
<span class=c1>#</span>
<span class=c1># The above copyright notice and this permission notice shall be included in all</span>
<span class=c1># copies or substantial portions of the Software.</span>
<span class=c1>#</span>
<span class=c1># THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class=c1># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class=c1># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class=c1># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class=c1># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class=c1># OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class=c1># SOFTWARE.</span>
<span class=sd>"""Rate-limit extensions for RESTful bucketed endpoints.</span>

<span class=sd>Provides implementations for the complex rate limiting mechanisms that Discord</span>
<span class=sd>requires for rate limit handling that conforms to the passed bucket headers</span>
<span class=sd>correctly.</span>

<span class=sd>This was initially a bit of a headache for me to understand, personally, since</span>
<span class=sd>there is a lot of "implicit detail" that is easy to miss from the documentation.</span>

<span class=sd>In an attempt to make this somewhat understandable by anyone else, I have tried</span>
<span class=sd>to document the theory of how this is handled here.</span>

<span class=sd>What is the theory behind this implementation?</span>
<span class=sd>----------------------------------------------</span>

<span class=sd>In this module, we refer to a `hikari.internal.routes.CompiledRoute` as a definition</span>
<span class=sd>of a route with specific major parameter values included (e.g.</span>
<span class=sd>`POST /channels/123/messages`), and a `hikari.internal.routes.Route` as a</span>
<span class=sd>definition of a route without specific parameter values included (e.g.</span>
<span class=sd>`POST /channels/{channel}/messages`). We can compile a</span>
<span class=sd>`hikari.internal.routes.CompiledRoute` from a `hikari.internal.routes.Route`</span>
<span class=sd>by providing the corresponding parameters as kwargs, as you may already know.</span>

<span class=sd>In this module, a "bucket" is an internal data structure that tracks and</span>
<span class=sd>enforces the rate limit state for a specific `hikari.internal.routes.CompiledRoute`,</span>
<span class=sd>and can manage delaying tasks in the event that we begin to get rate limited.</span>
<span class=sd>It also supports providing in-order execution of queued tasks.</span>

<span class=sd>Discord allocates types of buckets to routes. If you are making a request and</span>
<span class=sd>there is a valid rate limit on the route you hit, you should receive an</span>
<span class=sd>`X-RateLimit-Bucket` header from the server in your response. This is a hash</span>
<span class=sd>that identifies a route based on internal criteria that does not include major</span>
<span class=sd>parameters. This `X-RateLimitBucket` is known in this module as an "bucket hash".</span>

<span class=sd>This means that generally, the route `POST /channels/123/messages` and</span>
<span class=sd>`POST /channels/456/messages` will usually sit in the same bucket, but</span>
<span class=sd>`GET /channels/123/messages/789` and `PATCH /channels/123/messages/789` will</span>
<span class=sd>usually not share the same bucket. Discord may or may not change this at any</span>
<span class=sd>time, so hard coding this logic is not a useful thing to be doing.</span>

<span class=sd>Rate limits, on the other hand, apply to a bucket and are specific to the major</span>
<span class=sd>parameters of the compiled route. This means that `POST /channels/123/messages`</span>
<span class=sd>and `POST /channels/456/messages` do not share the same real bucket, despite</span>
<span class=sd>Discord providing the same bucket hash. A real bucket hash is the `str` hash of</span>
<span class=sd>the bucket that Discord sends us in a response concatenated to the corresponding</span>
<span class=sd>major parameters. This is used for quick bucket indexing internally in this</span>
<span class=sd>module.</span>

<span class=sd>One issue that occurs from this is that we cannot effectively hash a</span>
<span class=sd>`hikari.internal.routes.CompiledRoute` that has not yet been hit, meaning that</span>
<span class=sd>until we receive a response from this endpoint, we have no idea what our rate</span>
<span class=sd>limits could be, nor the bucket that they sit in. This is usually not</span>
<span class=sd>problematic, as the first request to an endpoint should never be rate limited</span>
<span class=sd>unless you are hitting it from elsewhere in the same time window outside your</span>
<span class=sd>hikari.applications. To manage this situation, unknown endpoints are allocated to</span>
<span class=sd>a special unlimited bucket until they have an initial bucket hash code allocated</span>
<span class=sd>from a response. Once this happens, the route is reallocated a dedicated bucket.</span>
<span class=sd>Unknown buckets have a hardcoded initial hash code internally.</span>

<span class=sd>Initially acquiring time on a bucket</span>
<span class=sd>------------------------------------</span>

<span class=sd>Each time you `BaseRateLimiter.acquire()` a request timeslice for a given</span>
<span class=sd>`hikari.internal.routes.Route`, several things happen. The first is that we</span>
<span class=sd>attempt to find the existing bucket for that route, if there is one, or get an</span>
<span class=sd>unknown bucket otherwise. This is done by creating a real bucket hash from the</span>
<span class=sd>compiled route. The initial hash is calculated using a lookup table that maps</span>
<span class=sd>`hikari.internal.routes.CompiledRoute` objects to their corresponding initial hash</span>
<span class=sd>codes, or to the unknown bucket hash code if not yet known. This initial hash is</span>
<span class=sd>processed by the `hikari.internal.routes.CompiledRoute` to provide the real bucket</span>
<span class=sd>hash we need to get the route's bucket object internally.</span>

<span class=sd>The `BaseRateLimiter.acquire()` method will take the bucket and acquire a new</span>
<span class=sd>timeslice on it. This takes the form of a `asyncio.Future` which should be</span>
<span class=sd>awaited by the caller and will complete once the caller is allowed to make a</span>
<span class=sd>request. Most of the time, this is done instantly, but if the bucket has an</span>
<span class=sd>active rate limit preventing requests being sent, then the future will be paused</span>
<span class=sd>until the rate limit is over. This may be longer than the rate limit period if</span>
<span class=sd>you have queued a large number of requests during this limit, as it is</span>
<span class=sd>first-come-first-served.</span>

<span class=sd>Acquiring a rate limited bucket will start a bucket-wide task (if not already</span>
<span class=sd>running) that will wait until the rate limit has completed before allowing more</span>
<span class=sd>futures to complete. This is done while observing the rate limits again, so can</span>
<span class=sd>easily begin to re-ratelimit itself if needed. Once the task is complete, it</span>
<span class=sd>tidies itself up and disposes of itself. This task will complete once the queue</span>
<span class=sd>becomes empty.</span>

<span class=sd>The result of `RESTBucketManager.acquire()` is a tuple of a `asyncio.Future` to</span>
<span class=sd>await on which completes when you are allowed to proceed with making a request,</span>
<span class=sd>and a real bucket hash which should be stored temporarily. This will be</span>
<span class=sd>explained in the next section.</span>

<span class=sd>Handling the rate limit headers of a response</span>
<span class=sd>---------------------------------------------</span>

<span class=sd>Once you have received your response, you are expected to extract the values of</span>
<span class=sd>the vital rate limit headers manually and parse them to the correct data types.</span>
<span class=sd>These headers are:</span>

<span class=sd>* `X-RateLimit-Limit`:</span>
<span class=sd>    an `int` describing the max requests in the bucket from empty to</span>
<span class=sd>    being rate limited.</span>
<span class=sd>* `X-RateLimit-Remaining`:</span>
<span class=sd>    an `int` describing the remaining number of requests before rate</span>
<span class=sd>    limiting occurs in the current window.</span>
<span class=sd>* `X-RateLimit-Bucket`:</span>
<span class=sd>    a `str` containing the initial bucket hash.</span>
<span class=sd>* `X-RateLimit-Reset-After`:</span>
<span class=sd>    a `float` containing the number of seconds when the current rate</span>
<span class=sd>    limit bucket will reset with decimal millisecond precision.</span>

<span class=sd>Each of the above values should be passed to the `update_rate_limits` method to</span>
<span class=sd>ensure that the bucket you acquired time from is correctly updated should</span>
<span class=sd>Discord decide to alter their ratelimits on the fly without warning (including</span>
<span class=sd>timings and the bucket).</span>

<span class=sd>This method will manage creating new buckets as needed and resetting vital</span>
<span class=sd>information in each bucket you use.</span>

<span class=sd>Tidying up</span>
<span class=sd>----------</span>

<span class=sd>To prevent unused buckets cluttering up memory, each `RESTBucketManager`</span>
<span class=sd>instance spins up a `asyncio.Task` that periodically locks the bucket list</span>
<span class=sd>(not threadsafe, only using the concept of asyncio not yielding in regular</span>
<span class=sd>functions) and disposes of any clearly stale buckets that are no longer needed.</span>
<span class=sd>These will be recreated again in the future if they are needed.</span>

<span class=sd>When shutting down an application, one must remember to `close()` the</span>
<span class=sd>`RESTBucketManager` that has been used. This will ensure the garbage collection</span>
<span class=sd>task is stopped, and will also ensure any remaining futures in any bucket queues</span>
<span class=sd>have an `asyncio.CancelledError` set on them to prevent deadlocking ratelimited</span>
<span class=sd>calls that may be waiting to be unlocked.</span>

<span class=sd>Body-field-specific rate limiting</span>
<span class=sd>---------------------------------</span>

<span class=sd>As of the start of June, 2020, Discord appears to be enforcing another layer</span>
<span class=sd>of rate limiting logic to their HTTP APIs which is field-specific. This means</span>
<span class=sd>that special rate limits will also exist on some endpoints that limit based</span>
<span class=sd>on what attributes you send in a JSON or form data payload.</span>

<span class=sd>No information is sent in headers about these specific limits. You will only</span>
<span class=sd>be made aware that they exist once you get ratelimited. In the 429 ratelimited</span>
<span class=sd>response, you will have the `"global"` attribute set to `False`, and a</span>
<span class=sd>`"reset_after"` attribute that differs entirely to the `X-RateLimit-Reset-After`</span>
<span class=sd>header. Thus, it is important to not assume the value in the 429 response</span>
<span class=sd>for the reset time is the same as the one in the bucket headers. Hikari's</span>
<span class=sd>`hikari.api.rest.RESTClient` implementation specifically uses the value furthest</span>
<span class=sd>in the future when working out which bucket to adhere to.</span>

<span class=sd>It is worth remembering that there is an API limit to the number of 401s,</span>
<span class=sd>403s, and 429s you receive, which is around 10,000 per 15 minutes. Passing this</span>
<span class=sd>limit results in a soft ban of your account.</span>

<span class=sd>At the time of writing, the only example of this appears to be on the</span>
<span class=sd>`PATCH /channels/{channel_id}` endpoint. This has a limit of two changes per</span>
<span class=sd>10 minutes. More details about how this is implemented have yet to be</span>
<span class=sd>released or documented...</span>
<span class=sd>"""</span>

<span class=kn>from</span> <span class=nn>__future__</span> <span class=kn>import</span> <span class=n>annotations</span>

<span class=n>__all__</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>List</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span><span class=s2>"UNKNOWN_HASH"</span><span class=p>,</span> <span class=s2>"RESTBucket"</span><span class=p>,</span> <span class=s2>"RESTBucketManager"</span><span class=p>]</span>

<span class=kn>import</span> <span class=nn>asyncio</span>
<span class=kn>import</span> <span class=nn>logging</span>
<span class=kn>import</span> <span class=nn>typing</span>

<span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>errors</span>
<span class=kn>from</span> <span class=nn>hikari.impl</span> <span class=kn>import</span> <span class=n>rate_limits</span>
<span class=kn>from</span> <span class=nn>hikari.internal</span> <span class=kn>import</span> <span class=n>routes</span>
<span class=kn>from</span> <span class=nn>hikari.internal</span> <span class=kn>import</span> <span class=n>time</span>
<span class=kn>from</span> <span class=nn>hikari.internal</span> <span class=kn>import</span> <span class=n>ux</span>

<span class=k>if</span> <span class=n>typing</span><span class=o>.</span><span class=n>TYPE_CHECKING</span><span class=p>:</span>
    <span class=kn>import</span> <span class=nn>types</span>

<span class=n>UNKNOWN_HASH</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Final</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=s2>"UNKNOWN"</span>
<span class=sd>"""The hash used for an unknown bucket that has not yet been resolved."""</span>

<span class=n>_LOGGER</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Final</span><span class=p>[</span><span class=n>logging</span><span class=o>.</span><span class=n>Logger</span><span class=p>]</span> <span class=o>=</span> <span class=n>logging</span><span class=o>.</span><span class=n>getLogger</span><span class=p>(</span><span class=s2>"hikari.ratelimits"</span><span class=p>)</span>


<span class=k>class</span> <span class=nc>RESTBucket</span><span class=p>(</span><span class=n>rate_limits</span><span class=o>.</span><span class=n>WindowedBurstRateLimiter</span><span class=p>):</span>
    <span class=sd>"""Represents a rate limit for an HTTP endpoint.</span>

<span class=sd>    Component to represent an active rate limit bucket on a specific HTTP route</span>
<span class=sd>    with a specific major parameter combo.</span>

<span class=sd>    This is somewhat similar to the `WindowedBurstRateLimiter` in how it</span>
<span class=sd>    works.</span>

<span class=sd>    This algorithm will use fixed-period time windows that have a given limit</span>
<span class=sd>    (capacity). Each time a task requests processing time, it will drip another</span>
<span class=sd>    unit into the bucket. Once the bucket has reached its limit, nothing can</span>
<span class=sd>    drip and new tasks will be queued until the time window finishes.</span>

<span class=sd>    Once the time window finishes, the bucket will empty, returning the current</span>
<span class=sd>    capacity to zero, and tasks that are queued will start being able to drip</span>
<span class=sd>    again.</span>

<span class=sd>    Additional logic is provided by the `RESTBucket.update_rate_limit` call</span>
<span class=sd>    which allows dynamically changing the enforced rate limits at any time.</span>
<span class=sd>    """</span>

    <span class=vm>__slots__</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=s2>"_compiled_route"</span><span class=p>,</span> <span class=s2>"_max_rate_limit"</span><span class=p>,</span> <span class=s2>"_lock"</span><span class=p>)</span>

    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>compiled_route</span><span class=p>:</span> <span class=n>routes</span><span class=o>.</span><span class=n>CompiledRoute</span><span class=p>,</span> <span class=n>max_rate_limit</span><span class=p>:</span> <span class=nb>float</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_compiled_route</span> <span class=o>=</span> <span class=n>compiled_route</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_max_rate_limit</span> <span class=o>=</span> <span class=n>max_rate_limit</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_lock</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>Lock</span><span class=p>()</span>

    <span class=k>async</span> <span class=k>def</span> <span class=fm>__aenter__</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>acquire</span><span class=p>()</span>

    <span class=k>async</span> <span class=k>def</span> <span class=fm>__aexit__</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>exc_type</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Type</span><span class=p>[</span><span class=ne>BaseException</span><span class=p>]],</span>
        <span class=n>exc</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=ne>BaseException</span><span class=p>],</span>
        <span class=n>exc_tb</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=n>types</span><span class=o>.</span><span class=n>TracebackType</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_lock</span><span class=o>.</span><span class=n>release</span><span class=p>()</span>

    <span class=nd>@property</span>
    <span class=k>def</span> <span class=nf>is_unknown</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=nb>bool</span><span class=p>:</span>
        <span class=sd>"""Return `True` if the bucket represents an `UNKNOWN` bucket."""</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>name</span><span class=o>.</span><span class=n>startswith</span><span class=p>(</span><span class=n>UNKNOWN_HASH</span><span class=p>)</span>

    <span class=k>async</span> <span class=k>def</span> <span class=nf>acquire</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Acquire time on this rate limiter.</span>

<span class=sd>        .. note::</span>
<span class=sd>            You should afterwards invoke `RESTBucket.update_rate_limit` to</span>
<span class=sd>            update any rate limit information you are made aware of.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            If the rate limit is longer than `max_rate_limit`.</span>
<span class=sd>        """</span>
        <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>_lock</span><span class=o>.</span><span class=n>acquire</span><span class=p>()</span>

        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_unknown</span><span class=p>:</span>
            <span class=k>return</span>

        <span class=n>now</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>monotonic</span><span class=p>()</span>
        <span class=n>retry_after</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>reset_at</span> <span class=o>-</span> <span class=n>now</span>

        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_rate_limited</span><span class=p>(</span><span class=n>now</span><span class=p>)</span> <span class=ow>and</span> <span class=n>retry_after</span> <span class=o>></span> <span class=bp>self</span><span class=o>.</span><span class=n>_max_rate_limit</span><span class=p>:</span>
            <span class=k>raise</span> <span class=n>errors</span><span class=o>.</span><span class=n>RateLimitTooLongError</span><span class=p>(</span>
                <span class=n>route</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>_compiled_route</span><span class=p>,</span>
                <span class=n>retry_after</span><span class=o>=</span><span class=n>retry_after</span><span class=p>,</span>
                <span class=n>max_retry_after</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>_max_rate_limit</span><span class=p>,</span>
                <span class=n>reset_at</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>reset_at</span><span class=p>,</span>
                <span class=n>limit</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>limit</span><span class=p>,</span>
                <span class=n>period</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>period</span><span class=p>,</span>
            <span class=p>)</span>

        <span class=k>await</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>acquire</span><span class=p>()</span>

    <span class=k>def</span> <span class=nf>update_rate_limit</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>remaining</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>limit</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>reset_at</span><span class=p>:</span> <span class=nb>float</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Update the rate limit information.</span>

<span class=sd>        .. note::</span>
<span class=sd>            The `reset_at` epoch is expected to be a `time.monotonic_timestamp`</span>
<span class=sd>            monotonic epoch, rather than a `time.time` date-based epoch.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        remaining : int</span>
<span class=sd>            The calls remaining in this time window.</span>
<span class=sd>        limit : int</span>
<span class=sd>            The total calls allowed in this time window.</span>
<span class=sd>        reset_at : float</span>
<span class=sd>            The epoch at which to reset the limit.</span>
<span class=sd>        """</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>remaining</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=n>remaining</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>limit</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=n>limit</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>reset_at</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=n>reset_at</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>period</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=mf>0.0</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>reset_at</span> <span class=o>-</span> <span class=n>time</span><span class=o>.</span><span class=n>monotonic</span><span class=p>())</span>

    <span class=k>def</span> <span class=nf>drip</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Decrement the remaining count for this bucket.</span>

<span class=sd>        .. note::</span>
<span class=sd>            If the bucket is marked as `RESTBucket.is_unknown`, then this will</span>
<span class=sd>            not do anything. `Unknown` buckets have infinite rate limits.</span>
<span class=sd>        """</span>
        <span class=c1># We don't drip unknown buckets: we cannot rate limit them as we don't know their real bucket hash or</span>
        <span class=c1># the current rate limit values Discord put on them...</span>
        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_unknown</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>remaining</span> <span class=o>-=</span> <span class=mi>1</span>

    <span class=k>def</span> <span class=nf>resolve</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>real_bucket_hash</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Resolve an unknown bucket.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        real_bucket_hash: str</span>
<span class=sd>            The real bucket hash for this bucket.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        RuntimeError</span>
<span class=sd>            If the hash of the bucket is already known.</span>
<span class=sd>        """</span>
        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_unknown</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>RuntimeError</span><span class=p>(</span><span class=s2>"Cannot resolve known bucket"</span><span class=p>)</span>

        <span class=bp>self</span><span class=o>.</span><span class=n>name</span><span class=p>:</span> <span class=nb>str</span> <span class=o>=</span> <span class=n>real_bucket_hash</span>


<span class=k>def</span> <span class=nf>_create_unknown_hash</span><span class=p>(</span><span class=n>route</span><span class=p>:</span> <span class=n>routes</span><span class=o>.</span><span class=n>CompiledRoute</span><span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>
    <span class=k>return</span> <span class=n>UNKNOWN_HASH</span> <span class=o>+</span> <span class=n>routes</span><span class=o>.</span><span class=n>HASH_SEPARATOR</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=nb>hash</span><span class=p>(</span><span class=n>route</span><span class=p>))</span>


<span class=k>class</span> <span class=nc>RESTBucketManager</span><span class=p>:</span>
    <span class=sd>"""The main rate limiter implementation for HTTP clients.</span>

<span class=sd>    This is designed to provide bucketed rate limiting for Discord HTTP</span>
<span class=sd>    endpoints that respects the `X-RateLimit-Bucket` rate limit header. To do</span>
<span class=sd>    this, it makes the assumption that any limit can change at any time.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    max_rate_limit : float</span>
<span class=sd>        The max number of seconds to backoff for when rate limited. Anything</span>
<span class=sd>        greater than this will instead raise an error.</span>
<span class=sd>    """</span>

    <span class=vm>__slots__</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span>
        <span class=s2>"routes_to_hashes"</span><span class=p>,</span>
        <span class=s2>"real_hashes_to_buckets"</span><span class=p>,</span>
        <span class=s2>"closed_event"</span><span class=p>,</span>
        <span class=s2>"gc_task"</span><span class=p>,</span>
        <span class=s2>"max_rate_limit"</span><span class=p>,</span>
    <span class=p>)</span>

    <span class=n>routes_to_hashes</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Final</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>MutableMapping</span><span class=p>[</span><span class=n>routes</span><span class=o>.</span><span class=n>Route</span><span class=p>,</span> <span class=nb>str</span><span class=p>]]</span>
    <span class=sd>"""Maps routes to their `X-RateLimit-Bucket` header being used."""</span>

    <span class=n>real_hashes_to_buckets</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Final</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>MutableMapping</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>RESTBucket</span><span class=p>]]</span>
    <span class=sd>"""Maps full bucket hashes (`X-RateLimit-Bucket` appended with a hash of</span>
<span class=sd>    major parameters used in that compiled route) to their corresponding rate</span>
<span class=sd>    limiters.</span>
<span class=sd>    """</span>

    <span class=n>closed_event</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Final</span><span class=p>[</span><span class=n>asyncio</span><span class=o>.</span><span class=n>Event</span><span class=p>]</span>
    <span class=sd>"""An internal event that is set when the object is shut down."""</span>

    <span class=n>gc_task</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=n>asyncio</span><span class=o>.</span><span class=n>Task</span><span class=p>[</span><span class=kc>None</span><span class=p>]]</span>
    <span class=sd>"""The internal garbage collector task."""</span>

    <span class=n>max_rate_limit</span><span class=p>:</span> <span class=nb>float</span>
    <span class=sd>"""The max number of seconds to backoff for when rate limited.</span>

<span class=sd>    Anything greater than this will instead raise an error.</span>
<span class=sd>    """</span>

    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>max_rate_limit</span><span class=p>:</span> <span class=nb>float</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>routes_to_hashes</span> <span class=o>=</span> <span class=p>{}</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span> <span class=o>=</span> <span class=p>{}</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>closed_event</span><span class=p>:</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>Event</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>Event</span><span class=p>()</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=n>asyncio</span><span class=o>.</span><span class=n>Task</span><span class=p>[</span><span class=kc>None</span><span class=p>]]</span> <span class=o>=</span> <span class=kc>None</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>max_rate_limit</span> <span class=o>=</span> <span class=n>max_rate_limit</span>

    <span class=k>def</span> <span class=fm>__enter__</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>RESTBucketManager</span><span class=p>:</span>
        <span class=k>return</span> <span class=bp>self</span>

    <span class=k>def</span> <span class=fm>__exit__</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>exc_type</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Type</span><span class=p>[</span><span class=ne>Exception</span><span class=p>]],</span>
        <span class=n>exc_val</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=ne>Exception</span><span class=p>],</span>
        <span class=n>exc_tb</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=n>types</span><span class=o>.</span><span class=n>TracebackType</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>

    <span class=k>def</span> <span class=fm>__del__</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>

    <span class=k>def</span> <span class=nf>start</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>poll_period</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>20.0</span><span class=p>,</span> <span class=n>expire_after</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>10.0</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Start this ratelimiter up.</span>

<span class=sd>        This spins up internal garbage collection logic in the background to</span>
<span class=sd>        keep memory usage to an optimal level as old routes and bucket hashes</span>
<span class=sd>        get discarded and replaced.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        poll_period : float</span>
<span class=sd>            Period to poll the garbage collector at in seconds. Defaults</span>
<span class=sd>            to `20` seconds.</span>
<span class=sd>        expire_after : float</span>
<span class=sd>            Time after which the last `reset_at` was hit for a bucket to</span>
<span class=sd>            remove it. Higher values will retain unneeded ratelimit info for</span>
<span class=sd>            longer, but may produce more effective rate-limiting logic as a</span>
<span class=sd>            result. Using `0` will make the bucket get garbage collected as soon</span>
<span class=sd>            as the rate limit has reset. Defaults to `10` seconds.</span>
<span class=sd>        """</span>
        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>gc</span><span class=p>(</span><span class=n>poll_period</span><span class=p>,</span> <span class=n>expire_after</span><span class=p>))</span>

    <span class=k>def</span> <span class=nf>close</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Close the garbage collector and kill any tasks waiting on ratelimits.</span>

<span class=sd>        Once this has been called, this object is considered to be effectively</span>
<span class=sd>        dead. To reuse it, one should create a new instance.</span>
<span class=sd>        """</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>closed_event</span><span class=o>.</span><span class=n>set</span><span class=p>()</span>
        <span class=k>for</span> <span class=n>bucket</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=o>.</span><span class=n>values</span><span class=p>():</span>
            <span class=n>bucket</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>routes_to_hashes</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>

        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span><span class=o>.</span><span class=n>cancel</span><span class=p>()</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span> <span class=o>=</span> <span class=kc>None</span>

    <span class=c1># Ignore docstring not starting in an imperative mood</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>gc</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>poll_period</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span> <span class=n>expire_after</span><span class=p>:</span> <span class=nb>float</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Run the garbage collector loop.</span>

<span class=sd>        This is designed to run in the background and manage removing unused</span>
<span class=sd>        route references from the rate-limiter collection to save memory.</span>

<span class=sd>        This will run forever until `RESTBucketManager.closed_event` is set.</span>
<span class=sd>        This will invoke `RESTBucketManager.do_gc_pass` periodically.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            You generally have no need to invoke this directly. Use</span>
<span class=sd>            `RESTBucketManager.start` and `RESTBucketManager.close` to control</span>
<span class=sd>            this instead.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        poll_period : float</span>
<span class=sd>            The period to poll at.</span>
<span class=sd>        expire_after : float</span>
<span class=sd>            Time after which the last `reset_at` was hit for a bucket to</span>
<span class=sd>            remove it. Higher values will retain unneeded ratelimit info for</span>
<span class=sd>            longer, but may produce more effective ratelimiting logic as a</span>
<span class=sd>            result. Using `0` will make the bucket get garbage collected as soon</span>
<span class=sd>            as the rate limit has reset.</span>
<span class=sd>        """</span>
        <span class=c1># Prevent filling memory increasingly until we run out by removing dead buckets every 20s</span>
        <span class=c1># Allocations are somewhat cheap if we only do them every so-many seconds, after all.</span>
        <span class=n>_LOGGER</span><span class=o>.</span><span class=n>log</span><span class=p>(</span><span class=n>ux</span><span class=o>.</span><span class=n>TRACE</span><span class=p>,</span> <span class=s2>"rate limit garbage collector started"</span><span class=p>)</span>
        <span class=k>while</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>closed_event</span><span class=o>.</span><span class=n>is_set</span><span class=p>():</span>
            <span class=k>try</span><span class=p>:</span>
                <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>wait_for</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>closed_event</span><span class=o>.</span><span class=n>wait</span><span class=p>(),</span> <span class=n>timeout</span><span class=o>=</span><span class=n>poll_period</span><span class=p>)</span>
            <span class=k>except</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>TimeoutError</span><span class=p>:</span>
                <span class=n>_LOGGER</span><span class=o>.</span><span class=n>log</span><span class=p>(</span><span class=n>ux</span><span class=o>.</span><span class=n>TRACE</span><span class=p>,</span> <span class=s2>"performing rate limit garbage collection pass"</span><span class=p>)</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>do_gc_pass</span><span class=p>(</span><span class=n>expire_after</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span> <span class=o>=</span> <span class=kc>None</span>

    <span class=k>def</span> <span class=nf>do_gc_pass</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>expire_after</span><span class=p>:</span> <span class=nb>float</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Perform a single garbage collection pass.</span>

<span class=sd>        This will assess any routes stored in the internal mappings of this</span>
<span class=sd>        object and remove any that are deemed to be inactive or dead in order</span>
<span class=sd>        to save memory.</span>

<span class=sd>        If the removed routes are used again in the future, they will be</span>
<span class=sd>        re-cached automatically.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            You generally have no need to invoke this directly. Use</span>
<span class=sd>            `RESTBucketManager.start` and `RESTBucketManager.close` to control</span>
<span class=sd>            this instead.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        expire_after : float</span>
<span class=sd>            Time after which the last `reset_at` was hit for a bucket to\</span>
<span class=sd>            remove it. Defaults to `reset_at` + 20 seconds. Higher values will</span>
<span class=sd>            retain unneeded ratelimit info for longer, but may produce more</span>
<span class=sd>            effective ratelimiting logic as a result.</span>
<span class=sd>        """</span>
        <span class=n>buckets_to_purge</span> <span class=o>=</span> <span class=p>[]</span>

        <span class=n>now</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>monotonic</span><span class=p>()</span>

        <span class=c1># We have three main states that a bucket can be in:</span>
        <span class=c1># 1. active - the bucket is active and is not at risk of deallocation</span>
        <span class=c1># 2. survival - the bucket is inactive but is still fresh enough to be kept alive.</span>
        <span class=c1># 3. death - the bucket has been inactive for too long.</span>
        <span class=n>active</span> <span class=o>=</span> <span class=mi>0</span>

        <span class=c1># Discover and purge</span>
        <span class=n>bucket_pairs</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=o>.</span><span class=n>items</span><span class=p>()</span>

        <span class=k>for</span> <span class=n>full_hash</span><span class=p>,</span> <span class=n>bucket</span> <span class=ow>in</span> <span class=n>bucket_pairs</span><span class=p>:</span>
            <span class=k>if</span> <span class=n>bucket</span><span class=o>.</span><span class=n>is_empty</span> <span class=ow>and</span> <span class=n>bucket</span><span class=o>.</span><span class=n>reset_at</span> <span class=o>+</span> <span class=n>expire_after</span> <span class=o><</span> <span class=n>now</span><span class=p>:</span>
                <span class=c1># If it is still running a throttle and is in memory, it will remain in memory</span>
                <span class=c1># but we will not know about it.</span>
                <span class=n>buckets_to_purge</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>full_hash</span><span class=p>)</span>

            <span class=k>if</span> <span class=n>bucket</span><span class=o>.</span><span class=n>reset_at</span> <span class=o>>=</span> <span class=n>now</span><span class=p>:</span>
                <span class=n>active</span> <span class=o>+=</span> <span class=mi>1</span>

        <span class=n>dead</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>buckets_to_purge</span><span class=p>)</span>
        <span class=n>total</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>bucket_pairs</span><span class=p>)</span>
        <span class=n>survival</span> <span class=o>=</span> <span class=n>total</span> <span class=o>-</span> <span class=n>active</span> <span class=o>-</span> <span class=n>dead</span>

        <span class=k>for</span> <span class=n>full_hash</span> <span class=ow>in</span> <span class=n>buckets_to_purge</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=p>[</span><span class=n>full_hash</span><span class=p>]</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
            <span class=k>del</span> <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=p>[</span><span class=n>full_hash</span><span class=p>]</span>

        <span class=n>_LOGGER</span><span class=o>.</span><span class=n>log</span><span class=p>(</span><span class=n>ux</span><span class=o>.</span><span class=n>TRACE</span><span class=p>,</span> <span class=s2>"purged </span><span class=si>%s</span><span class=s2> stale buckets, </span><span class=si>%s</span><span class=s2> remain in survival, </span><span class=si>%s</span><span class=s2> active"</span><span class=p>,</span> <span class=n>dead</span><span class=p>,</span> <span class=n>survival</span><span class=p>,</span> <span class=n>active</span><span class=p>)</span>

    <span class=k>def</span> <span class=nf>acquire</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>compiled_route</span><span class=p>:</span> <span class=n>routes</span><span class=o>.</span><span class=n>CompiledRoute</span><span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>AsyncContextManager</span><span class=p>[</span><span class=kc>None</span><span class=p>]:</span>
        <span class=sd>"""Acquire a bucket for the given route.</span>

<span class=sd>        .. note::</span>
<span class=sd>            You MUST keep the context manager acquired during the whole of the</span>
<span class=sd>            request. From making the request until calling `update_rate_limits`.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        compiled_route : hikari.internal.routes.CompiledRoute</span>
<span class=sd>            The route to get the bucket for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.AsyncContextManager[None]</span>
<span class=sd>            A context manager to enter while doing the request.</span>
<span class=sd>        """</span>
        <span class=n>template</span> <span class=o>=</span> <span class=n>compiled_route</span><span class=o>.</span><span class=n>route</span>

        <span class=k>try</span><span class=p>:</span>
            <span class=n>bucket_hash</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>routes_to_hashes</span><span class=p>[</span><span class=n>template</span><span class=p>]</span>
            <span class=n>real_bucket_hash</span> <span class=o>=</span> <span class=n>compiled_route</span><span class=o>.</span><span class=n>create_real_bucket_hash</span><span class=p>(</span><span class=n>bucket_hash</span><span class=p>)</span>
        <span class=k>except</span> <span class=ne>KeyError</span><span class=p>:</span>
            <span class=n>real_bucket_hash</span> <span class=o>=</span> <span class=n>_create_unknown_hash</span><span class=p>(</span><span class=n>compiled_route</span><span class=p>)</span>

        <span class=k>try</span><span class=p>:</span>
            <span class=n>bucket</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=p>[</span><span class=n>real_bucket_hash</span><span class=p>]</span>
            <span class=n>_LOGGER</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span><span class=s2>"</span><span class=si>%s</span><span class=s2> is being mapped to existing bucket </span><span class=si>%s</span><span class=s2>"</span><span class=p>,</span> <span class=n>compiled_route</span><span class=p>,</span> <span class=n>real_bucket_hash</span><span class=p>)</span>
        <span class=k>except</span> <span class=ne>KeyError</span><span class=p>:</span>
            <span class=n>_LOGGER</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span><span class=s2>"</span><span class=si>%s</span><span class=s2> is being mapped to new bucket </span><span class=si>%s</span><span class=s2>"</span><span class=p>,</span> <span class=n>compiled_route</span><span class=p>,</span> <span class=n>real_bucket_hash</span><span class=p>)</span>
            <span class=n>bucket</span> <span class=o>=</span> <span class=n>RESTBucket</span><span class=p>(</span><span class=n>real_bucket_hash</span><span class=p>,</span> <span class=n>compiled_route</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>max_rate_limit</span><span class=p>)</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=p>[</span><span class=n>real_bucket_hash</span><span class=p>]</span> <span class=o>=</span> <span class=n>bucket</span>

        <span class=k>return</span> <span class=n>bucket</span>

    <span class=k>def</span> <span class=nf>update_rate_limits</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>compiled_route</span><span class=p>:</span> <span class=n>routes</span><span class=o>.</span><span class=n>CompiledRoute</span><span class=p>,</span>
        <span class=n>bucket_header</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>remaining_header</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span>
        <span class=n>limit_header</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span>
        <span class=n>reset_after</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Update the rate limits for a bucket using info from a response.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        compiled_route : hikari.internal.routes.CompiledRoute</span>
<span class=sd>            The compiled route to get the bucket for.</span>
<span class=sd>        bucket_header : typing.Optional[str]</span>
<span class=sd>            The `X-RateLimit-Bucket` header that was provided in the response.</span>
<span class=sd>        remaining_header : int</span>
<span class=sd>            The `X-RateLimit-Remaining` header cast to an `int`.</span>
<span class=sd>        limit_header : int</span>
<span class=sd>            The `X-RateLimit-Limit` header cast to an `int`.</span>
<span class=sd>        reset_after : float</span>
<span class=sd>            The `X-RateLimit-Reset-After` header cast to a `float`.</span>
<span class=sd>        """</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>routes_to_hashes</span><span class=p>[</span><span class=n>compiled_route</span><span class=o>.</span><span class=n>route</span><span class=p>]</span> <span class=o>=</span> <span class=n>bucket_header</span>
        <span class=n>real_bucket_hash</span> <span class=o>=</span> <span class=n>compiled_route</span><span class=o>.</span><span class=n>create_real_bucket_hash</span><span class=p>(</span><span class=n>bucket_header</span><span class=p>)</span>

        <span class=k>if</span> <span class=n>bucket</span> <span class=o>:=</span> <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>real_bucket_hash</span><span class=p>):</span>
            <span class=n>_LOGGER</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span>
                <span class=s2>"updating </span><span class=si>%s</span><span class=s2> with bucket </span><span class=si>%s</span><span class=s2> [reset-after:</span><span class=si>%s</span><span class=s2>s, limit:</span><span class=si>%s</span><span class=s2>, remaining:</span><span class=si>%s</span><span class=s2>]"</span><span class=p>,</span>
                <span class=n>compiled_route</span><span class=p>,</span>
                <span class=n>real_bucket_hash</span><span class=p>,</span>
                <span class=n>reset_after</span><span class=p>,</span>
                <span class=n>limit_header</span><span class=p>,</span>
                <span class=n>remaining_header</span><span class=p>,</span>
            <span class=p>)</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>unknown_bucket_hash</span> <span class=o>=</span> <span class=n>_create_unknown_hash</span><span class=p>(</span><span class=n>compiled_route</span><span class=p>)</span>

            <span class=k>if</span> <span class=n>bucket</span> <span class=o>:=</span> <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=n>unknown_bucket_hash</span><span class=p>,</span> <span class=kc>None</span><span class=p>):</span>
                <span class=n>bucket</span><span class=o>.</span><span class=n>resolve</span><span class=p>(</span><span class=n>real_bucket_hash</span><span class=p>)</span>
                <span class=n>_LOGGER</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span>
                    <span class=s2>"remapping </span><span class=si>%s</span><span class=s2> with existing bucket </span><span class=si>%s</span><span class=s2> [reset-after:</span><span class=si>%s</span><span class=s2>s, limit:</span><span class=si>%s</span><span class=s2>, remaining:</span><span class=si>%s</span><span class=s2>]"</span><span class=p>,</span>
                    <span class=n>compiled_route</span><span class=p>,</span>
                    <span class=n>unknown_bucket_hash</span><span class=p>,</span>
                    <span class=n>reset_after</span><span class=p>,</span>
                    <span class=n>limit_header</span><span class=p>,</span>
                    <span class=n>remaining_header</span><span class=p>,</span>
                <span class=p>)</span>
            <span class=k>else</span><span class=p>:</span>
                <span class=n>_LOGGER</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span>
                    <span class=s2>"remapping </span><span class=si>%s</span><span class=s2> with new bucket </span><span class=si>%s</span><span class=s2> [reset-after:</span><span class=si>%s</span><span class=s2>s, limit:</span><span class=si>%s</span><span class=s2>, remaining:</span><span class=si>%s</span><span class=s2>]"</span><span class=p>,</span>
                    <span class=n>compiled_route</span><span class=p>,</span>
                    <span class=n>real_bucket_hash</span><span class=p>,</span>
                    <span class=n>reset_after</span><span class=p>,</span>
                    <span class=n>limit_header</span><span class=p>,</span>
                    <span class=n>remaining_header</span><span class=p>,</span>
                <span class=p>)</span>
                <span class=n>bucket</span> <span class=o>=</span> <span class=n>RESTBucket</span><span class=p>(</span><span class=n>real_bucket_hash</span><span class=p>,</span> <span class=n>compiled_route</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>max_rate_limit</span><span class=p>)</span>

            <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=p>[</span><span class=n>real_bucket_hash</span><span class=p>]</span> <span class=o>=</span> <span class=n>bucket</span>

        <span class=n>reset_at_monotonic</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>monotonic</span><span class=p>()</span> <span class=o>+</span> <span class=n>reset_after</span>
        <span class=n>bucket</span><span class=o>.</span><span class=n>update_rate_limit</span><span class=p>(</span><span class=n>remaining_header</span><span class=p>,</span> <span class=n>limit_header</span><span class=p>,</span> <span class=n>reset_at_monotonic</span><span class=p>)</span>

    <span class=nd>@property</span>
    <span class=k>def</span> <span class=nf>is_started</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=nb>bool</span><span class=p>:</span>
        <span class=sd>"""Return `True` if the rate limiter GC task is started."""</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span>
</pre></div></details></section><section id=RESTBucket><div class="attr class"><a class=headerlink href=#RESTBucket>#</a><span class=def>class</span><span class=name>RESTBucket</span><wbr>(<span class=base><a href=rate_limits.html#WindowedBurstRateLimiter>hikari.impl.rate_limits.WindowedBurstRateLimiter</a></span>):</div><details><summary>View Source</summary> <div class=codehilite><pre><span></span><span class=k>class</span> <span class=nc>RESTBucket</span><span class=p>(</span><span class=n>rate_limits</span><span class=o>.</span><span class=n>WindowedBurstRateLimiter</span><span class=p>):</span>
    <span class=sd>"""Represents a rate limit for an HTTP endpoint.</span>

<span class=sd>    Component to represent an active rate limit bucket on a specific HTTP route</span>
<span class=sd>    with a specific major parameter combo.</span>

<span class=sd>    This is somewhat similar to the `WindowedBurstRateLimiter` in how it</span>
<span class=sd>    works.</span>

<span class=sd>    This algorithm will use fixed-period time windows that have a given limit</span>
<span class=sd>    (capacity). Each time a task requests processing time, it will drip another</span>
<span class=sd>    unit into the bucket. Once the bucket has reached its limit, nothing can</span>
<span class=sd>    drip and new tasks will be queued until the time window finishes.</span>

<span class=sd>    Once the time window finishes, the bucket will empty, returning the current</span>
<span class=sd>    capacity to zero, and tasks that are queued will start being able to drip</span>
<span class=sd>    again.</span>

<span class=sd>    Additional logic is provided by the `RESTBucket.update_rate_limit` call</span>
<span class=sd>    which allows dynamically changing the enforced rate limits at any time.</span>
<span class=sd>    """</span>

    <span class=vm>__slots__</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=s2>"_compiled_route"</span><span class=p>,</span> <span class=s2>"_max_rate_limit"</span><span class=p>,</span> <span class=s2>"_lock"</span><span class=p>)</span>

    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>compiled_route</span><span class=p>:</span> <span class=n>routes</span><span class=o>.</span><span class=n>CompiledRoute</span><span class=p>,</span> <span class=n>max_rate_limit</span><span class=p>:</span> <span class=nb>float</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_compiled_route</span> <span class=o>=</span> <span class=n>compiled_route</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_max_rate_limit</span> <span class=o>=</span> <span class=n>max_rate_limit</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_lock</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>Lock</span><span class=p>()</span>

    <span class=k>async</span> <span class=k>def</span> <span class=fm>__aenter__</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>acquire</span><span class=p>()</span>

    <span class=k>async</span> <span class=k>def</span> <span class=fm>__aexit__</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>exc_type</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Type</span><span class=p>[</span><span class=ne>BaseException</span><span class=p>]],</span>
        <span class=n>exc</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=ne>BaseException</span><span class=p>],</span>
        <span class=n>exc_tb</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=n>types</span><span class=o>.</span><span class=n>TracebackType</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_lock</span><span class=o>.</span><span class=n>release</span><span class=p>()</span>

    <span class=nd>@property</span>
    <span class=k>def</span> <span class=nf>is_unknown</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=nb>bool</span><span class=p>:</span>
        <span class=sd>"""Return `True` if the bucket represents an `UNKNOWN` bucket."""</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>name</span><span class=o>.</span><span class=n>startswith</span><span class=p>(</span><span class=n>UNKNOWN_HASH</span><span class=p>)</span>

    <span class=k>async</span> <span class=k>def</span> <span class=nf>acquire</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Acquire time on this rate limiter.</span>

<span class=sd>        .. note::</span>
<span class=sd>            You should afterwards invoke `RESTBucket.update_rate_limit` to</span>
<span class=sd>            update any rate limit information you are made aware of.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            If the rate limit is longer than `max_rate_limit`.</span>
<span class=sd>        """</span>
        <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>_lock</span><span class=o>.</span><span class=n>acquire</span><span class=p>()</span>

        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_unknown</span><span class=p>:</span>
            <span class=k>return</span>

        <span class=n>now</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>monotonic</span><span class=p>()</span>
        <span class=n>retry_after</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>reset_at</span> <span class=o>-</span> <span class=n>now</span>

        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_rate_limited</span><span class=p>(</span><span class=n>now</span><span class=p>)</span> <span class=ow>and</span> <span class=n>retry_after</span> <span class=o>></span> <span class=bp>self</span><span class=o>.</span><span class=n>_max_rate_limit</span><span class=p>:</span>
            <span class=k>raise</span> <span class=n>errors</span><span class=o>.</span><span class=n>RateLimitTooLongError</span><span class=p>(</span>
                <span class=n>route</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>_compiled_route</span><span class=p>,</span>
                <span class=n>retry_after</span><span class=o>=</span><span class=n>retry_after</span><span class=p>,</span>
                <span class=n>max_retry_after</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>_max_rate_limit</span><span class=p>,</span>
                <span class=n>reset_at</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>reset_at</span><span class=p>,</span>
                <span class=n>limit</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>limit</span><span class=p>,</span>
                <span class=n>period</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>period</span><span class=p>,</span>
            <span class=p>)</span>

        <span class=k>await</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>acquire</span><span class=p>()</span>

    <span class=k>def</span> <span class=nf>update_rate_limit</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>remaining</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>limit</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>reset_at</span><span class=p>:</span> <span class=nb>float</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Update the rate limit information.</span>

<span class=sd>        .. note::</span>
<span class=sd>            The `reset_at` epoch is expected to be a `time.monotonic_timestamp`</span>
<span class=sd>            monotonic epoch, rather than a `time.time` date-based epoch.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        remaining : int</span>
<span class=sd>            The calls remaining in this time window.</span>
<span class=sd>        limit : int</span>
<span class=sd>            The total calls allowed in this time window.</span>
<span class=sd>        reset_at : float</span>
<span class=sd>            The epoch at which to reset the limit.</span>
<span class=sd>        """</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>remaining</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=n>remaining</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>limit</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=n>limit</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>reset_at</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=n>reset_at</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>period</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=mf>0.0</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>reset_at</span> <span class=o>-</span> <span class=n>time</span><span class=o>.</span><span class=n>monotonic</span><span class=p>())</span>

    <span class=k>def</span> <span class=nf>drip</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Decrement the remaining count for this bucket.</span>

<span class=sd>        .. note::</span>
<span class=sd>            If the bucket is marked as `RESTBucket.is_unknown`, then this will</span>
<span class=sd>            not do anything. `Unknown` buckets have infinite rate limits.</span>
<span class=sd>        """</span>
        <span class=c1># We don't drip unknown buckets: we cannot rate limit them as we don't know their real bucket hash or</span>
        <span class=c1># the current rate limit values Discord put on them...</span>
        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_unknown</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>remaining</span> <span class=o>-=</span> <span class=mi>1</span>

    <span class=k>def</span> <span class=nf>resolve</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>real_bucket_hash</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Resolve an unknown bucket.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        real_bucket_hash: str</span>
<span class=sd>            The real bucket hash for this bucket.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        RuntimeError</span>
<span class=sd>            If the hash of the bucket is already known.</span>
<span class=sd>        """</span>
        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_unknown</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>RuntimeError</span><span class=p>(</span><span class=s2>"Cannot resolve known bucket"</span><span class=p>)</span>

        <span class=bp>self</span><span class=o>.</span><span class=n>name</span><span class=p>:</span> <span class=nb>str</span> <span class=o>=</span> <span class=n>real_bucket_hash</span>
</pre></div></details><div class=docstring><p>Represents a rate limit for an HTTP endpoint.<p>Component to represent an active rate limit bucket on a specific HTTP route with a specific major parameter combo.<p>This is somewhat similar to the <code>WindowedBurstRateLimiter</code> in how it works.<p>This algorithm will use fixed-period time windows that have a given limit (capacity). Each time a task requests processing time, it will drip another unit into the bucket. Once the bucket has reached its limit, nothing can drip and new tasks will be queued until the time window finishes.<p>Once the time window finishes, the bucket will empty, returning the current capacity to zero, and tasks that are queued will start being able to drip again.<p>Additional logic is provided by the <code><a href=#RESTBucket.update_rate_limit>RESTBucket.update_rate_limit</a></code> call which allows dynamically changing the enforced rate limits at any time.</div><section class=member_divisor><h5>Variables and properties</h5><div id=RESTBucket.is_empty><div class="attr variable"><a class=headerlink href=#RESTBucket.is_empty>#</a><span class=name>is_empty</span><span class=annotation>: bool</span></div><div class=docstring><p>Return <code>True</code> if no futures are on the queue being rate limited.</div></div><div id=RESTBucket.is_unknown><div class="attr variable"><a class=headerlink href=#RESTBucket.is_unknown>#</a><span class=name>is_unknown</span><span class=annotation>: bool</span></div><div class=docstring><p>Return <code>True</code> if the bucket represents an <code>UNKNOWN</code> bucket.</div></div><div id=RESTBucket.limit><div class="attr variable"><a class=headerlink href=#RESTBucket.limit>#</a><span class=name>limit</span><span class=annotation>: int</span></div><div class=docstring><p>The maximum number of <code>WindowedBurstRateLimiter.acquire</code>'s allowed in this time window.</div></div><div id=RESTBucket.name><div class="attr variable"><a class=headerlink href=#RESTBucket.name>#</a><span class=name>name</span><span class=annotation>: str</span></div><div class=docstring><p>The name of the rate limiter.</div></div><div id=RESTBucket.period><div class="attr variable"><a class=headerlink href=#RESTBucket.period>#</a><span class=name>period</span><span class=annotation>: float</span></div><div class=docstring><p>How long the window lasts for from the start in seconds.</div></div><div id=RESTBucket.queue><div class="attr variable"><a class=headerlink href=#RESTBucket.queue>#</a><span class=name>queue</span><span class=annotation>: List[_asyncio.Future]</span></div><div class=docstring><p>The queue of any futures under a rate limit.</div></div><div id=RESTBucket.remaining><div class="attr variable"><a class=headerlink href=#RESTBucket.remaining>#</a><span class=name>remaining</span><span class=annotation>: int</span></div><div class=docstring><p>The number of <code>WindowedBurstRateLimiter.acquire</code>'s left in this window before you will get rate limited.</div></div><div id=RESTBucket.reset_at><div class="attr variable"><a class=headerlink href=#RESTBucket.reset_at>#</a><span class=name>reset_at</span><span class=annotation>: float</span></div><div class=docstring><p>The <code>time.monotonic_timestamp</code> that the limit window ends at.</div></div><div id=RESTBucket.throttle_task><div class="attr variable"><a class=headerlink href=#RESTBucket.throttle_task>#</a><span class=name>throttle_task</span><span class=annotation>: Optional[_asyncio.Task]</span></div><div class=docstring><p>The throttling task, or <code>None</code> if it is not running.</div></div></section><section class=member_divisor><h5>Methods</h5><div id=RESTBucket.__init__><div class="attr function"><a class=headerlink href=#RESTBucket.__init__>#</a><span class=def>def</span><span class=name>__init__</span><span class=signature>(<br> self,<br> name: str,<br> compiled_route: <a href=../internal/routes.html#CompiledRoute>hikari.internal.routes.CompiledRoute</a>,<br> max_rate_limit: float<br>):</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>compiled_route</span><span class=p>:</span> <span class=n>routes</span><span class=o>.</span><span class=n>CompiledRoute</span><span class=p>,</span> <span class=n>max_rate_limit</span><span class=p>:</span> <span class=nb>float</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_compiled_route</span> <span class=o>=</span> <span class=n>compiled_route</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_max_rate_limit</span> <span class=o>=</span> <span class=n>max_rate_limit</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_lock</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>Lock</span><span class=p>()</span>
</pre></div></details></div><div id=RESTBucket.acquire><div class="attr function"><a class=headerlink href=#RESTBucket.acquire>#</a><span class=def>async def</span><span class=name>acquire</span><span class=signature>(self) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=k>async</span> <span class=k>def</span> <span class=nf>acquire</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Acquire time on this rate limiter.</span>

<span class=sd>        .. note::</span>
<span class=sd>            You should afterwards invoke `RESTBucket.update_rate_limit` to</span>
<span class=sd>            update any rate limit information you are made aware of.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            If the rate limit is longer than `max_rate_limit`.</span>
<span class=sd>        """</span>
        <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>_lock</span><span class=o>.</span><span class=n>acquire</span><span class=p>()</span>

        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_unknown</span><span class=p>:</span>
            <span class=k>return</span>

        <span class=n>now</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>monotonic</span><span class=p>()</span>
        <span class=n>retry_after</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>reset_at</span> <span class=o>-</span> <span class=n>now</span>

        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_rate_limited</span><span class=p>(</span><span class=n>now</span><span class=p>)</span> <span class=ow>and</span> <span class=n>retry_after</span> <span class=o>></span> <span class=bp>self</span><span class=o>.</span><span class=n>_max_rate_limit</span><span class=p>:</span>
            <span class=k>raise</span> <span class=n>errors</span><span class=o>.</span><span class=n>RateLimitTooLongError</span><span class=p>(</span>
                <span class=n>route</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>_compiled_route</span><span class=p>,</span>
                <span class=n>retry_after</span><span class=o>=</span><span class=n>retry_after</span><span class=p>,</span>
                <span class=n>max_retry_after</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>_max_rate_limit</span><span class=p>,</span>
                <span class=n>reset_at</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>reset_at</span><span class=p>,</span>
                <span class=n>limit</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>limit</span><span class=p>,</span>
                <span class=n>period</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>period</span><span class=p>,</span>
            <span class=p>)</span>

        <span class=k>await</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>acquire</span><span class=p>()</span>
</pre></div></details><div class=docstring><p>Acquire time on this rate limiter.<p><em>Note:</em> You should afterwards invoke <code><a href=#RESTBucket.update_rate_limit>RESTBucket.update_rate_limit</a></code> to update any rate limit information you are made aware of.<h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: If the rate limit is longer than <code>max_rate_limit</code>.</ul></div></div><div id=RESTBucket.close><div class="attr function"><a class=headerlink href=#RESTBucket.close>#</a><span class=def>def</span><span class=name>close</span><span class=signature>(self) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=k>def</span> <span class=nf>close</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Close the rate limiter, and shut down any pending tasks.</span>

<span class=sd>        Once this is invoked, you should not reuse this object.</span>
<span class=sd>        """</span>
        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_closed</span><span class=p>:</span>
            <span class=k>return</span>

        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>throttle_task</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>throttle_task</span><span class=o>.</span><span class=n>cancel</span><span class=p>()</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>throttle_task</span> <span class=o>=</span> <span class=kc>None</span>

        <span class=n>failed_tasks</span> <span class=o>=</span> <span class=mi>0</span>
        <span class=k>while</span> <span class=bp>self</span><span class=o>.</span><span class=n>queue</span><span class=p>:</span>
            <span class=n>failed_tasks</span> <span class=o>+=</span> <span class=mi>1</span>
            <span class=n>future</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>queue</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
            <span class=c1># Make the future complete with an exception</span>
            <span class=n>future</span><span class=o>.</span><span class=n>cancel</span><span class=p>()</span>

        <span class=k>if</span> <span class=n>failed_tasks</span><span class=p>:</span>
            <span class=n>_LOGGER</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span><span class=s2>"</span><span class=si>%s</span><span class=s2> rate limiter closed with </span><span class=si>%s</span><span class=s2> pending tasks!"</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>name</span><span class=p>,</span> <span class=n>failed_tasks</span><span class=p>)</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>_LOGGER</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span><span class=s2>"</span><span class=si>%s</span><span class=s2> rate limiter closed"</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>name</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>_closed</span> <span class=o>=</span> <span class=kc>True</span>
</pre></div></details><div class=docstring><p>Close the rate limiter, and shut down any pending tasks.<p>Once this is invoked, you should not reuse this object.</div></div><div id=RESTBucket.drip><div class="attr function"><a class=headerlink href=#RESTBucket.drip>#</a><span class=def>def</span><span class=name>drip</span><span class=signature>(self) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=k>def</span> <span class=nf>drip</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Decrement the remaining count for this bucket.</span>

<span class=sd>        .. note::</span>
<span class=sd>            If the bucket is marked as `RESTBucket.is_unknown`, then this will</span>
<span class=sd>            not do anything. `Unknown` buckets have infinite rate limits.</span>
<span class=sd>        """</span>
        <span class=c1># We don't drip unknown buckets: we cannot rate limit them as we don't know their real bucket hash or</span>
        <span class=c1># the current rate limit values Discord put on them...</span>
        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_unknown</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>remaining</span> <span class=o>-=</span> <span class=mi>1</span>
</pre></div></details><div class=docstring><p>Decrement the remaining count for this bucket.<p><em>Note:</em> If the bucket is marked as <code><a href=#RESTBucket.is_unknown>RESTBucket.is_unknown</a></code>, then this will not do anything. <code>Unknown</code> buckets have infinite rate limits.</div></div><div id=RESTBucket.get_time_until_reset><div class="attr function"><a class=headerlink href=#RESTBucket.get_time_until_reset>#</a><span class=def>def</span><span class=name>get_time_until_reset</span><span class=signature>(self, now: float) -> float:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=k>def</span> <span class=nf>get_time_until_reset</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>now</span><span class=p>:</span> <span class=nb>float</span><span class=p>)</span> <span class=o>-></span> <span class=nb>float</span><span class=p>:</span>
        <span class=sd>"""Determine how long until the current rate limit is reset.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            Invoking this method will update the internal state if we were</span>
<span class=sd>            previously rate limited, but at the given time are no longer under</span>
<span class=sd>            that limit. This makes it imperative that you only pass the current</span>
<span class=sd>            timestamp to this function, and not past or future timestamps. The</span>
<span class=sd>            effects of doing the latter are undefined behaviour.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        now : float</span>
<span class=sd>            The monotonic `time.monotonic_timestamp` timestamp.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        float</span>
<span class=sd>            The time left to sleep before the rate limit is reset. If no rate limit</span>
<span class=sd>            is in effect, then this will return `0.0` instead.</span>
<span class=sd>        """</span>
        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_rate_limited</span><span class=p>(</span><span class=n>now</span><span class=p>):</span>
            <span class=k>return</span> <span class=mf>0.0</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>reset_at</span> <span class=o>-</span> <span class=n>now</span>
</pre></div></details><div class=docstring><p>Determine how long until the current rate limit is reset.<p><em>Warning:</em> Invoking this method will update the internal state if we were previously rate limited, but at the given time are no longer under that limit. This makes it imperative that you only pass the current timestamp to this function, and not past or future timestamps. The effects of doing the latter are undefined behaviour.<h6 id=parameters>Parameters</h6><ul><li><strong>now</strong> (float): The monotonic <code>time.monotonic_timestamp</code> timestamp.</ul><h6 id=returns>Returns</h6><ul><li><strong>float</strong>: The time left to sleep before the rate limit is reset. If no rate limit is in effect, then this will return <code>0.0</code> instead.</ul></div></div><div id=RESTBucket.is_rate_limited><div class="attr function"><a class=headerlink href=#RESTBucket.is_rate_limited>#</a><span class=def>def</span><span class=name>is_rate_limited</span><span class=signature>(self, now: float) -> bool:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=k>def</span> <span class=nf>is_rate_limited</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>now</span><span class=p>:</span> <span class=nb>float</span><span class=p>)</span> <span class=o>-></span> <span class=nb>bool</span><span class=p>:</span>
        <span class=sd>"""Determine if we are under a rate limit at the given time.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            Invoking this method will update the internal state if we were</span>
<span class=sd>            previously rate limited, but at the given time are no longer under</span>
<span class=sd>            that limit. This makes it imperative that you only pass the current</span>
<span class=sd>            timestamp to this function, and not past or future timestamps. The</span>
<span class=sd>            effects of doing the latter are undefined behaviour.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        now : float</span>
<span class=sd>            The monotonic `time.monotonic_timestamp` timestamp.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        bool</span>
<span class=sd>            `True` if we are being rate limited, or `False` if</span>
<span class=sd>            we are not.</span>
<span class=sd>        """</span>
        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>reset_at</span> <span class=o><=</span> <span class=n>now</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>remaining</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>limit</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>reset_at</span> <span class=o>=</span> <span class=n>now</span> <span class=o>+</span> <span class=bp>self</span><span class=o>.</span><span class=n>period</span>
            <span class=k>return</span> <span class=kc>False</span>

        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>remaining</span> <span class=o><=</span> <span class=mi>0</span>
</pre></div></details><div class=docstring><p>Determine if we are under a rate limit at the given time.<p><em>Warning:</em> Invoking this method will update the internal state if we were previously rate limited, but at the given time are no longer under that limit. This makes it imperative that you only pass the current timestamp to this function, and not past or future timestamps. The effects of doing the latter are undefined behaviour.<h6 id=parameters>Parameters</h6><ul><li><strong>now</strong> (float): The monotonic <code>time.monotonic_timestamp</code> timestamp.</ul><h6 id=returns>Returns</h6><ul><li><strong>bool</strong>: <code>True</code> if we are being rate limited, or <code>False</code> if we are not.</ul></div></div><div id=RESTBucket.resolve><div class="attr function"><a class=headerlink href=#RESTBucket.resolve>#</a><span class=def>def</span><span class=name>resolve</span><span class=signature>(self, real_bucket_hash: str) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=k>def</span> <span class=nf>resolve</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>real_bucket_hash</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Resolve an unknown bucket.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        real_bucket_hash: str</span>
<span class=sd>            The real bucket hash for this bucket.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        RuntimeError</span>
<span class=sd>            If the hash of the bucket is already known.</span>
<span class=sd>        """</span>
        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_unknown</span><span class=p>:</span>
            <span class=k>raise</span> <span class=ne>RuntimeError</span><span class=p>(</span><span class=s2>"Cannot resolve known bucket"</span><span class=p>)</span>

        <span class=bp>self</span><span class=o>.</span><span class=n>name</span><span class=p>:</span> <span class=nb>str</span> <span class=o>=</span> <span class=n>real_bucket_hash</span>
</pre></div></details><div class=docstring><p>Resolve an unknown bucket.<h6 id=parameters>Parameters</h6><ul><li><strong>real_bucket_hash</strong> (str): The real bucket hash for this bucket.</ul><h6 id=raises>Raises</h6><ul><li><strong>RuntimeError</strong>: If the hash of the bucket is already known.</ul></div></div><div id=RESTBucket.throttle><div class="attr function"><a class=headerlink href=#RESTBucket.throttle>#</a><span class=def>async def</span><span class=name>throttle</span><span class=signature>(self) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=k>async</span> <span class=k>def</span> <span class=nf>throttle</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Perform the throttling rate limiter logic.</span>

<span class=sd>        Iterates repeatedly while the queue is not empty, adhering to any</span>
<span class=sd>        rate limits that occur in the mean time.</span>

<span class=sd>        .. note::</span>
<span class=sd>            You should usually not need to invoke this directly, but if you do,</span>
<span class=sd>            ensure to call it using `asyncio.create_task`, and store the</span>
<span class=sd>            task immediately in `throttle_task`.</span>

<span class=sd>            When this coroutine function completes, it will set the</span>
<span class=sd>            `throttle_task` to `None`. This means you can check if throttling</span>
<span class=sd>            is occurring by checking if `throttle_task` is not `None`.</span>
<span class=sd>        """</span>
        <span class=n>_LOGGER</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span>
            <span class=s2>"you are being rate limited on bucket </span><span class=si>%s</span><span class=s2>, backing off for </span><span class=si>%s</span><span class=s2>s"</span><span class=p>,</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>name</span><span class=p>,</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>get_time_until_reset</span><span class=p>(</span><span class=n>time</span><span class=o>.</span><span class=n>monotonic</span><span class=p>()),</span>
        <span class=p>)</span>

        <span class=k>while</span> <span class=bp>self</span><span class=o>.</span><span class=n>queue</span><span class=p>:</span>
            <span class=n>sleep_for</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>get_time_until_reset</span><span class=p>(</span><span class=n>time</span><span class=o>.</span><span class=n>monotonic</span><span class=p>())</span>
            <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=n>sleep_for</span><span class=p>)</span>

            <span class=k>while</span> <span class=bp>self</span><span class=o>.</span><span class=n>remaining</span> <span class=o>></span> <span class=mi>0</span> <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>queue</span><span class=p>:</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>drip</span><span class=p>()</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>queue</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=o>.</span><span class=n>set_result</span><span class=p>(</span><span class=kc>None</span><span class=p>)</span>

        <span class=bp>self</span><span class=o>.</span><span class=n>throttle_task</span> <span class=o>=</span> <span class=kc>None</span>
</pre></div></details><div class=docstring><p>Perform the throttling rate limiter logic.<p>Iterates repeatedly while the queue is not empty, adhering to any rate limits that occur in the mean time.<p><em>Note:</em> You should usually not need to invoke this directly, but if you do, ensure to call it using <code>asyncio.create_task</code>, and store the task immediately in <code><a href=#RESTBucket.throttle_task>throttle_task</a></code>.<p>When this coroutine function completes, it will set the <code><a href=#RESTBucket.throttle_task>throttle_task</a></code> to <code>None</code>. This means you can check if throttling is occurring by checking if <code><a href=#RESTBucket.throttle_task>throttle_task</a></code> is not <code>None</code>.</div></div><div id=RESTBucket.update_rate_limit><div class="attr function"><a class=headerlink href=#RESTBucket.update_rate_limit>#</a><span class=def>def</span><span class=name>update_rate_limit</span><span class=signature>(self, remaining: int, limit: int, reset_at: float) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=k>def</span> <span class=nf>update_rate_limit</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>remaining</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>limit</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>reset_at</span><span class=p>:</span> <span class=nb>float</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Update the rate limit information.</span>

<span class=sd>        .. note::</span>
<span class=sd>            The `reset_at` epoch is expected to be a `time.monotonic_timestamp`</span>
<span class=sd>            monotonic epoch, rather than a `time.time` date-based epoch.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        remaining : int</span>
<span class=sd>            The calls remaining in this time window.</span>
<span class=sd>        limit : int</span>
<span class=sd>            The total calls allowed in this time window.</span>
<span class=sd>        reset_at : float</span>
<span class=sd>            The epoch at which to reset the limit.</span>
<span class=sd>        """</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>remaining</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=n>remaining</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>limit</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=n>limit</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>reset_at</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=n>reset_at</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>period</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=mf>0.0</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>reset_at</span> <span class=o>-</span> <span class=n>time</span><span class=o>.</span><span class=n>monotonic</span><span class=p>())</span>
</pre></div></details><div class=docstring><p>Update the rate limit information.<p><em>Note:</em> The <code><a href=#RESTBucket.reset_at>reset_at</a></code> epoch is expected to be a <code>time.monotonic_timestamp</code> monotonic epoch, rather than a <code>time.time</code> date-based epoch.<h6 id=parameters>Parameters</h6><ul><li><strong>remaining</strong> (int): The calls remaining in this time window.<li><strong>limit</strong> (int): The total calls allowed in this time window.<li><strong>reset_at</strong> (float): The epoch at which to reset the limit.</ul></div></div></section></section><section id=RESTBucketManager><div class="attr class"><a class=headerlink href=#RESTBucketManager>#</a><span class=def>class</span><span class=name>RESTBucketManager</span>:</div><details><summary>View Source</summary> <div class=codehilite><pre><span></span><span class=k>class</span> <span class=nc>RESTBucketManager</span><span class=p>:</span>
    <span class=sd>"""The main rate limiter implementation for HTTP clients.</span>

<span class=sd>    This is designed to provide bucketed rate limiting for Discord HTTP</span>
<span class=sd>    endpoints that respects the `X-RateLimit-Bucket` rate limit header. To do</span>
<span class=sd>    this, it makes the assumption that any limit can change at any time.</span>

<span class=sd>    Parameters</span>
<span class=sd>    ----------</span>
<span class=sd>    max_rate_limit : float</span>
<span class=sd>        The max number of seconds to backoff for when rate limited. Anything</span>
<span class=sd>        greater than this will instead raise an error.</span>
<span class=sd>    """</span>

    <span class=vm>__slots__</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span>
        <span class=s2>"routes_to_hashes"</span><span class=p>,</span>
        <span class=s2>"real_hashes_to_buckets"</span><span class=p>,</span>
        <span class=s2>"closed_event"</span><span class=p>,</span>
        <span class=s2>"gc_task"</span><span class=p>,</span>
        <span class=s2>"max_rate_limit"</span><span class=p>,</span>
    <span class=p>)</span>

    <span class=n>routes_to_hashes</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Final</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>MutableMapping</span><span class=p>[</span><span class=n>routes</span><span class=o>.</span><span class=n>Route</span><span class=p>,</span> <span class=nb>str</span><span class=p>]]</span>
    <span class=sd>"""Maps routes to their `X-RateLimit-Bucket` header being used."""</span>

    <span class=n>real_hashes_to_buckets</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Final</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>MutableMapping</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>RESTBucket</span><span class=p>]]</span>
    <span class=sd>"""Maps full bucket hashes (`X-RateLimit-Bucket` appended with a hash of</span>
<span class=sd>    major parameters used in that compiled route) to their corresponding rate</span>
<span class=sd>    limiters.</span>
<span class=sd>    """</span>

    <span class=n>closed_event</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Final</span><span class=p>[</span><span class=n>asyncio</span><span class=o>.</span><span class=n>Event</span><span class=p>]</span>
    <span class=sd>"""An internal event that is set when the object is shut down."""</span>

    <span class=n>gc_task</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=n>asyncio</span><span class=o>.</span><span class=n>Task</span><span class=p>[</span><span class=kc>None</span><span class=p>]]</span>
    <span class=sd>"""The internal garbage collector task."""</span>

    <span class=n>max_rate_limit</span><span class=p>:</span> <span class=nb>float</span>
    <span class=sd>"""The max number of seconds to backoff for when rate limited.</span>

<span class=sd>    Anything greater than this will instead raise an error.</span>
<span class=sd>    """</span>

    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>max_rate_limit</span><span class=p>:</span> <span class=nb>float</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>routes_to_hashes</span> <span class=o>=</span> <span class=p>{}</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span> <span class=o>=</span> <span class=p>{}</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>closed_event</span><span class=p>:</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>Event</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>Event</span><span class=p>()</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=n>asyncio</span><span class=o>.</span><span class=n>Task</span><span class=p>[</span><span class=kc>None</span><span class=p>]]</span> <span class=o>=</span> <span class=kc>None</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>max_rate_limit</span> <span class=o>=</span> <span class=n>max_rate_limit</span>

    <span class=k>def</span> <span class=fm>__enter__</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>RESTBucketManager</span><span class=p>:</span>
        <span class=k>return</span> <span class=bp>self</span>

    <span class=k>def</span> <span class=fm>__exit__</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>exc_type</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Type</span><span class=p>[</span><span class=ne>Exception</span><span class=p>]],</span>
        <span class=n>exc_val</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=ne>Exception</span><span class=p>],</span>
        <span class=n>exc_tb</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=n>types</span><span class=o>.</span><span class=n>TracebackType</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>

    <span class=k>def</span> <span class=fm>__del__</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>

    <span class=k>def</span> <span class=nf>start</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>poll_period</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>20.0</span><span class=p>,</span> <span class=n>expire_after</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>10.0</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Start this ratelimiter up.</span>

<span class=sd>        This spins up internal garbage collection logic in the background to</span>
<span class=sd>        keep memory usage to an optimal level as old routes and bucket hashes</span>
<span class=sd>        get discarded and replaced.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        poll_period : float</span>
<span class=sd>            Period to poll the garbage collector at in seconds. Defaults</span>
<span class=sd>            to `20` seconds.</span>
<span class=sd>        expire_after : float</span>
<span class=sd>            Time after which the last `reset_at` was hit for a bucket to</span>
<span class=sd>            remove it. Higher values will retain unneeded ratelimit info for</span>
<span class=sd>            longer, but may produce more effective rate-limiting logic as a</span>
<span class=sd>            result. Using `0` will make the bucket get garbage collected as soon</span>
<span class=sd>            as the rate limit has reset. Defaults to `10` seconds.</span>
<span class=sd>        """</span>
        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>gc</span><span class=p>(</span><span class=n>poll_period</span><span class=p>,</span> <span class=n>expire_after</span><span class=p>))</span>

    <span class=k>def</span> <span class=nf>close</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Close the garbage collector and kill any tasks waiting on ratelimits.</span>

<span class=sd>        Once this has been called, this object is considered to be effectively</span>
<span class=sd>        dead. To reuse it, one should create a new instance.</span>
<span class=sd>        """</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>closed_event</span><span class=o>.</span><span class=n>set</span><span class=p>()</span>
        <span class=k>for</span> <span class=n>bucket</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=o>.</span><span class=n>values</span><span class=p>():</span>
            <span class=n>bucket</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>routes_to_hashes</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>

        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span><span class=o>.</span><span class=n>cancel</span><span class=p>()</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span> <span class=o>=</span> <span class=kc>None</span>

    <span class=c1># Ignore docstring not starting in an imperative mood</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>gc</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>poll_period</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span> <span class=n>expire_after</span><span class=p>:</span> <span class=nb>float</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Run the garbage collector loop.</span>

<span class=sd>        This is designed to run in the background and manage removing unused</span>
<span class=sd>        route references from the rate-limiter collection to save memory.</span>

<span class=sd>        This will run forever until `RESTBucketManager.closed_event` is set.</span>
<span class=sd>        This will invoke `RESTBucketManager.do_gc_pass` periodically.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            You generally have no need to invoke this directly. Use</span>
<span class=sd>            `RESTBucketManager.start` and `RESTBucketManager.close` to control</span>
<span class=sd>            this instead.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        poll_period : float</span>
<span class=sd>            The period to poll at.</span>
<span class=sd>        expire_after : float</span>
<span class=sd>            Time after which the last `reset_at` was hit for a bucket to</span>
<span class=sd>            remove it. Higher values will retain unneeded ratelimit info for</span>
<span class=sd>            longer, but may produce more effective ratelimiting logic as a</span>
<span class=sd>            result. Using `0` will make the bucket get garbage collected as soon</span>
<span class=sd>            as the rate limit has reset.</span>
<span class=sd>        """</span>
        <span class=c1># Prevent filling memory increasingly until we run out by removing dead buckets every 20s</span>
        <span class=c1># Allocations are somewhat cheap if we only do them every so-many seconds, after all.</span>
        <span class=n>_LOGGER</span><span class=o>.</span><span class=n>log</span><span class=p>(</span><span class=n>ux</span><span class=o>.</span><span class=n>TRACE</span><span class=p>,</span> <span class=s2>"rate limit garbage collector started"</span><span class=p>)</span>
        <span class=k>while</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>closed_event</span><span class=o>.</span><span class=n>is_set</span><span class=p>():</span>
            <span class=k>try</span><span class=p>:</span>
                <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>wait_for</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>closed_event</span><span class=o>.</span><span class=n>wait</span><span class=p>(),</span> <span class=n>timeout</span><span class=o>=</span><span class=n>poll_period</span><span class=p>)</span>
            <span class=k>except</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>TimeoutError</span><span class=p>:</span>
                <span class=n>_LOGGER</span><span class=o>.</span><span class=n>log</span><span class=p>(</span><span class=n>ux</span><span class=o>.</span><span class=n>TRACE</span><span class=p>,</span> <span class=s2>"performing rate limit garbage collection pass"</span><span class=p>)</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>do_gc_pass</span><span class=p>(</span><span class=n>expire_after</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span> <span class=o>=</span> <span class=kc>None</span>

    <span class=k>def</span> <span class=nf>do_gc_pass</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>expire_after</span><span class=p>:</span> <span class=nb>float</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Perform a single garbage collection pass.</span>

<span class=sd>        This will assess any routes stored in the internal mappings of this</span>
<span class=sd>        object and remove any that are deemed to be inactive or dead in order</span>
<span class=sd>        to save memory.</span>

<span class=sd>        If the removed routes are used again in the future, they will be</span>
<span class=sd>        re-cached automatically.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            You generally have no need to invoke this directly. Use</span>
<span class=sd>            `RESTBucketManager.start` and `RESTBucketManager.close` to control</span>
<span class=sd>            this instead.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        expire_after : float</span>
<span class=sd>            Time after which the last `reset_at` was hit for a bucket to\</span>
<span class=sd>            remove it. Defaults to `reset_at` + 20 seconds. Higher values will</span>
<span class=sd>            retain unneeded ratelimit info for longer, but may produce more</span>
<span class=sd>            effective ratelimiting logic as a result.</span>
<span class=sd>        """</span>
        <span class=n>buckets_to_purge</span> <span class=o>=</span> <span class=p>[]</span>

        <span class=n>now</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>monotonic</span><span class=p>()</span>

        <span class=c1># We have three main states that a bucket can be in:</span>
        <span class=c1># 1. active - the bucket is active and is not at risk of deallocation</span>
        <span class=c1># 2. survival - the bucket is inactive but is still fresh enough to be kept alive.</span>
        <span class=c1># 3. death - the bucket has been inactive for too long.</span>
        <span class=n>active</span> <span class=o>=</span> <span class=mi>0</span>

        <span class=c1># Discover and purge</span>
        <span class=n>bucket_pairs</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=o>.</span><span class=n>items</span><span class=p>()</span>

        <span class=k>for</span> <span class=n>full_hash</span><span class=p>,</span> <span class=n>bucket</span> <span class=ow>in</span> <span class=n>bucket_pairs</span><span class=p>:</span>
            <span class=k>if</span> <span class=n>bucket</span><span class=o>.</span><span class=n>is_empty</span> <span class=ow>and</span> <span class=n>bucket</span><span class=o>.</span><span class=n>reset_at</span> <span class=o>+</span> <span class=n>expire_after</span> <span class=o><</span> <span class=n>now</span><span class=p>:</span>
                <span class=c1># If it is still running a throttle and is in memory, it will remain in memory</span>
                <span class=c1># but we will not know about it.</span>
                <span class=n>buckets_to_purge</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>full_hash</span><span class=p>)</span>

            <span class=k>if</span> <span class=n>bucket</span><span class=o>.</span><span class=n>reset_at</span> <span class=o>>=</span> <span class=n>now</span><span class=p>:</span>
                <span class=n>active</span> <span class=o>+=</span> <span class=mi>1</span>

        <span class=n>dead</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>buckets_to_purge</span><span class=p>)</span>
        <span class=n>total</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>bucket_pairs</span><span class=p>)</span>
        <span class=n>survival</span> <span class=o>=</span> <span class=n>total</span> <span class=o>-</span> <span class=n>active</span> <span class=o>-</span> <span class=n>dead</span>

        <span class=k>for</span> <span class=n>full_hash</span> <span class=ow>in</span> <span class=n>buckets_to_purge</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=p>[</span><span class=n>full_hash</span><span class=p>]</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
            <span class=k>del</span> <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=p>[</span><span class=n>full_hash</span><span class=p>]</span>

        <span class=n>_LOGGER</span><span class=o>.</span><span class=n>log</span><span class=p>(</span><span class=n>ux</span><span class=o>.</span><span class=n>TRACE</span><span class=p>,</span> <span class=s2>"purged </span><span class=si>%s</span><span class=s2> stale buckets, </span><span class=si>%s</span><span class=s2> remain in survival, </span><span class=si>%s</span><span class=s2> active"</span><span class=p>,</span> <span class=n>dead</span><span class=p>,</span> <span class=n>survival</span><span class=p>,</span> <span class=n>active</span><span class=p>)</span>

    <span class=k>def</span> <span class=nf>acquire</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>compiled_route</span><span class=p>:</span> <span class=n>routes</span><span class=o>.</span><span class=n>CompiledRoute</span><span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>AsyncContextManager</span><span class=p>[</span><span class=kc>None</span><span class=p>]:</span>
        <span class=sd>"""Acquire a bucket for the given route.</span>

<span class=sd>        .. note::</span>
<span class=sd>            You MUST keep the context manager acquired during the whole of the</span>
<span class=sd>            request. From making the request until calling `update_rate_limits`.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        compiled_route : hikari.internal.routes.CompiledRoute</span>
<span class=sd>            The route to get the bucket for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.AsyncContextManager[None]</span>
<span class=sd>            A context manager to enter while doing the request.</span>
<span class=sd>        """</span>
        <span class=n>template</span> <span class=o>=</span> <span class=n>compiled_route</span><span class=o>.</span><span class=n>route</span>

        <span class=k>try</span><span class=p>:</span>
            <span class=n>bucket_hash</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>routes_to_hashes</span><span class=p>[</span><span class=n>template</span><span class=p>]</span>
            <span class=n>real_bucket_hash</span> <span class=o>=</span> <span class=n>compiled_route</span><span class=o>.</span><span class=n>create_real_bucket_hash</span><span class=p>(</span><span class=n>bucket_hash</span><span class=p>)</span>
        <span class=k>except</span> <span class=ne>KeyError</span><span class=p>:</span>
            <span class=n>real_bucket_hash</span> <span class=o>=</span> <span class=n>_create_unknown_hash</span><span class=p>(</span><span class=n>compiled_route</span><span class=p>)</span>

        <span class=k>try</span><span class=p>:</span>
            <span class=n>bucket</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=p>[</span><span class=n>real_bucket_hash</span><span class=p>]</span>
            <span class=n>_LOGGER</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span><span class=s2>"</span><span class=si>%s</span><span class=s2> is being mapped to existing bucket </span><span class=si>%s</span><span class=s2>"</span><span class=p>,</span> <span class=n>compiled_route</span><span class=p>,</span> <span class=n>real_bucket_hash</span><span class=p>)</span>
        <span class=k>except</span> <span class=ne>KeyError</span><span class=p>:</span>
            <span class=n>_LOGGER</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span><span class=s2>"</span><span class=si>%s</span><span class=s2> is being mapped to new bucket </span><span class=si>%s</span><span class=s2>"</span><span class=p>,</span> <span class=n>compiled_route</span><span class=p>,</span> <span class=n>real_bucket_hash</span><span class=p>)</span>
            <span class=n>bucket</span> <span class=o>=</span> <span class=n>RESTBucket</span><span class=p>(</span><span class=n>real_bucket_hash</span><span class=p>,</span> <span class=n>compiled_route</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>max_rate_limit</span><span class=p>)</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=p>[</span><span class=n>real_bucket_hash</span><span class=p>]</span> <span class=o>=</span> <span class=n>bucket</span>

        <span class=k>return</span> <span class=n>bucket</span>

    <span class=k>def</span> <span class=nf>update_rate_limits</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>compiled_route</span><span class=p>:</span> <span class=n>routes</span><span class=o>.</span><span class=n>CompiledRoute</span><span class=p>,</span>
        <span class=n>bucket_header</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>remaining_header</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span>
        <span class=n>limit_header</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span>
        <span class=n>reset_after</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Update the rate limits for a bucket using info from a response.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        compiled_route : hikari.internal.routes.CompiledRoute</span>
<span class=sd>            The compiled route to get the bucket for.</span>
<span class=sd>        bucket_header : typing.Optional[str]</span>
<span class=sd>            The `X-RateLimit-Bucket` header that was provided in the response.</span>
<span class=sd>        remaining_header : int</span>
<span class=sd>            The `X-RateLimit-Remaining` header cast to an `int`.</span>
<span class=sd>        limit_header : int</span>
<span class=sd>            The `X-RateLimit-Limit` header cast to an `int`.</span>
<span class=sd>        reset_after : float</span>
<span class=sd>            The `X-RateLimit-Reset-After` header cast to a `float`.</span>
<span class=sd>        """</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>routes_to_hashes</span><span class=p>[</span><span class=n>compiled_route</span><span class=o>.</span><span class=n>route</span><span class=p>]</span> <span class=o>=</span> <span class=n>bucket_header</span>
        <span class=n>real_bucket_hash</span> <span class=o>=</span> <span class=n>compiled_route</span><span class=o>.</span><span class=n>create_real_bucket_hash</span><span class=p>(</span><span class=n>bucket_header</span><span class=p>)</span>

        <span class=k>if</span> <span class=n>bucket</span> <span class=o>:=</span> <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>real_bucket_hash</span><span class=p>):</span>
            <span class=n>_LOGGER</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span>
                <span class=s2>"updating </span><span class=si>%s</span><span class=s2> with bucket </span><span class=si>%s</span><span class=s2> [reset-after:</span><span class=si>%s</span><span class=s2>s, limit:</span><span class=si>%s</span><span class=s2>, remaining:</span><span class=si>%s</span><span class=s2>]"</span><span class=p>,</span>
                <span class=n>compiled_route</span><span class=p>,</span>
                <span class=n>real_bucket_hash</span><span class=p>,</span>
                <span class=n>reset_after</span><span class=p>,</span>
                <span class=n>limit_header</span><span class=p>,</span>
                <span class=n>remaining_header</span><span class=p>,</span>
            <span class=p>)</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>unknown_bucket_hash</span> <span class=o>=</span> <span class=n>_create_unknown_hash</span><span class=p>(</span><span class=n>compiled_route</span><span class=p>)</span>

            <span class=k>if</span> <span class=n>bucket</span> <span class=o>:=</span> <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=n>unknown_bucket_hash</span><span class=p>,</span> <span class=kc>None</span><span class=p>):</span>
                <span class=n>bucket</span><span class=o>.</span><span class=n>resolve</span><span class=p>(</span><span class=n>real_bucket_hash</span><span class=p>)</span>
                <span class=n>_LOGGER</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span>
                    <span class=s2>"remapping </span><span class=si>%s</span><span class=s2> with existing bucket </span><span class=si>%s</span><span class=s2> [reset-after:</span><span class=si>%s</span><span class=s2>s, limit:</span><span class=si>%s</span><span class=s2>, remaining:</span><span class=si>%s</span><span class=s2>]"</span><span class=p>,</span>
                    <span class=n>compiled_route</span><span class=p>,</span>
                    <span class=n>unknown_bucket_hash</span><span class=p>,</span>
                    <span class=n>reset_after</span><span class=p>,</span>
                    <span class=n>limit_header</span><span class=p>,</span>
                    <span class=n>remaining_header</span><span class=p>,</span>
                <span class=p>)</span>
            <span class=k>else</span><span class=p>:</span>
                <span class=n>_LOGGER</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span>
                    <span class=s2>"remapping </span><span class=si>%s</span><span class=s2> with new bucket </span><span class=si>%s</span><span class=s2> [reset-after:</span><span class=si>%s</span><span class=s2>s, limit:</span><span class=si>%s</span><span class=s2>, remaining:</span><span class=si>%s</span><span class=s2>]"</span><span class=p>,</span>
                    <span class=n>compiled_route</span><span class=p>,</span>
                    <span class=n>real_bucket_hash</span><span class=p>,</span>
                    <span class=n>reset_after</span><span class=p>,</span>
                    <span class=n>limit_header</span><span class=p>,</span>
                    <span class=n>remaining_header</span><span class=p>,</span>
                <span class=p>)</span>
                <span class=n>bucket</span> <span class=o>=</span> <span class=n>RESTBucket</span><span class=p>(</span><span class=n>real_bucket_hash</span><span class=p>,</span> <span class=n>compiled_route</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>max_rate_limit</span><span class=p>)</span>

            <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=p>[</span><span class=n>real_bucket_hash</span><span class=p>]</span> <span class=o>=</span> <span class=n>bucket</span>

        <span class=n>reset_at_monotonic</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>monotonic</span><span class=p>()</span> <span class=o>+</span> <span class=n>reset_after</span>
        <span class=n>bucket</span><span class=o>.</span><span class=n>update_rate_limit</span><span class=p>(</span><span class=n>remaining_header</span><span class=p>,</span> <span class=n>limit_header</span><span class=p>,</span> <span class=n>reset_at_monotonic</span><span class=p>)</span>

    <span class=nd>@property</span>
    <span class=k>def</span> <span class=nf>is_started</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=nb>bool</span><span class=p>:</span>
        <span class=sd>"""Return `True` if the rate limiter GC task is started."""</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span>
</pre></div></details><div class=docstring><p>The main rate limiter implementation for HTTP clients.<p>This is designed to provide bucketed rate limiting for Discord HTTP endpoints that respects the <code>X-RateLimit-Bucket</code> rate limit header. To do this, it makes the assumption that any limit can change at any time.<h6 id=parameters>Parameters</h6><ul><li><strong>max_rate_limit</strong> (float): The max number of seconds to backoff for when rate limited. Anything greater than this will instead raise an error.</ul></div><section class=member_divisor><h5>Variables and properties</h5><div id=RESTBucketManager.closed_event><div class="attr variable"><a class=headerlink href=#RESTBucketManager.closed_event>#</a><span class=name>closed_event</span><span class=annotation>: Final[asyncio.locks.Event]</span></div><div class=docstring><p>An internal event that is set when the object is shut down.</div></div><div id=RESTBucketManager.gc_task><div class="attr variable"><a class=headerlink href=#RESTBucketManager.gc_task>#</a><span class=name>gc_task</span><span class=annotation>: Optional[_asyncio.Task]</span></div><div class=docstring><p>The internal garbage collector task.</div></div><div id=RESTBucketManager.is_started><div class="attr variable"><a class=headerlink href=#RESTBucketManager.is_started>#</a><span class=name>is_started</span><span class=annotation>: bool</span></div><div class=docstring><p>Return <code>True</code> if the rate limiter GC task is started.</div></div><div id=RESTBucketManager.max_rate_limit><div class="attr variable"><a class=headerlink href=#RESTBucketManager.max_rate_limit>#</a><span class=name>max_rate_limit</span><span class=annotation>: float</span></div><div class=docstring><p>The max number of seconds to backoff for when rate limited.<p>Anything greater than this will instead raise an error.</div></div><div id=RESTBucketManager.real_hashes_to_buckets><div class="attr variable"><a class=headerlink href=#RESTBucketManager.real_hashes_to_buckets>#</a><span class=name>real_hashes_to_buckets</span><span class=annotation>: Final[MutableMapping[str, <a href=#RESTBucket>hikari.impl.buckets.RESTBucket</a>]]</span></div><div class=docstring><p>Maps full bucket hashes (<code>X-RateLimit-Bucket</code> appended with a hash of major parameters used in that compiled route) to their corresponding rate limiters.</div></div><div id=RESTBucketManager.routes_to_hashes><div class="attr variable"><a class=headerlink href=#RESTBucketManager.routes_to_hashes>#</a><span class=name>routes_to_hashes</span><span class=annotation>: Final[MutableMapping[<a href=../internal/routes.html#Route>hikari.internal.routes.Route</a>, str]]</span></div><div class=docstring><p>Maps routes to their <code>X-RateLimit-Bucket</code> header being used.</div></div></section><section class=member_divisor><h5>Methods</h5><div id=RESTBucketManager.__init__><div class="attr function"><a class=headerlink href=#RESTBucketManager.__init__>#</a><span class=def>def</span><span class=name>__init__</span><span class=signature>(self, max_rate_limit: float):</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>max_rate_limit</span><span class=p>:</span> <span class=nb>float</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>routes_to_hashes</span> <span class=o>=</span> <span class=p>{}</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span> <span class=o>=</span> <span class=p>{}</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>closed_event</span><span class=p>:</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>Event</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>Event</span><span class=p>()</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=n>asyncio</span><span class=o>.</span><span class=n>Task</span><span class=p>[</span><span class=kc>None</span><span class=p>]]</span> <span class=o>=</span> <span class=kc>None</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>max_rate_limit</span> <span class=o>=</span> <span class=n>max_rate_limit</span>
</pre></div></details></div><div id=RESTBucketManager.acquire><div class="attr function"><a class=headerlink href=#RESTBucketManager.acquire>#</a><span class=def>def</span><span class=name>acquire</span><span class=signature>(<br> self,<br> compiled_route: <a href=../internal/routes.html#CompiledRoute>hikari.internal.routes.CompiledRoute</a><br>) -> AsyncContextManager[NoneType]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=k>def</span> <span class=nf>acquire</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>compiled_route</span><span class=p>:</span> <span class=n>routes</span><span class=o>.</span><span class=n>CompiledRoute</span><span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>AsyncContextManager</span><span class=p>[</span><span class=kc>None</span><span class=p>]:</span>
        <span class=sd>"""Acquire a bucket for the given route.</span>

<span class=sd>        .. note::</span>
<span class=sd>            You MUST keep the context manager acquired during the whole of the</span>
<span class=sd>            request. From making the request until calling `update_rate_limits`.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        compiled_route : hikari.internal.routes.CompiledRoute</span>
<span class=sd>            The route to get the bucket for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.AsyncContextManager[None]</span>
<span class=sd>            A context manager to enter while doing the request.</span>
<span class=sd>        """</span>
        <span class=n>template</span> <span class=o>=</span> <span class=n>compiled_route</span><span class=o>.</span><span class=n>route</span>

        <span class=k>try</span><span class=p>:</span>
            <span class=n>bucket_hash</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>routes_to_hashes</span><span class=p>[</span><span class=n>template</span><span class=p>]</span>
            <span class=n>real_bucket_hash</span> <span class=o>=</span> <span class=n>compiled_route</span><span class=o>.</span><span class=n>create_real_bucket_hash</span><span class=p>(</span><span class=n>bucket_hash</span><span class=p>)</span>
        <span class=k>except</span> <span class=ne>KeyError</span><span class=p>:</span>
            <span class=n>real_bucket_hash</span> <span class=o>=</span> <span class=n>_create_unknown_hash</span><span class=p>(</span><span class=n>compiled_route</span><span class=p>)</span>

        <span class=k>try</span><span class=p>:</span>
            <span class=n>bucket</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=p>[</span><span class=n>real_bucket_hash</span><span class=p>]</span>
            <span class=n>_LOGGER</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span><span class=s2>"</span><span class=si>%s</span><span class=s2> is being mapped to existing bucket </span><span class=si>%s</span><span class=s2>"</span><span class=p>,</span> <span class=n>compiled_route</span><span class=p>,</span> <span class=n>real_bucket_hash</span><span class=p>)</span>
        <span class=k>except</span> <span class=ne>KeyError</span><span class=p>:</span>
            <span class=n>_LOGGER</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span><span class=s2>"</span><span class=si>%s</span><span class=s2> is being mapped to new bucket </span><span class=si>%s</span><span class=s2>"</span><span class=p>,</span> <span class=n>compiled_route</span><span class=p>,</span> <span class=n>real_bucket_hash</span><span class=p>)</span>
            <span class=n>bucket</span> <span class=o>=</span> <span class=n>RESTBucket</span><span class=p>(</span><span class=n>real_bucket_hash</span><span class=p>,</span> <span class=n>compiled_route</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>max_rate_limit</span><span class=p>)</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=p>[</span><span class=n>real_bucket_hash</span><span class=p>]</span> <span class=o>=</span> <span class=n>bucket</span>

        <span class=k>return</span> <span class=n>bucket</span>
</pre></div></details><div class=docstring><p>Acquire a bucket for the given route.<p><em>Note:</em> You MUST keep the context manager acquired during the whole of the request. From making the request until calling <code><a href=#RESTBucketManager.update_rate_limits>update_rate_limits</a></code>.<h6 id=parameters>Parameters</h6><ul><li><strong>compiled_route</strong> (<a href=../internal/routes.html#CompiledRoute>hikari.internal.routes.CompiledRoute</a>): The route to get the bucket for.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.AsyncContextManager[None]</strong>: A context manager to enter while doing the request.</ul></div></div><div id=RESTBucketManager.close><div class="attr function"><a class=headerlink href=#RESTBucketManager.close>#</a><span class=def>def</span><span class=name>close</span><span class=signature>(self) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=k>def</span> <span class=nf>close</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Close the garbage collector and kill any tasks waiting on ratelimits.</span>

<span class=sd>        Once this has been called, this object is considered to be effectively</span>
<span class=sd>        dead. To reuse it, one should create a new instance.</span>
<span class=sd>        """</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>closed_event</span><span class=o>.</span><span class=n>set</span><span class=p>()</span>
        <span class=k>for</span> <span class=n>bucket</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=o>.</span><span class=n>values</span><span class=p>():</span>
            <span class=n>bucket</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>routes_to_hashes</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>

        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span><span class=o>.</span><span class=n>cancel</span><span class=p>()</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span> <span class=o>=</span> <span class=kc>None</span>
</pre></div></details><div class=docstring><p>Close the garbage collector and kill any tasks waiting on ratelimits.<p>Once this has been called, this object is considered to be effectively dead. To reuse it, one should create a new instance.</div></div><div id=RESTBucketManager.do_gc_pass><div class="attr function"><a class=headerlink href=#RESTBucketManager.do_gc_pass>#</a><span class=def>def</span><span class=name>do_gc_pass</span><span class=signature>(self, expire_after: float) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=k>def</span> <span class=nf>do_gc_pass</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>expire_after</span><span class=p>:</span> <span class=nb>float</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Perform a single garbage collection pass.</span>

<span class=sd>        This will assess any routes stored in the internal mappings of this</span>
<span class=sd>        object and remove any that are deemed to be inactive or dead in order</span>
<span class=sd>        to save memory.</span>

<span class=sd>        If the removed routes are used again in the future, they will be</span>
<span class=sd>        re-cached automatically.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            You generally have no need to invoke this directly. Use</span>
<span class=sd>            `RESTBucketManager.start` and `RESTBucketManager.close` to control</span>
<span class=sd>            this instead.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        expire_after : float</span>
<span class=sd>            Time after which the last `reset_at` was hit for a bucket to\</span>
<span class=sd>            remove it. Defaults to `reset_at` + 20 seconds. Higher values will</span>
<span class=sd>            retain unneeded ratelimit info for longer, but may produce more</span>
<span class=sd>            effective ratelimiting logic as a result.</span>
<span class=sd>        """</span>
        <span class=n>buckets_to_purge</span> <span class=o>=</span> <span class=p>[]</span>

        <span class=n>now</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>monotonic</span><span class=p>()</span>

        <span class=c1># We have three main states that a bucket can be in:</span>
        <span class=c1># 1. active - the bucket is active and is not at risk of deallocation</span>
        <span class=c1># 2. survival - the bucket is inactive but is still fresh enough to be kept alive.</span>
        <span class=c1># 3. death - the bucket has been inactive for too long.</span>
        <span class=n>active</span> <span class=o>=</span> <span class=mi>0</span>

        <span class=c1># Discover and purge</span>
        <span class=n>bucket_pairs</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=o>.</span><span class=n>items</span><span class=p>()</span>

        <span class=k>for</span> <span class=n>full_hash</span><span class=p>,</span> <span class=n>bucket</span> <span class=ow>in</span> <span class=n>bucket_pairs</span><span class=p>:</span>
            <span class=k>if</span> <span class=n>bucket</span><span class=o>.</span><span class=n>is_empty</span> <span class=ow>and</span> <span class=n>bucket</span><span class=o>.</span><span class=n>reset_at</span> <span class=o>+</span> <span class=n>expire_after</span> <span class=o><</span> <span class=n>now</span><span class=p>:</span>
                <span class=c1># If it is still running a throttle and is in memory, it will remain in memory</span>
                <span class=c1># but we will not know about it.</span>
                <span class=n>buckets_to_purge</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>full_hash</span><span class=p>)</span>

            <span class=k>if</span> <span class=n>bucket</span><span class=o>.</span><span class=n>reset_at</span> <span class=o>>=</span> <span class=n>now</span><span class=p>:</span>
                <span class=n>active</span> <span class=o>+=</span> <span class=mi>1</span>

        <span class=n>dead</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>buckets_to_purge</span><span class=p>)</span>
        <span class=n>total</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>bucket_pairs</span><span class=p>)</span>
        <span class=n>survival</span> <span class=o>=</span> <span class=n>total</span> <span class=o>-</span> <span class=n>active</span> <span class=o>-</span> <span class=n>dead</span>

        <span class=k>for</span> <span class=n>full_hash</span> <span class=ow>in</span> <span class=n>buckets_to_purge</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=p>[</span><span class=n>full_hash</span><span class=p>]</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
            <span class=k>del</span> <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=p>[</span><span class=n>full_hash</span><span class=p>]</span>

        <span class=n>_LOGGER</span><span class=o>.</span><span class=n>log</span><span class=p>(</span><span class=n>ux</span><span class=o>.</span><span class=n>TRACE</span><span class=p>,</span> <span class=s2>"purged </span><span class=si>%s</span><span class=s2> stale buckets, </span><span class=si>%s</span><span class=s2> remain in survival, </span><span class=si>%s</span><span class=s2> active"</span><span class=p>,</span> <span class=n>dead</span><span class=p>,</span> <span class=n>survival</span><span class=p>,</span> <span class=n>active</span><span class=p>)</span>
</pre></div></details><div class=docstring><p>Perform a single garbage collection pass.<p>This will assess any routes stored in the internal mappings of this object and remove any that are deemed to be inactive or dead in order to save memory.<p>If the removed routes are used again in the future, they will be re-cached automatically.<p><em>Warning:</em> You generally have no need to invoke this directly. Use <code><a href=#RESTBucketManager.start>RESTBucketManager.start</a></code> and <code><a href=#RESTBucketManager.close>RESTBucketManager.close</a></code> to control this instead.<h6 id=parameters>Parameters</h6><ul><li><strong>expire_after</strong> (float): Time after which the last <code>reset_at</code> was hit for a bucket to remove it. Defaults to <code>reset_at</code> + 20 seconds. Higher values will retain unneeded ratelimit info for longer, but may produce more effective ratelimiting logic as a result.</ul></div></div><div id=RESTBucketManager.gc><div class="attr function"><a class=headerlink href=#RESTBucketManager.gc>#</a><span class=def>async def</span><span class=name>gc</span><span class=signature>(self, poll_period: float, expire_after: float) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=k>async</span> <span class=k>def</span> <span class=nf>gc</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>poll_period</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span> <span class=n>expire_after</span><span class=p>:</span> <span class=nb>float</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Run the garbage collector loop.</span>

<span class=sd>        This is designed to run in the background and manage removing unused</span>
<span class=sd>        route references from the rate-limiter collection to save memory.</span>

<span class=sd>        This will run forever until `RESTBucketManager.closed_event` is set.</span>
<span class=sd>        This will invoke `RESTBucketManager.do_gc_pass` periodically.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            You generally have no need to invoke this directly. Use</span>
<span class=sd>            `RESTBucketManager.start` and `RESTBucketManager.close` to control</span>
<span class=sd>            this instead.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        poll_period : float</span>
<span class=sd>            The period to poll at.</span>
<span class=sd>        expire_after : float</span>
<span class=sd>            Time after which the last `reset_at` was hit for a bucket to</span>
<span class=sd>            remove it. Higher values will retain unneeded ratelimit info for</span>
<span class=sd>            longer, but may produce more effective ratelimiting logic as a</span>
<span class=sd>            result. Using `0` will make the bucket get garbage collected as soon</span>
<span class=sd>            as the rate limit has reset.</span>
<span class=sd>        """</span>
        <span class=c1># Prevent filling memory increasingly until we run out by removing dead buckets every 20s</span>
        <span class=c1># Allocations are somewhat cheap if we only do them every so-many seconds, after all.</span>
        <span class=n>_LOGGER</span><span class=o>.</span><span class=n>log</span><span class=p>(</span><span class=n>ux</span><span class=o>.</span><span class=n>TRACE</span><span class=p>,</span> <span class=s2>"rate limit garbage collector started"</span><span class=p>)</span>
        <span class=k>while</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>closed_event</span><span class=o>.</span><span class=n>is_set</span><span class=p>():</span>
            <span class=k>try</span><span class=p>:</span>
                <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>wait_for</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>closed_event</span><span class=o>.</span><span class=n>wait</span><span class=p>(),</span> <span class=n>timeout</span><span class=o>=</span><span class=n>poll_period</span><span class=p>)</span>
            <span class=k>except</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>TimeoutError</span><span class=p>:</span>
                <span class=n>_LOGGER</span><span class=o>.</span><span class=n>log</span><span class=p>(</span><span class=n>ux</span><span class=o>.</span><span class=n>TRACE</span><span class=p>,</span> <span class=s2>"performing rate limit garbage collection pass"</span><span class=p>)</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>do_gc_pass</span><span class=p>(</span><span class=n>expire_after</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span> <span class=o>=</span> <span class=kc>None</span>
</pre></div></details><div class=docstring><p>Run the garbage collector loop.<p>This is designed to run in the background and manage removing unused route references from the rate-limiter collection to save memory.<p>This will run forever until <code><a href=#RESTBucketManager.closed_event>RESTBucketManager.closed_event</a></code> is set. This will invoke <code><a href=#RESTBucketManager.do_gc_pass>RESTBucketManager.do_gc_pass</a></code> periodically.<p><em>Warning:</em> You generally have no need to invoke this directly. Use <code><a href=#RESTBucketManager.start>RESTBucketManager.start</a></code> and <code><a href=#RESTBucketManager.close>RESTBucketManager.close</a></code> to control this instead.<h6 id=parameters>Parameters</h6><ul><li><strong>poll_period</strong> (float): The period to poll at.<li><strong>expire_after</strong> (float): Time after which the last <code>reset_at</code> was hit for a bucket to remove it. Higher values will retain unneeded ratelimit info for longer, but may produce more effective ratelimiting logic as a result. Using <code>0</code> will make the bucket get garbage collected as soon as the rate limit has reset.</ul></div></div><div id=RESTBucketManager.start><div class="attr function"><a class=headerlink href=#RESTBucketManager.start>#</a><span class=def>def</span><span class=name>start</span><span class=signature>(self, poll_period: float = 20.0, expire_after: float = 10.0) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=k>def</span> <span class=nf>start</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>poll_period</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>20.0</span><span class=p>,</span> <span class=n>expire_after</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>10.0</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Start this ratelimiter up.</span>

<span class=sd>        This spins up internal garbage collection logic in the background to</span>
<span class=sd>        keep memory usage to an optimal level as old routes and bucket hashes</span>
<span class=sd>        get discarded and replaced.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        poll_period : float</span>
<span class=sd>            Period to poll the garbage collector at in seconds. Defaults</span>
<span class=sd>            to `20` seconds.</span>
<span class=sd>        expire_after : float</span>
<span class=sd>            Time after which the last `reset_at` was hit for a bucket to</span>
<span class=sd>            remove it. Higher values will retain unneeded ratelimit info for</span>
<span class=sd>            longer, but may produce more effective rate-limiting logic as a</span>
<span class=sd>            result. Using `0` will make the bucket get garbage collected as soon</span>
<span class=sd>            as the rate limit has reset. Defaults to `10` seconds.</span>
<span class=sd>        """</span>
        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>gc_task</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>gc</span><span class=p>(</span><span class=n>poll_period</span><span class=p>,</span> <span class=n>expire_after</span><span class=p>))</span>
</pre></div></details><div class=docstring><p>Start this ratelimiter up.<p>This spins up internal garbage collection logic in the background to keep memory usage to an optimal level as old routes and bucket hashes get discarded and replaced.<h6 id=parameters>Parameters</h6><ul><li><strong>poll_period</strong> (float): Period to poll the garbage collector at in seconds. Defaults to <code>20</code> seconds.<li><strong>expire_after</strong> (float): Time after which the last <code>reset_at</code> was hit for a bucket to remove it. Higher values will retain unneeded ratelimit info for longer, but may produce more effective rate-limiting logic as a result. Using <code>0</code> will make the bucket get garbage collected as soon as the rate limit has reset. Defaults to <code>10</code> seconds.</ul></div></div><div id=RESTBucketManager.update_rate_limits><div class="attr function"><a class=headerlink href=#RESTBucketManager.update_rate_limits>#</a><span class=def>def</span><span class=name>update_rate_limits</span><span class=signature>(<br> self,<br> compiled_route: <a href=../internal/routes.html#CompiledRoute>hikari.internal.routes.CompiledRoute</a>,<br> bucket_header: str,<br> remaining_header: int,<br> limit_header: int,<br> reset_after: float<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=k>def</span> <span class=nf>update_rate_limits</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>compiled_route</span><span class=p>:</span> <span class=n>routes</span><span class=o>.</span><span class=n>CompiledRoute</span><span class=p>,</span>
        <span class=n>bucket_header</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>remaining_header</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span>
        <span class=n>limit_header</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span>
        <span class=n>reset_after</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Update the rate limits for a bucket using info from a response.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        compiled_route : hikari.internal.routes.CompiledRoute</span>
<span class=sd>            The compiled route to get the bucket for.</span>
<span class=sd>        bucket_header : typing.Optional[str]</span>
<span class=sd>            The `X-RateLimit-Bucket` header that was provided in the response.</span>
<span class=sd>        remaining_header : int</span>
<span class=sd>            The `X-RateLimit-Remaining` header cast to an `int`.</span>
<span class=sd>        limit_header : int</span>
<span class=sd>            The `X-RateLimit-Limit` header cast to an `int`.</span>
<span class=sd>        reset_after : float</span>
<span class=sd>            The `X-RateLimit-Reset-After` header cast to a `float`.</span>
<span class=sd>        """</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>routes_to_hashes</span><span class=p>[</span><span class=n>compiled_route</span><span class=o>.</span><span class=n>route</span><span class=p>]</span> <span class=o>=</span> <span class=n>bucket_header</span>
        <span class=n>real_bucket_hash</span> <span class=o>=</span> <span class=n>compiled_route</span><span class=o>.</span><span class=n>create_real_bucket_hash</span><span class=p>(</span><span class=n>bucket_header</span><span class=p>)</span>

        <span class=k>if</span> <span class=n>bucket</span> <span class=o>:=</span> <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>real_bucket_hash</span><span class=p>):</span>
            <span class=n>_LOGGER</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span>
                <span class=s2>"updating </span><span class=si>%s</span><span class=s2> with bucket </span><span class=si>%s</span><span class=s2> [reset-after:</span><span class=si>%s</span><span class=s2>s, limit:</span><span class=si>%s</span><span class=s2>, remaining:</span><span class=si>%s</span><span class=s2>]"</span><span class=p>,</span>
                <span class=n>compiled_route</span><span class=p>,</span>
                <span class=n>real_bucket_hash</span><span class=p>,</span>
                <span class=n>reset_after</span><span class=p>,</span>
                <span class=n>limit_header</span><span class=p>,</span>
                <span class=n>remaining_header</span><span class=p>,</span>
            <span class=p>)</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>unknown_bucket_hash</span> <span class=o>=</span> <span class=n>_create_unknown_hash</span><span class=p>(</span><span class=n>compiled_route</span><span class=p>)</span>

            <span class=k>if</span> <span class=n>bucket</span> <span class=o>:=</span> <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=n>unknown_bucket_hash</span><span class=p>,</span> <span class=kc>None</span><span class=p>):</span>
                <span class=n>bucket</span><span class=o>.</span><span class=n>resolve</span><span class=p>(</span><span class=n>real_bucket_hash</span><span class=p>)</span>
                <span class=n>_LOGGER</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span>
                    <span class=s2>"remapping </span><span class=si>%s</span><span class=s2> with existing bucket </span><span class=si>%s</span><span class=s2> [reset-after:</span><span class=si>%s</span><span class=s2>s, limit:</span><span class=si>%s</span><span class=s2>, remaining:</span><span class=si>%s</span><span class=s2>]"</span><span class=p>,</span>
                    <span class=n>compiled_route</span><span class=p>,</span>
                    <span class=n>unknown_bucket_hash</span><span class=p>,</span>
                    <span class=n>reset_after</span><span class=p>,</span>
                    <span class=n>limit_header</span><span class=p>,</span>
                    <span class=n>remaining_header</span><span class=p>,</span>
                <span class=p>)</span>
            <span class=k>else</span><span class=p>:</span>
                <span class=n>_LOGGER</span><span class=o>.</span><span class=n>debug</span><span class=p>(</span>
                    <span class=s2>"remapping </span><span class=si>%s</span><span class=s2> with new bucket </span><span class=si>%s</span><span class=s2> [reset-after:</span><span class=si>%s</span><span class=s2>s, limit:</span><span class=si>%s</span><span class=s2>, remaining:</span><span class=si>%s</span><span class=s2>]"</span><span class=p>,</span>
                    <span class=n>compiled_route</span><span class=p>,</span>
                    <span class=n>real_bucket_hash</span><span class=p>,</span>
                    <span class=n>reset_after</span><span class=p>,</span>
                    <span class=n>limit_header</span><span class=p>,</span>
                    <span class=n>remaining_header</span><span class=p>,</span>
                <span class=p>)</span>
                <span class=n>bucket</span> <span class=o>=</span> <span class=n>RESTBucket</span><span class=p>(</span><span class=n>real_bucket_hash</span><span class=p>,</span> <span class=n>compiled_route</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>max_rate_limit</span><span class=p>)</span>

            <span class=bp>self</span><span class=o>.</span><span class=n>real_hashes_to_buckets</span><span class=p>[</span><span class=n>real_bucket_hash</span><span class=p>]</span> <span class=o>=</span> <span class=n>bucket</span>

        <span class=n>reset_at_monotonic</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>monotonic</span><span class=p>()</span> <span class=o>+</span> <span class=n>reset_after</span>
        <span class=n>bucket</span><span class=o>.</span><span class=n>update_rate_limit</span><span class=p>(</span><span class=n>remaining_header</span><span class=p>,</span> <span class=n>limit_header</span><span class=p>,</span> <span class=n>reset_at_monotonic</span><span class=p>)</span>
</pre></div></details><div class=docstring><p>Update the rate limits for a bucket using info from a response.<h6 id=parameters>Parameters</h6><ul><li><strong>compiled_route</strong> (<a href=../internal/routes.html#CompiledRoute>hikari.internal.routes.CompiledRoute</a>): The compiled route to get the bucket for.<li><strong>bucket_header</strong> (typing.Optional[str]): The <code>X-RateLimit-Bucket</code> header that was provided in the response.<li><strong>remaining_header</strong> (int): The <code>X-RateLimit-Remaining</code> header cast to an <code>int</code>.<li><strong>limit_header</strong> (int): The <code>X-RateLimit-Limit</code> header cast to an <code>int</code>.<li><strong>reset_after</strong> (float): The <code>X-RateLimit-Reset-After</code> header cast to a <code>float</code>.</ul></div></div></section></section><section id=UNKNOWN_HASH><div class="attr variable"><a class=headerlink href=#UNKNOWN_HASH>#</a><span class=name>UNKNOWN_HASH</span><span class=annotation>: Final[str]</span></div><div class=docstring><p>The hash used for an unknown bucket that has not yet been resolved.</div></section></main><script src=../../../version_switcher.js></script><script>"use strict";const html=document.querySelector("html"),sidebarToggle=document.getElementById("sidebar-toggle");sidebarToggle.addEventListener("click",function(){html.classList.contains("sidebar-hidden")?html.classList.remove("sidebar-hidden"):html.classList.add("sidebar-hidden")});let firstContact=null;document.addEventListener("touchstart",function(e){firstContact={x:e.touches[0].clientX,time:Date.now()}},{passive:!0}),document.addEventListener("touchmove",function(e){if(!firstContact)return;let i=e.touches[0].clientX,t=i-firstContact.x;Date.now()-firstContact.time<300&&Math.abs(t)>=100&&(t>=0&&firstContact.x<Math.min(document.body.clientWidth,450)?(html.classList.remove("sidebar-hidden"),firstContact=null):t<0&&i<250&&(html.classList.add("sidebar-hidden"),firstContact=null))},{passive:!0});</script><script>function escapeHTML(n){return document.createElement("div").appendChild(document.createTextNode(n)).parentNode.innerHTML}const originalContent=document.querySelector("main.pdoc");let currentContent=originalContent;function setContent(n){let e;n?(e=document.createElement("main"),e.classList.add("pdoc"),e.innerHTML=n):e=originalContent,currentContent!==e&&(currentContent.replaceWith(e),currentContent=e)}function getSearchTerm(){return new URL(window.location).searchParams.get("search")}const searchBox=document.querySelector(".pdoc input[type=search]");searchBox.addEventListener("input",function(){let n=new URL(window.location);searchBox.value.trim()?(n.hash="",n.searchParams.set("search",searchBox.value)):n.searchParams.delete("search"),history.replaceState("","",n.toString()),onInput()}),window.addEventListener("popstate",onInput);let search,searchErr;async function initialize(){try{search=await new Promise((n,e)=>{const t=document.createElement("script");t.type="text/javascript",t.async=!0,t.onload=()=>n(window.pdocSearch),t.onerror=r=>e(r),t.src="../../search.js",document.getElementsByTagName("head")[0].appendChild(t)})}catch{console.error("Cannot fetch pdoc search index"),searchErr="Cannot fetch search index."}onInput(),document.querySelector("nav.pdoc").addEventListener("click",n=>{n.target.hash&&(searchBox.value="",searchBox.dispatchEvent(new Event("input")))})}function onInput(){setContent((()=>{const n=getSearchTerm();if(!n)return null;if(searchErr)return`<h3>Error: ${searchErr}</h3>`;if(!search)return"<h3>Searching...</h3>";window.scrollTo({top:0,left:0,behavior:"auto"});const e=search(n);let t;e.length===0?t=`No search results for '${escapeHTML(n)}'.`:t=`<h4>${e.length} search result${e.length>1?"s":""} for '${escapeHTML(n)}'.</h4>`;for(let r of e.slice(0,10)){let s=r.doc,l=`../../${s.modulename.replaceAll(".","/")}.html`;s.qualname&&(l+=`#${s.qualname}`);let a;switch(r.doc.type){case"function":a=`<span class="def">${s.funcdef}</span> <span class="name">${s.fullname}</span><span class="signature">${s.signature}:</span>`;break;case"class":a=`<span class="def">class</span> <span class="name">${s.fullname}</span>`,s.bases&&(a+=`<wbr>(<span class="base">${s.bases}</span>)`),a+=":";break;case"variable":a=`<span class="name">${s.fullname}</span>`,s.annotation&&(a+=`<span class="annotation">${s.annotation}</span>`),s.default_value&&(a+=`<span class="default_value">${s.default_value}</span>`);break;default:a=`<span class="name">${s.fullname}</span>`;break}t+=`
                        <section class="search-result">
                        <a href="${l}" class="attr ${s.type}">${a}</a>
                        <div class="docstring">${s.doc}</div>
                        </section>
                    `}return t})())}getSearchTerm()?(initialize(),searchBox.value=getSearchTerm(),onInput()):searchBox.addEventListener("focus",initialize,{once:!0}),searchBox.addEventListener("keydown",n=>{if(["ArrowDown","ArrowUp","Enter"].includes(n.key)){let e=currentContent.querySelector(".search-result.focused");e?n.key==="ArrowDown"&&e.nextElementSibling&&e.nextElementSibling.classList.contains("search-result")?(e.classList.remove("focused"),e.nextElementSibling.classList.add("focused"),e.nextElementSibling.scrollIntoView({behavior:"smooth",block:"nearest",inline:"nearest"})):n.key==="ArrowUp"&&e.previousElementSibling&&e.previousElementSibling.classList.contains("search-result")?(e.classList.remove("focused"),e.previousElementSibling.classList.add("focused"),e.previousElementSibling.scrollIntoView({behavior:"smooth",block:"nearest",inline:"nearest"})):n.key==="Enter"&&e.querySelector("a").click():currentContent.querySelector(".search-result").classList.add("focused")}});</script>