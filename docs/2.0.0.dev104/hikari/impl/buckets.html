<!doctype html>
<html lang="en" class="sidebar-hidden">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 8.0.1" />
    <title>hikari.impl.buckets API documentation | v2.0.0.dev104</title>
    <link rel="icon" href="https://www.hikari-py.dev/logo.png"/>

    
<style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>

<style>:root{--pdoc-background:#212529;}.pdoc{--text:#f7f7f7;--muted:#9d9d9d;--link:#d264d0;--link-hover:#3989ff;--code:#333;--active:#555;--accent:#343434;--accent2:#555;--nav-hover:rgba(0, 0, 0, 0.1);--def:#ff79c6;--name:#61aeee;--annotation:#F471E6;font-family:SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;word-break:break-word;}@media (max-width:1079px){:root{--sidebar-width:30rem;}html{font-size:3vw;}main, header{padding:2rem 3vw 0 1.5rem;}html:not(.sidebar-hidden) body{overflow:hidden !important;}.sidebar-hidden nav.pdoc{transform:translateX(calc(0px - var(--sidebar-width)));}nav.pdoc{transition:transform 0.2s;}.pdoc .sidebar-toggle{position:fixed;top:0;bottom:calc(100% - 6rem);left:var(--sidebar-width);border-left:5px solid grey;border-top:5px solid rgba(0, 0, 0, 0);border-bottom:5px solid rgba(0, 0, 0, 0);}}@media (min-width:1080px){:root{--sidebar-width:clamp(12.5rem, 28vw, 26rem);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);}}nav.pdoc{position:fixed;left:0;top:0;bottom:0;height:100vh;width:var(--sidebar-width);z-index:1;}.pdoc .sidebar{height:100vh;overflow:auto;padding:1rem 1rem;background-color:var(--accent);border-right:1px solid var(--accent2);scrollbar-color:var(--accent2) transparent }.pdoc .sidebar::-webkit-scrollbar-thumb{background-color:var(--accent2); }.pdoc .sidebar input[type=search]{display:block;outline-offset:0;width:102%;}.pdoc .sidebar ul{list-style:none;padding-left:1rem;}.pdoc .sidebar li{display:block;margin:0;padding:.2rem 0 .2rem .5rem;transition:all 100ms;}.pdoc .sidebar > ul > li{padding-left:0;}.pdoc .sidebar li:hover{background-color:var(--nav-hover);}.pdoc .sidebar a:hover{color:var(--text);}.pdoc .sidebar a{display:block;}.pdoc .sidebar a.function, .pdoc .sidebar a.variable{color:#bd93f9;}.pdoc .sidebar > h2:first-of-type{margin-top:1rem;}.pdoc .sidebar .class:before{content:"class ";color:var(--muted);}.pdoc .sidebar .function:after{content:"()";color:var(--muted);}.pdoc .sidebar .sidebar-buttons{display:flex;width:100%;margin-bottom:.5rem;align-items:end;}.pdoc .sidebar .sidebar-buttons .push{margin-left:auto;}.pdoc .svg-button > svg{width:1.5rem;margin:0 .2rem 0 .2rem;cursor:pointer;}.pdoc .version-selector{background-color:var(--accent);color:var(--text);border:hidden;}.pdoc .version-selector:disabled{-webkit-appearance:none;}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc p{font-weight:300;margin-top:0;margin-bottom:.5rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{color:#de4f91;font-weight:bold;margin:0.3em 0;padding:0.2em 0;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .modulename a:hover{filter:brightness(80%);}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{--shift:-2.4rem;text-align:right;margin-top:var(--shift);margin-bottom:calc(0px - var(--shift));clear:both;filter:opacity(1);}.pdoc details:not([open]){height:0;overflow:visible;}.pdoc details > summary{font-size:.75rem;cursor:pointer;color:var(--muted);border-width:0;padding:0 .7em;display:inline-block;display:inline list-item;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc details > div{margin-top:calc(0px - var(--shift) / 2);text-align:left;}.pdoc .docstring{margin:0 0 2rem 2rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc .docstring li{margin-bottom:15px;}.pdoc .docstring li:last-child{margin-bottom:0;}.pdoc span.name{color:#61aeee;}.pdoc span.base{color:#8be9fd;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc li strong{color:#DB61D9;}b, strong{font-weight:bold;}.pdoc em{color:orange;}.pdoc h6{padding-top:1rem;font-size:2rem;color:white;}.pdoc h6#notes{color:orange;}.pdoc h6#raises{color:#ff6666;}.pdoc div.decorator{color:#61aeee;}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .inherited dt,.pdoc .inherited dt::before{color:#61aeee;}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:1rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:3rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited div{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;color:white;}.pdoc .c{color:#6a7aaa;}.pdoc .err{color:#ff5555;background-color:#1e0010;}.pdoc .k{color:#ff79c6;}.pdoc .l{color:#ae81ff;}.pdoc .n{color:#f8f8f2;}.pdoc .o{color:#ff79c6;}.pdoc .p{color:#f8f8f2;}.pdoc .ch{color:#6a7aaa;}.pdoc .cm{color:#6a7aaa;}.pdoc .cp{color:#6a7aaa;}.pdoc .cpf{color:#6a7aaa;}.pdoc .c1{color:#6a7aaa;}.pdoc .cs{color:#6a7aaa;}.pdoc .gd{color:#6a7aaa;}.pdoc .ge{font-style:italic;}.pdoc .gi{color:#a6e22e;}.pdoc .go{color:#ff79c6;}.pdoc .gp{color:#f92672;font-weight:bold;}.pdoc .gs{font-weight:bold;}.pdoc .gu{color:#75715e;}.pdoc .kc{color:#ff79c6;}.pdoc .kd{color:#bd93f9;}.pdoc .kn{color:#ff79c6;}.pdoc .kp{color:#bd93f9;}.pdoc .kr{color:#ff79c6;}.pdoc .kt{color:#ff79c6;}.pdoc .ld{color:#e6db74;}.pdoc .m{color:#ae81ff;}.pdoc .s{color:#e6db74;}.pdoc .na{color:#a6e22e;}.pdoc .nb{color:#8be9fd;}.pdoc .nc{color:#e6c07b;}.pdoc .no{color:#ff79c6;}.pdoc .ni{color:#ff79c6;}.pdoc .ne{color:#8be9fd;}.pdoc .nf{color:#61aeee;}.pdoc .nl{color:#f8f8f2;}.pdoc .nn{color:#f8f8f2;}.pdoc .nx{color:#a6e22e;}.pdoc .py{color:#f8f8f2;}.pdoc .nt{color:#f92672;}.pdoc .nv{color:#f8f8f2;}.pdoc .ow{color:#ff79c6;}.pdoc .w{color:#f8f8f2;}.pdoc .mb{color:#ae81ff;}.pdoc .mf{color:#ae81ff;}.pdoc .mh{color:#ae81ff;}.pdoc .mi{color:#ae81ff;}.pdoc .mo{color:#ae81ff;}.pdoc .sa{color:#ff79c6;}.pdoc .sb{color:#e6db74;}.pdoc .sc{color:#e6db74;}.pdoc .dl{color:#e6db74;}.pdoc .sd{color:#6272a4;}.pdoc .s2{color:#e6db74;}.pdoc .se{color:#ae81ff;}.pdoc .sh{color:#e6db74;}.pdoc .si{color:#bd93f9;}.pdoc .sx{color:#e6db74;}.pdoc .sr{color:#e6db74;}.pdoc .s1{color:#e6db74;}.pdoc .ss{color:#e6db74;}.pdoc .bp{color:#bd93f9;}.pdoc .fm{color:#bd93f9;}.pdoc .vc{color:#bd93f9;}.pdoc .vg{color:#f8f8f2;}.pdoc .vi{color:#ffffff;}.pdoc .vm{color:#bd93f9;}.pdoc .il{color:#ae81ff;}.pdoc .nd{color:#61aeee;}.pdoc .kc{color:#bd93f9;}</style>
</head>
<body>    <nav class="pdoc">
        <div id="sidebar" class="sidebar">
            <div class="sidebar-buttons">
                <label>
                    Hikari <select class="version-selector" id="version-selector" disabled><option>2.0.0.dev104</option></select>
                </label>
                <div class="push"></div>
                <a href="../../index.html" class="svg-button"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 576 512" >
    <path d="M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z" fill="#ffffff"/>
</svg></a>
                <a href="https://discord.gg/Jx4cNGG" class="svg-button"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 71 55">
    <path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z" fill="#ffffff"/>
</svg></a>
                <a href="https://pypi.org/project/hikari" class="svg-button"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 512 512">
    <path d="M488.6 250.2L392 214V105.5c0-15-9.3-28.4-23.4-33.7l-100-37.5c-8.1-3.1-17.1-3.1-25.3 0l-100 37.5c-14.1 5.3-23.4 18.7-23.4 33.7V214l-96.6 36.2C9.3 255.5 0 268.9 0 283.9V394c0 13.6 7.7 26.1 19.9 32.2l100 50c10.1 5.1 22.1 5.1 32.2 0l103.9-52 103.9 52c10.1 5.1 22.1 5.1 32.2 0l100-50c12.2-6.1 19.9-18.6 19.9-32.2V283.9c0-15-9.3-28.4-23.4-33.7zM358 214.8l-85 31.9v-68.2l85-37v73.3zM154 104.1l102-38.2 102 38.2v.6l-102 41.4-102-41.4v-.6zm84 291.1l-85 42.5v-79.1l85-38.8v75.4zm0-112l-102 41.4-102-41.4v-.6l102-38.2 102 38.2v.6zm240 112l-85 42.5v-79.1l85-38.8v75.4zm0-112l-102 41.4-102-41.4v-.6l102-38.2 102 38.2v.6z" fill="#ffffff"/>
</svg></a>
            </div>

                <input type="search" placeholder="Search..." role="searchbox" title="Search the documentation" pattern=".+">

                <h2>Contents</h2>
                <ul>
  <li><a href="#what-is-the-theory-behind-this-implementation">What is the theory behind this implementation?</a>
  <ul>
    <li><a href="#initially-acquiring-time-on-a-bucket">Initially acquiring time on a bucket</a></li>
    <li><a href="#handling-the-rate-limit-headers-of-a-response">Handling the rate limit headers of a response</a></li>
    <li><a href="#tidying-up">Tidying up</a></li>
  </ul></li>
  <li><a href="#body-field-specific-rate-limiting">Body-field-specific rate limiting</a></li>
</ul>



                <h2>API Documentation</h2>
                    <ul class="memberlist">
            <li>
                    <a class="variable" href="#UNKNOWN_HASH">UNKNOWN_HASH</a>
            </li>
            <li>
                    <a class="class" href="#RESTBucket">RESTBucket</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#RESTBucket.__init__">RESTBucket</a>
                        </li>
                        <li>
                                <a class="variable" href="#RESTBucket.is_unknown">is_unknown</a>
                        </li>
                        <li>
                                <a class="function" href="#RESTBucket.acquire">acquire</a>
                        </li>
                        <li>
                                <a class="function" href="#RESTBucket.update_rate_limit">update_rate_limit</a>
                        </li>
                        <li>
                                <a class="function" href="#RESTBucket.drip">drip</a>
                        </li>
                        <li>
                                <a class="function" href="#RESTBucket.resolve">resolve</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#RESTBucketManager">RESTBucketManager</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#RESTBucketManager.__init__">RESTBucketManager</a>
                        </li>
                        <li>
                                <a class="variable" href="#RESTBucketManager.routes_to_hashes">routes_to_hashes</a>
                        </li>
                        <li>
                                <a class="variable" href="#RESTBucketManager.real_hashes_to_buckets">real_hashes_to_buckets</a>
                        </li>
                        <li>
                                <a class="variable" href="#RESTBucketManager.closed_event">closed_event</a>
                        </li>
                        <li>
                                <a class="variable" href="#RESTBucketManager.gc_task">gc_task</a>
                        </li>
                        <li>
                                <a class="variable" href="#RESTBucketManager.max_rate_limit">max_rate_limit</a>
                        </li>
                        <li>
                                <a class="function" href="#RESTBucketManager.start">start</a>
                        </li>
                        <li>
                                <a class="function" href="#RESTBucketManager.close">close</a>
                        </li>
                        <li>
                                <a class="function" href="#RESTBucketManager.gc">gc</a>
                        </li>
                        <li>
                                <a class="function" href="#RESTBucketManager.do_gc_pass">do_gc_pass</a>
                        </li>
                        <li>
                                <a class="function" href="#RESTBucketManager.acquire">acquire</a>
                        </li>
                        <li>
                                <a class="function" href="#RESTBucketManager.update_rate_limits">update_rate_limits</a>
                        </li>
                        <li>
                                <a class="variable" href="#RESTBucketManager.is_started">is_started</a>
                        </li>
                </ul>

            </li>
    </ul>


            <a class="attribution" href="https://pdoc.dev">built with pdoc v8.0.1</a>
        </div>

        <div class="sidebar-toggle" id="sidebar-toggle"></div>
    </nav>

    <main class="pdoc">
        
        <section>
                <h1 class="modulename">
<a href="./../../index.html">hikari</a><wbr>.<a href="./../impl.html">impl</a><wbr>.buckets    </h1>

                    <div class="docstring"><p>Rate-limit extensions for RESTful bucketed endpoints.</p>

<p>Provides implementations for the complex rate limiting mechanisms that Discord
requires for rate limit handling that conforms to the passed bucket headers
correctly.</p>

<p>This was initially a bit of a headache for me to understand, personally, since
there is a lot of "implicit detail" that is easy to miss from the documentation.</p>

<p>In an attempt to make this somewhat understandable by anyone else, I have tried
to document the theory of how this is handled here.</p>

<h2 id="what-is-the-theory-behind-this-implementation">What is the theory behind this implementation?</h2>

<p>In this module, we refer to a <code><a href="../internal/routes.html#CompiledRoute">hikari.internal.routes.CompiledRoute</a></code> as a definition
of a route with specific major parameter values included (e.g.
<code>POST /channels/123/messages</code>), and a <code><a href="../internal/routes.html#Route">hikari.internal.routes.Route</a></code> as a
definition of a route without specific parameter values included (e.g.
<code>POST /channels/{channel}/messages</code>). We can compile a
<code><a href="../internal/routes.html#CompiledRoute">hikari.internal.routes.CompiledRoute</a></code> from a <code><a href="../internal/routes.html#Route">hikari.internal.routes.Route</a></code>
by providing the corresponding parameters as kwargs, as you may already know.</p>

<p>In this module, a "bucket" is an internal data structure that tracks and
enforces the rate limit state for a specific <code><a href="../internal/routes.html#CompiledRoute">hikari.internal.routes.CompiledRoute</a></code>,
and can manage delaying tasks in the event that we begin to get rate limited.
It also supports providing in-order execution of queued tasks.</p>

<p>Discord allocates types of buckets to routes. If you are making a request and
there is a valid rate limit on the route you hit, you should receive an
<code>X-RateLimit-Bucket</code> header from the server in your response. This is a hash
that identifies a route based on internal criteria that does not include major
parameters. This <code>X-RateLimitBucket</code> is known in this module as an "bucket hash".</p>

<p>This means that generally, the route <code>POST /channels/123/messages</code> and
<code>POST /channels/456/messages</code> will usually sit in the same bucket, but
<code>GET /channels/123/messages/789</code> and <code>PATCH /channels/123/messages/789</code> will
usually not share the same bucket. Discord may or may not change this at any
time, so hard coding this logic is not a useful thing to be doing.</p>

<p>Rate limits, on the other hand, apply to a bucket and are specific to the major
parameters of the compiled route. This means that <code>POST /channels/123/messages</code>
and <code>POST /channels/456/messages</code> do not share the same real bucket, despite
Discord providing the same bucket hash. A real bucket hash is the <code>str</code> hash of
the bucket that Discord sends us in a response concatenated to the corresponding
major parameters. This is used for quick bucket indexing internally in this
module.</p>

<p>One issue that occurs from this is that we cannot effectively hash a
<code><a href="../internal/routes.html#CompiledRoute">hikari.internal.routes.CompiledRoute</a></code> that has not yet been hit, meaning that
until we receive a response from this endpoint, we have no idea what our rate
limits could be, nor the bucket that they sit in. This is usually not
problematic, as the first request to an endpoint should never be rate limited
unless you are hitting it from elsewhere in the same time window outside your
<a href="../applications.html">hikari.applications</a>. To manage this situation, unknown endpoints are allocated to
a special unlimited bucket until they have an initial bucket hash code allocated
from a response. Once this happens, the route is reallocated a dedicated bucket.
Unknown buckets have a hardcoded initial hash code internally.</p>

<h6 id="initially-acquiring-time-on-a-bucket">Initially acquiring time on a bucket</h6>

<p>Each time you <code>BaseRateLimiter.acquire()</code> a request timeslice for a given
<code><a href="../internal/routes.html#Route">hikari.internal.routes.Route</a></code>, several things happen. The first is that we
attempt to find the existing bucket for that route, if there is one, or get an
unknown bucket otherwise. This is done by creating a real bucket hash from the
compiled route. The initial hash is calculated using a lookup table that maps
<code><a href="../internal/routes.html#CompiledRoute">hikari.internal.routes.CompiledRoute</a></code> objects to their corresponding initial hash
codes, or to the unknown bucket hash code if not yet known. This initial hash is
processed by the <code><a href="../internal/routes.html#CompiledRoute">hikari.internal.routes.CompiledRoute</a></code> to provide the real bucket
hash we need to get the route's bucket object internally.</p>

<p>The <code>BaseRateLimiter.acquire()</code> method will take the bucket and acquire a new
timeslice on it. This takes the form of a <code>asyncio.Future</code> which should be
awaited by the caller and will complete once the caller is allowed to make a
request. Most of the time, this is done instantly, but if the bucket has an
active rate limit preventing requests being sent, then the future will be paused
until the rate limit is over. This may be longer than the rate limit period if
you have queued a large number of requests during this limit, as it is
first-come-first-served.</p>

<p>Acquiring a rate limited bucket will start a bucket-wide task (if not already
running) that will wait until the rate limit has completed before allowing more
futures to complete. This is done while observing the rate limits again, so can
easily begin to re-ratelimit itself if needed. Once the task is complete, it
tidies itself up and disposes of itself. This task will complete once the queue
becomes empty.</p>

<p>The result of <code><a href="#RESTBucketManager.acquire">RESTBucketManager.acquire()</a></code> is a tuple of a <code>asyncio.Future</code> to
await on which completes when you are allowed to proceed with making a request,
and a real bucket hash which should be stored temporarily. This will be
explained in the next section.</p>

<h6 id="handling-the-rate-limit-headers-of-a-response">Handling the rate limit headers of a response</h6>

<p>Once you have received your response, you are expected to extract the values of
the vital rate limit headers manually and parse them to the correct data types.
These headers are:</p>

<ul>
<li><code>X-RateLimit-Limit</code>:
an <code>int</code> describing the max requests in the bucket from empty to
being rate limited.</li>
<li><code>X-RateLimit-Remaining</code>:
an <code>int</code> describing the remaining number of requests before rate
limiting occurs in the current window.</li>
<li><code>X-RateLimit-Bucket</code>:
a <code>str</code> containing the initial bucket hash.</li>
<li><code>X-RateLimit-Reset-After</code>:
a <code>float</code> containing the number of seconds when the current rate
limit bucket will reset with decimal millisecond precision.</li>
</ul>

<p>Each of the above values should be passed to the <code>update_rate_limits</code> method to
ensure that the bucket you acquired time from is correctly updated should
Discord decide to alter their ratelimits on the fly without warning (including
timings and the bucket).</p>

<p>This method will manage creating new buckets as needed and resetting vital
information in each bucket you use.</p>

<h6 id="tidying-up">Tidying up</h6>

<p>To prevent unused buckets cluttering up memory, each <code><a href="#RESTBucketManager">RESTBucketManager</a></code>
instance spins up a <code>asyncio.Task</code> that periodically locks the bucket list
(not threadsafe, only using the concept of asyncio not yielding in regular
functions) and disposes of any clearly stale buckets that are no longer needed.
These will be recreated again in the future if they are needed.</p>

<p>When shutting down an application, one must remember to <code>close()</code> the
<code><a href="#RESTBucketManager">RESTBucketManager</a></code> that has been used. This will ensure the garbage collection
task is stopped, and will also ensure any remaining futures in any bucket queues
have an <code>asyncio.CancelledError</code> set on them to prevent deadlocking ratelimited
calls that may be waiting to be unlocked.</p>

<h2 id="body-field-specific-rate-limiting">Body-field-specific rate limiting</h2>

<p>As of the start of June, 2020, Discord appears to be enforcing another layer
of rate limiting logic to their HTTP APIs which is field-specific. This means
that special rate limits will also exist on some endpoints that limit based
on what attributes you send in a JSON or form data payload.</p>

<p>No information is sent in headers about these specific limits. You will only
be made aware that they exist once you get ratelimited. In the 429 ratelimited
response, you will have the <code>"global"</code> attribute set to <code>False</code>, and a
<code>"reset_after"</code> attribute that differs entirely to the <code>X-RateLimit-Reset-After</code>
header. Thus, it is important to not assume the value in the 429 response
for the reset time is the same as the one in the bucket headers. Hikari's
<code><a href="../api/rest.html#RESTClient">hikari.api.rest.RESTClient</a></code> implementation specifically uses the value furthest
in the future when working out which bucket to adhere to.</p>

<p>It is worth remembering that there is an API limit to the number of 401s,
403s, and 429s you receive, which is around 10,000 per 15 minutes. Passing this
limit results in a soft ban of your account.</p>

<p>At the time of writing, the only example of this appears to be on the
<code>PATCH /channels/{channel_id}</code> endpoint. This has a limit of two changes per
10 minutes. More details about how this is implemented have yet to be
released or documented...</p>
</div>

                    <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># cython: language_level=3</span>
<span class="c1"># Copyright (c) 2020 Nekokatt</span>
<span class="c1"># Copyright (c) 2021 davfsa</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="c1"># of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<span class="c1"># in the Software without restriction, including without limitation the rights</span>
<span class="c1"># to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="c1"># copies of the Software, and to permit persons to whom the Software is</span>
<span class="c1"># furnished to do so, subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be included in all</span>
<span class="c1"># copies or substantial portions of the Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="c1"># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="c1"># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="c1"># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="c1"># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="c1"># OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="c1"># SOFTWARE.</span>
<span class="sd">&quot;&quot;&quot;Rate-limit extensions for RESTful bucketed endpoints.</span>

<span class="sd">Provides implementations for the complex rate limiting mechanisms that Discord</span>
<span class="sd">requires for rate limit handling that conforms to the passed bucket headers</span>
<span class="sd">correctly.</span>

<span class="sd">This was initially a bit of a headache for me to understand, personally, since</span>
<span class="sd">there is a lot of &quot;implicit detail&quot; that is easy to miss from the documentation.</span>

<span class="sd">In an attempt to make this somewhat understandable by anyone else, I have tried</span>
<span class="sd">to document the theory of how this is handled here.</span>

<span class="sd">What is the theory behind this implementation?</span>
<span class="sd">----------------------------------------------</span>

<span class="sd">In this module, we refer to a `hikari.internal.routes.CompiledRoute` as a definition</span>
<span class="sd">of a route with specific major parameter values included (e.g.</span>
<span class="sd">`POST /channels/123/messages`), and a `hikari.internal.routes.Route` as a</span>
<span class="sd">definition of a route without specific parameter values included (e.g.</span>
<span class="sd">`POST /channels/{channel}/messages`). We can compile a</span>
<span class="sd">`hikari.internal.routes.CompiledRoute` from a `hikari.internal.routes.Route`</span>
<span class="sd">by providing the corresponding parameters as kwargs, as you may already know.</span>

<span class="sd">In this module, a &quot;bucket&quot; is an internal data structure that tracks and</span>
<span class="sd">enforces the rate limit state for a specific `hikari.internal.routes.CompiledRoute`,</span>
<span class="sd">and can manage delaying tasks in the event that we begin to get rate limited.</span>
<span class="sd">It also supports providing in-order execution of queued tasks.</span>

<span class="sd">Discord allocates types of buckets to routes. If you are making a request and</span>
<span class="sd">there is a valid rate limit on the route you hit, you should receive an</span>
<span class="sd">`X-RateLimit-Bucket` header from the server in your response. This is a hash</span>
<span class="sd">that identifies a route based on internal criteria that does not include major</span>
<span class="sd">parameters. This `X-RateLimitBucket` is known in this module as an &quot;bucket hash&quot;.</span>

<span class="sd">This means that generally, the route `POST /channels/123/messages` and</span>
<span class="sd">`POST /channels/456/messages` will usually sit in the same bucket, but</span>
<span class="sd">`GET /channels/123/messages/789` and `PATCH /channels/123/messages/789` will</span>
<span class="sd">usually not share the same bucket. Discord may or may not change this at any</span>
<span class="sd">time, so hard coding this logic is not a useful thing to be doing.</span>

<span class="sd">Rate limits, on the other hand, apply to a bucket and are specific to the major</span>
<span class="sd">parameters of the compiled route. This means that `POST /channels/123/messages`</span>
<span class="sd">and `POST /channels/456/messages` do not share the same real bucket, despite</span>
<span class="sd">Discord providing the same bucket hash. A real bucket hash is the `str` hash of</span>
<span class="sd">the bucket that Discord sends us in a response concatenated to the corresponding</span>
<span class="sd">major parameters. This is used for quick bucket indexing internally in this</span>
<span class="sd">module.</span>

<span class="sd">One issue that occurs from this is that we cannot effectively hash a</span>
<span class="sd">`hikari.internal.routes.CompiledRoute` that has not yet been hit, meaning that</span>
<span class="sd">until we receive a response from this endpoint, we have no idea what our rate</span>
<span class="sd">limits could be, nor the bucket that they sit in. This is usually not</span>
<span class="sd">problematic, as the first request to an endpoint should never be rate limited</span>
<span class="sd">unless you are hitting it from elsewhere in the same time window outside your</span>
<span class="sd">hikari.applications. To manage this situation, unknown endpoints are allocated to</span>
<span class="sd">a special unlimited bucket until they have an initial bucket hash code allocated</span>
<span class="sd">from a response. Once this happens, the route is reallocated a dedicated bucket.</span>
<span class="sd">Unknown buckets have a hardcoded initial hash code internally.</span>

<span class="sd">Initially acquiring time on a bucket</span>
<span class="sd">------------------------------------</span>

<span class="sd">Each time you `BaseRateLimiter.acquire()` a request timeslice for a given</span>
<span class="sd">`hikari.internal.routes.Route`, several things happen. The first is that we</span>
<span class="sd">attempt to find the existing bucket for that route, if there is one, or get an</span>
<span class="sd">unknown bucket otherwise. This is done by creating a real bucket hash from the</span>
<span class="sd">compiled route. The initial hash is calculated using a lookup table that maps</span>
<span class="sd">`hikari.internal.routes.CompiledRoute` objects to their corresponding initial hash</span>
<span class="sd">codes, or to the unknown bucket hash code if not yet known. This initial hash is</span>
<span class="sd">processed by the `hikari.internal.routes.CompiledRoute` to provide the real bucket</span>
<span class="sd">hash we need to get the route&#39;s bucket object internally.</span>

<span class="sd">The `BaseRateLimiter.acquire()` method will take the bucket and acquire a new</span>
<span class="sd">timeslice on it. This takes the form of a `asyncio.Future` which should be</span>
<span class="sd">awaited by the caller and will complete once the caller is allowed to make a</span>
<span class="sd">request. Most of the time, this is done instantly, but if the bucket has an</span>
<span class="sd">active rate limit preventing requests being sent, then the future will be paused</span>
<span class="sd">until the rate limit is over. This may be longer than the rate limit period if</span>
<span class="sd">you have queued a large number of requests during this limit, as it is</span>
<span class="sd">first-come-first-served.</span>

<span class="sd">Acquiring a rate limited bucket will start a bucket-wide task (if not already</span>
<span class="sd">running) that will wait until the rate limit has completed before allowing more</span>
<span class="sd">futures to complete. This is done while observing the rate limits again, so can</span>
<span class="sd">easily begin to re-ratelimit itself if needed. Once the task is complete, it</span>
<span class="sd">tidies itself up and disposes of itself. This task will complete once the queue</span>
<span class="sd">becomes empty.</span>

<span class="sd">The result of `RESTBucketManager.acquire()` is a tuple of a `asyncio.Future` to</span>
<span class="sd">await on which completes when you are allowed to proceed with making a request,</span>
<span class="sd">and a real bucket hash which should be stored temporarily. This will be</span>
<span class="sd">explained in the next section.</span>

<span class="sd">Handling the rate limit headers of a response</span>
<span class="sd">---------------------------------------------</span>

<span class="sd">Once you have received your response, you are expected to extract the values of</span>
<span class="sd">the vital rate limit headers manually and parse them to the correct data types.</span>
<span class="sd">These headers are:</span>

<span class="sd">* `X-RateLimit-Limit`:</span>
<span class="sd">    an `int` describing the max requests in the bucket from empty to</span>
<span class="sd">    being rate limited.</span>
<span class="sd">* `X-RateLimit-Remaining`:</span>
<span class="sd">    an `int` describing the remaining number of requests before rate</span>
<span class="sd">    limiting occurs in the current window.</span>
<span class="sd">* `X-RateLimit-Bucket`:</span>
<span class="sd">    a `str` containing the initial bucket hash.</span>
<span class="sd">* `X-RateLimit-Reset-After`:</span>
<span class="sd">    a `float` containing the number of seconds when the current rate</span>
<span class="sd">    limit bucket will reset with decimal millisecond precision.</span>

<span class="sd">Each of the above values should be passed to the `update_rate_limits` method to</span>
<span class="sd">ensure that the bucket you acquired time from is correctly updated should</span>
<span class="sd">Discord decide to alter their ratelimits on the fly without warning (including</span>
<span class="sd">timings and the bucket).</span>

<span class="sd">This method will manage creating new buckets as needed and resetting vital</span>
<span class="sd">information in each bucket you use.</span>

<span class="sd">Tidying up</span>
<span class="sd">----------</span>

<span class="sd">To prevent unused buckets cluttering up memory, each `RESTBucketManager`</span>
<span class="sd">instance spins up a `asyncio.Task` that periodically locks the bucket list</span>
<span class="sd">(not threadsafe, only using the concept of asyncio not yielding in regular</span>
<span class="sd">functions) and disposes of any clearly stale buckets that are no longer needed.</span>
<span class="sd">These will be recreated again in the future if they are needed.</span>

<span class="sd">When shutting down an application, one must remember to `close()` the</span>
<span class="sd">`RESTBucketManager` that has been used. This will ensure the garbage collection</span>
<span class="sd">task is stopped, and will also ensure any remaining futures in any bucket queues</span>
<span class="sd">have an `asyncio.CancelledError` set on them to prevent deadlocking ratelimited</span>
<span class="sd">calls that may be waiting to be unlocked.</span>

<span class="sd">Body-field-specific rate limiting</span>
<span class="sd">---------------------------------</span>

<span class="sd">As of the start of June, 2020, Discord appears to be enforcing another layer</span>
<span class="sd">of rate limiting logic to their HTTP APIs which is field-specific. This means</span>
<span class="sd">that special rate limits will also exist on some endpoints that limit based</span>
<span class="sd">on what attributes you send in a JSON or form data payload.</span>

<span class="sd">No information is sent in headers about these specific limits. You will only</span>
<span class="sd">be made aware that they exist once you get ratelimited. In the 429 ratelimited</span>
<span class="sd">response, you will have the `&quot;global&quot;` attribute set to `False`, and a</span>
<span class="sd">`&quot;reset_after&quot;` attribute that differs entirely to the `X-RateLimit-Reset-After`</span>
<span class="sd">header. Thus, it is important to not assume the value in the 429 response</span>
<span class="sd">for the reset time is the same as the one in the bucket headers. Hikari&#39;s</span>
<span class="sd">`hikari.api.rest.RESTClient` implementation specifically uses the value furthest</span>
<span class="sd">in the future when working out which bucket to adhere to.</span>

<span class="sd">It is worth remembering that there is an API limit to the number of 401s,</span>
<span class="sd">403s, and 429s you receive, which is around 10,000 per 15 minutes. Passing this</span>
<span class="sd">limit results in a soft ban of your account.</span>

<span class="sd">At the time of writing, the only example of this appears to be on the</span>
<span class="sd">`PATCH /channels/{channel_id}` endpoint. This has a limit of two changes per</span>
<span class="sd">10 minutes. More details about how this is implemented have yet to be</span>
<span class="sd">released or documented...</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="n">__all__</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;UNKNOWN_HASH&quot;</span><span class="p">,</span> <span class="s2">&quot;RESTBucket&quot;</span><span class="p">,</span> <span class="s2">&quot;RESTBucketManager&quot;</span><span class="p">]</span>

<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">typing</span>

<span class="kn">from</span> <span class="nn">hikari</span> <span class="kn">import</span> <span class="n">errors</span>
<span class="kn">from</span> <span class="nn">hikari.impl</span> <span class="kn">import</span> <span class="n">rate_limits</span>
<span class="kn">from</span> <span class="nn">hikari.internal</span> <span class="kn">import</span> <span class="n">routes</span>
<span class="kn">from</span> <span class="nn">hikari.internal</span> <span class="kn">import</span> <span class="n">time</span>
<span class="kn">from</span> <span class="nn">hikari.internal</span> <span class="kn">import</span> <span class="n">ux</span>

<span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">types</span>

<span class="n">UNKNOWN_HASH</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Final</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;UNKNOWN&quot;</span>
<span class="sd">&quot;&quot;&quot;The hash used for an unknown bucket that has not yet been resolved.&quot;&quot;&quot;</span>

<span class="n">_LOGGER</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Final</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;hikari.ratelimits&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">RESTBucket</span><span class="p">(</span><span class="n">rate_limits</span><span class="o">.</span><span class="n">WindowedBurstRateLimiter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a rate limit for an HTTP endpoint.</span>

<span class="sd">    Component to represent an active rate limit bucket on a specific HTTP route</span>
<span class="sd">    with a specific major parameter combo.</span>

<span class="sd">    This is somewhat similar to the `WindowedBurstRateLimiter` in how it</span>
<span class="sd">    works.</span>

<span class="sd">    This algorithm will use fixed-period time windows that have a given limit</span>
<span class="sd">    (capacity). Each time a task requests processing time, it will drip another</span>
<span class="sd">    unit into the bucket. Once the bucket has reached its limit, nothing can</span>
<span class="sd">    drip and new tasks will be queued until the time window finishes.</span>

<span class="sd">    Once the time window finishes, the bucket will empty, returning the current</span>
<span class="sd">    capacity to zero, and tasks that are queued will start being able to drip</span>
<span class="sd">    again.</span>

<span class="sd">    Additional logic is provided by the `RESTBucket.update_rate_limit` call</span>
<span class="sd">    which allows dynamically changing the enforced rate limits at any time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_compiled_route&quot;</span><span class="p">,</span> <span class="s2">&quot;_max_rate_limit&quot;</span><span class="p">,</span> <span class="s2">&quot;_lock&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">compiled_route</span><span class="p">:</span> <span class="n">routes</span><span class="o">.</span><span class="n">CompiledRoute</span><span class="p">,</span> <span class="n">max_rate_limit</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compiled_route</span> <span class="o">=</span> <span class="n">compiled_route</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_rate_limit</span> <span class="o">=</span> <span class="n">max_rate_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aexit__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">exc_type</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Type</span><span class="p">[</span><span class="ne">BaseException</span><span class="p">]],</span>
        <span class="n">exc</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="ne">BaseException</span><span class="p">],</span>
        <span class="n">exc_tb</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">TracebackType</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_unknown</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return `True` if the bucket represents an `UNKNOWN` bucket.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">UNKNOWN_HASH</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Acquire time on this rate limiter.</span>

<span class="sd">        .. note::</span>
<span class="sd">            You should afterwards invoke `RESTBucket.update_rate_limit` to</span>
<span class="sd">            update any rate limit information you are made aware of.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        hikari.errors.RateLimitTooLongError</span>
<span class="sd">            If the rate limit is longer than `max_rate_limit`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>
        <span class="n">retry_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">-</span> <span class="n">now</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_rate_limited</span><span class="p">(</span><span class="n">now</span><span class="p">)</span> <span class="ow">and</span> <span class="n">retry_after</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_rate_limit</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">RateLimitTooLongError</span><span class="p">(</span>
                <span class="n">route</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compiled_route</span><span class="p">,</span>
                <span class="n">retry_after</span><span class="o">=</span><span class="n">retry_after</span><span class="p">,</span>
                <span class="n">max_retry_after</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_rate_limit</span><span class="p">,</span>
                <span class="n">reset_at</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span><span class="p">,</span>
                <span class="n">limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">,</span>
                <span class="n">period</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">await</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">update_rate_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remaining</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">reset_at</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Update the rate limit information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        remaining : int</span>
<span class="sd">            The calls remaining in this time window.</span>
<span class="sd">        limit : int</span>
<span class="sd">            The total calls allowed in this time window.</span>
<span class="sd">        reset_at : float</span>
<span class="sd">            The epoch at which to reset the limit.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The `reset_at` epoch is expected to be a `time.monotonic_timestamp`</span>
<span class="sd">            monotonic epoch, rather than a `time.time` date-based epoch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remaining</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">remaining</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">reset_at</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">-</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">drip</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Decrement the remaining count for this bucket.</span>

<span class="sd">        .. note::</span>
<span class="sd">            If the bucket is marked as `RESTBucket.is_unknown`, then this will</span>
<span class="sd">            not do anything. `Unknown` buckets have infinite rate limits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We don&#39;t drip unknown buckets: we cannot rate limit them as we don&#39;t know their real bucket hash or</span>
        <span class="c1"># the current rate limit values Discord put on them...</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remaining</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">resolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">real_bucket_hash</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Resolve an unknown bucket.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        real_bucket_hash: str</span>
<span class="sd">            The real bucket hash for this bucket.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If the hash of the bucket is already known.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot resolve known bucket&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">real_bucket_hash</span>


<span class="k">def</span> <span class="nf">_create_unknown_hash</span><span class="p">(</span><span class="n">route</span><span class="p">:</span> <span class="n">routes</span><span class="o">.</span><span class="n">CompiledRoute</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">UNKNOWN_HASH</span> <span class="o">+</span> <span class="n">routes</span><span class="o">.</span><span class="n">HASH_SEPARATOR</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">route</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">RESTBucketManager</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;The main rate limiter implementation for HTTP clients.</span>

<span class="sd">    This is designed to provide bucketed rate limiting for Discord HTTP</span>
<span class="sd">    endpoints that respects the `X-RateLimit-Bucket` rate limit header. To do</span>
<span class="sd">    this, it makes the assumption that any limit can change at any time.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    max_rate_limit : float</span>
<span class="sd">        The max number of seconds to backoff for when rate limited. Anything</span>
<span class="sd">        greater than this will instead raise an error.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;routes_to_hashes&quot;</span><span class="p">,</span>
        <span class="s2">&quot;real_hashes_to_buckets&quot;</span><span class="p">,</span>
        <span class="s2">&quot;closed_event&quot;</span><span class="p">,</span>
        <span class="s2">&quot;gc_task&quot;</span><span class="p">,</span>
        <span class="s2">&quot;max_rate_limit&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">routes_to_hashes</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Final</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">MutableMapping</span><span class="p">[</span><span class="n">routes</span><span class="o">.</span><span class="n">Route</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span>
    <span class="sd">&quot;&quot;&quot;Maps routes to their `X-RateLimit-Bucket` header being used.&quot;&quot;&quot;</span>

    <span class="n">real_hashes_to_buckets</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Final</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">MutableMapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">RESTBucket</span><span class="p">]]</span>
    <span class="sd">&quot;&quot;&quot;Maps full bucket hashes (`X-RateLimit-Bucket` appended with a hash of</span>
<span class="sd">    major parameters used in that compiled route) to their corresponding rate</span>
<span class="sd">    limiters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">closed_event</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Final</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;An internal event that is set when the object is shut down.&quot;&quot;&quot;</span>

    <span class="n">gc_task</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Task</span><span class="p">[</span><span class="kc">None</span><span class="p">]]</span>
    <span class="sd">&quot;&quot;&quot;The internal garbage collector task.&quot;&quot;&quot;</span>

    <span class="n">max_rate_limit</span><span class="p">:</span> <span class="nb">float</span>
    <span class="sd">&quot;&quot;&quot;The max number of seconds to backoff for when rate limited.</span>

<span class="sd">    Anything greater than this will instead raise an error.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_rate_limit</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">routes_to_hashes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">closed_event</span><span class="p">:</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Task</span><span class="p">[</span><span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_rate_limit</span> <span class="o">=</span> <span class="n">max_rate_limit</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RESTBucketManager</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">exc_type</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Type</span><span class="p">[</span><span class="ne">Exception</span><span class="p">]],</span>
        <span class="n">exc_val</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="ne">Exception</span><span class="p">],</span>
        <span class="n">exc_tb</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">TracebackType</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poll_period</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">20.0</span><span class="p">,</span> <span class="n">expire_after</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Start this ratelimiter up.</span>

<span class="sd">        This spins up internal garbage collection logic in the background to</span>
<span class="sd">        keep memory usage to an optimal level as old routes and bucket hashes</span>
<span class="sd">        get discarded and replaced.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        poll_period : float</span>
<span class="sd">            Period to poll the garbage collector at in seconds. Defaults</span>
<span class="sd">            to `20` seconds.</span>
<span class="sd">        expire_after : float</span>
<span class="sd">            Time after which the last `reset_at` was hit for a bucket to</span>
<span class="sd">            remove it. Higher values will retain unneeded ratelimit info for</span>
<span class="sd">            longer, but may produce more effective rate-limiting logic as a</span>
<span class="sd">            result. Using `0` will make the bucket get garbage collected as soon</span>
<span class="sd">            as the rate limit has reset. Defaults to `10` seconds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gc</span><span class="p">(</span><span class="n">poll_period</span><span class="p">,</span> <span class="n">expire_after</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Close the garbage collector and kill any tasks waiting on ratelimits.</span>

<span class="sd">        Once this has been called, this object is considered to be effectively</span>
<span class="sd">        dead. To reuse it, one should create a new instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">closed_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">bucket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">routes_to_hashes</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Ignore docstring not starting in an imperative mood</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">gc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poll_period</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">expire_after</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The garbage collector loop.</span>

<span class="sd">        This is designed to run in the background and manage removing unused</span>
<span class="sd">        route references from the rate-limiter collection to save memory.</span>

<span class="sd">        This will run forever until `RESTBucketManager.closed_event` is set.</span>
<span class="sd">        This will invoke `RESTBucketManager.do_gc_pass` periodically.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        poll_period : float</span>
<span class="sd">            The period to poll at.</span>
<span class="sd">        expire_after : float</span>
<span class="sd">            Time after which the last `reset_at` was hit for a bucket to</span>
<span class="sd">            remove it. Higher values will retain unneeded ratelimit info for</span>
<span class="sd">            longer, but may produce more effective ratelimiting logic as a</span>
<span class="sd">            result. Using `0` will make the bucket get garbage collected as soon</span>
<span class="sd">            as the rate limit has reset.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            You generally have no need to invoke this directly. Use</span>
<span class="sd">            `RESTBucketManager.start` and `RESTBucketManager.close` to control</span>
<span class="sd">            this instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa: D401 - Imperative mood</span>
        <span class="c1"># Prevent filling memory increasingly until we run out by removing dead buckets every 20s</span>
        <span class="c1"># Allocations are somewhat cheap if we only do them every so-many seconds, after all.</span>
        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ux</span><span class="o">.</span><span class="n">TRACE</span><span class="p">,</span> <span class="s2">&quot;rate limit garbage collector started&quot;</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">closed_event</span><span class="o">.</span><span class="n">wait</span><span class="p">(),</span> <span class="n">timeout</span><span class="o">=</span><span class="n">poll_period</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">TimeoutError</span><span class="p">:</span>
                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ux</span><span class="o">.</span><span class="n">TRACE</span><span class="p">,</span> <span class="s2">&quot;performing rate limit garbage collection pass&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">do_gc_pass</span><span class="p">(</span><span class="n">expire_after</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">do_gc_pass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expire_after</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Perform a single garbage collection pass.</span>

<span class="sd">        This will assess any routes stored in the internal mappings of this</span>
<span class="sd">        object and remove any that are deemed to be inactive or dead in order</span>
<span class="sd">        to save memory.</span>

<span class="sd">        If the removed routes are used again in the future, they will be</span>
<span class="sd">        re-cached automatically.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expire_after : float</span>
<span class="sd">            Time after which the last `reset_at` was hit for a bucket to\</span>
<span class="sd">            remove it. Defaults to `reset_at` + 20 seconds. Higher values will</span>
<span class="sd">            retain unneeded ratelimit info for longer, but may produce more</span>
<span class="sd">            effective ratelimiting logic as a result.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            You generally have no need to invoke this directly. Use</span>
<span class="sd">            `RESTBucketManager.start` and `RESTBucketManager.close` to control</span>
<span class="sd">            this instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">buckets_to_purge</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>

        <span class="c1"># We have three main states that a bucket can be in:</span>
        <span class="c1"># 1. active - the bucket is active and is not at risk of deallocation</span>
        <span class="c1"># 2. survival - the bucket is inactive but is still fresh enough to be kept alive.</span>
        <span class="c1"># 3. death - the bucket has been inactive for too long.</span>
        <span class="n">active</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Discover and purge</span>
        <span class="n">bucket_pairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">full_hash</span><span class="p">,</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="n">bucket_pairs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bucket</span><span class="o">.</span><span class="n">is_empty</span> <span class="ow">and</span> <span class="n">bucket</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">+</span> <span class="n">expire_after</span> <span class="o">&lt;</span> <span class="n">now</span><span class="p">:</span>
                <span class="c1"># If it is still running a throttle and is in memory, it will remain in memory</span>
                <span class="c1"># but we will not know about it.</span>
                <span class="n">buckets_to_purge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">full_hash</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">bucket</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">&gt;=</span> <span class="n">now</span><span class="p">:</span>
                <span class="n">active</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">dead</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">buckets_to_purge</span><span class="p">)</span>
        <span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bucket_pairs</span><span class="p">)</span>
        <span class="n">survival</span> <span class="o">=</span> <span class="n">total</span> <span class="o">-</span> <span class="n">active</span> <span class="o">-</span> <span class="n">dead</span>

        <span class="k">for</span> <span class="n">full_hash</span> <span class="ow">in</span> <span class="n">buckets_to_purge</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="p">[</span><span class="n">full_hash</span><span class="p">]</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="p">[</span><span class="n">full_hash</span><span class="p">]</span>

        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ux</span><span class="o">.</span><span class="n">TRACE</span><span class="p">,</span> <span class="s2">&quot;purged </span><span class="si">%s</span><span class="s2"> stale buckets, </span><span class="si">%s</span><span class="s2"> remain in survival, </span><span class="si">%s</span><span class="s2"> active&quot;</span><span class="p">,</span> <span class="n">dead</span><span class="p">,</span> <span class="n">survival</span><span class="p">,</span> <span class="n">active</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compiled_route</span><span class="p">:</span> <span class="n">routes</span><span class="o">.</span><span class="n">CompiledRoute</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">AsyncContextManager</span><span class="p">[</span><span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Acquire a bucket for the given route.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compiled_route : hikari.internal.routes.CompiledRoute</span>
<span class="sd">            The route to get the bucket for.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        typing.AsyncContextManager[None]</span>
<span class="sd">            A context manager to enter while doing the request.</span>

<span class="sd">        .. note::</span>
<span class="sd">            You MUST keep the context manager acquired during the whole of the</span>
<span class="sd">            request. From making the request until calling `update_rate_limits`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">compiled_route</span><span class="o">.</span><span class="n">route</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">bucket_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">routes_to_hashes</span><span class="p">[</span><span class="n">template</span><span class="p">]</span>
            <span class="n">real_bucket_hash</span> <span class="o">=</span> <span class="n">compiled_route</span><span class="o">.</span><span class="n">create_real_bucket_hash</span><span class="p">(</span><span class="n">bucket_hash</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">real_bucket_hash</span> <span class="o">=</span> <span class="n">_create_unknown_hash</span><span class="p">(</span><span class="n">compiled_route</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">bucket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="p">[</span><span class="n">real_bucket_hash</span><span class="p">]</span>
            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is being mapped to existing bucket </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">compiled_route</span><span class="p">,</span> <span class="n">real_bucket_hash</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is being mapped to new bucket </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">compiled_route</span><span class="p">,</span> <span class="n">real_bucket_hash</span><span class="p">)</span>
            <span class="n">bucket</span> <span class="o">=</span> <span class="n">RESTBucket</span><span class="p">(</span><span class="n">real_bucket_hash</span><span class="p">,</span> <span class="n">compiled_route</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_rate_limit</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="p">[</span><span class="n">real_bucket_hash</span><span class="p">]</span> <span class="o">=</span> <span class="n">bucket</span>

        <span class="k">return</span> <span class="n">bucket</span>

    <span class="k">def</span> <span class="nf">update_rate_limits</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">compiled_route</span><span class="p">:</span> <span class="n">routes</span><span class="o">.</span><span class="n">CompiledRoute</span><span class="p">,</span>
        <span class="n">bucket_header</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">remaining_header</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">limit_header</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">reset_after</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Update the rate limits for a bucket using info from a response.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compiled_route : hikari.internal.routes.CompiledRoute</span>
<span class="sd">            The compiled route to get the bucket for.</span>
<span class="sd">        bucket_header : typing.Optional[str]</span>
<span class="sd">            The `X-RateLimit-Bucket` header that was provided in the response.</span>
<span class="sd">        remaining_header : int</span>
<span class="sd">            The `X-RateLimit-Remaining` header cast to an `int`.</span>
<span class="sd">        limit_header : int</span>
<span class="sd">            The `X-RateLimit-Limit` header cast to an `int`.</span>
<span class="sd">        reset_after : float</span>
<span class="sd">            The `X-RateLimit-Reset-After` header cast to a `float`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">routes_to_hashes</span><span class="p">[</span><span class="n">compiled_route</span><span class="o">.</span><span class="n">route</span><span class="p">]</span> <span class="o">=</span> <span class="n">bucket_header</span>
        <span class="n">real_bucket_hash</span> <span class="o">=</span> <span class="n">compiled_route</span><span class="o">.</span><span class="n">create_real_bucket_hash</span><span class="p">(</span><span class="n">bucket_header</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bucket</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">real_bucket_hash</span><span class="p">):</span>
            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;updating </span><span class="si">%s</span><span class="s2"> with bucket </span><span class="si">%s</span><span class="s2"> [reset-after:</span><span class="si">%s</span><span class="s2">s, limit:</span><span class="si">%s</span><span class="s2">, remaining:</span><span class="si">%s</span><span class="s2">]&quot;</span><span class="p">,</span>
                <span class="n">compiled_route</span><span class="p">,</span>
                <span class="n">real_bucket_hash</span><span class="p">,</span>
                <span class="n">reset_after</span><span class="p">,</span>
                <span class="n">limit_header</span><span class="p">,</span>
                <span class="n">remaining_header</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unknown_bucket_hash</span> <span class="o">=</span> <span class="n">_create_unknown_hash</span><span class="p">(</span><span class="n">compiled_route</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">bucket</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">unknown_bucket_hash</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">bucket</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">real_bucket_hash</span><span class="p">)</span>
                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;remapping </span><span class="si">%s</span><span class="s2"> with existing bucket </span><span class="si">%s</span><span class="s2"> [reset-after:</span><span class="si">%s</span><span class="s2">s, limit:</span><span class="si">%s</span><span class="s2">, remaining:</span><span class="si">%s</span><span class="s2">]&quot;</span><span class="p">,</span>
                    <span class="n">compiled_route</span><span class="p">,</span>
                    <span class="n">unknown_bucket_hash</span><span class="p">,</span>
                    <span class="n">reset_after</span><span class="p">,</span>
                    <span class="n">limit_header</span><span class="p">,</span>
                    <span class="n">remaining_header</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;remapping </span><span class="si">%s</span><span class="s2"> with new bucket </span><span class="si">%s</span><span class="s2"> [reset-after:</span><span class="si">%s</span><span class="s2">s, limit:</span><span class="si">%s</span><span class="s2">, remaining:</span><span class="si">%s</span><span class="s2">]&quot;</span><span class="p">,</span>
                    <span class="n">compiled_route</span><span class="p">,</span>
                    <span class="n">real_bucket_hash</span><span class="p">,</span>
                    <span class="n">reset_after</span><span class="p">,</span>
                    <span class="n">limit_header</span><span class="p">,</span>
                    <span class="n">remaining_header</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">bucket</span> <span class="o">=</span> <span class="n">RESTBucket</span><span class="p">(</span><span class="n">real_bucket_hash</span><span class="p">,</span> <span class="n">compiled_route</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_rate_limit</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="p">[</span><span class="n">real_bucket_hash</span><span class="p">]</span> <span class="o">=</span> <span class="n">bucket</span>

        <span class="n">reset_at_monotonic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">+</span> <span class="n">reset_after</span>
        <span class="n">bucket</span><span class="o">.</span><span class="n">update_rate_limit</span><span class="p">(</span><span class="n">remaining_header</span><span class="p">,</span> <span class="n">limit_header</span><span class="p">,</span> <span class="n">reset_at_monotonic</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_started</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return `True` if the rate limiter GC task is started.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
</pre></div>

        </details>

        </section>

            <section id="UNKNOWN_HASH">
                    
            <div class="attr variable"><a class="headerlink" href="#UNKNOWN_HASH">#&nbsp;&nbsp</a>

        <span class="name">UNKNOWN_HASH</span><span class="annotation">: Final[str]</span>
    </div>

            <div class="docstring"><p>The hash used for an unknown bucket that has not yet been resolved.</p>
</div>


            </section>
            <section id="RESTBucket">
                    
            <div class="attr class">
        <a class="headerlink" href="#RESTBucket">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">RESTBucket</span><wbr>(<span class="base"><a href="rate_limits.html#WindowedBurstRateLimiter">hikari.impl.rate_limits.WindowedBurstRateLimiter</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">RESTBucket</span><span class="p">(</span><span class="n">rate_limits</span><span class="o">.</span><span class="n">WindowedBurstRateLimiter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a rate limit for an HTTP endpoint.</span>

<span class="sd">    Component to represent an active rate limit bucket on a specific HTTP route</span>
<span class="sd">    with a specific major parameter combo.</span>

<span class="sd">    This is somewhat similar to the `WindowedBurstRateLimiter` in how it</span>
<span class="sd">    works.</span>

<span class="sd">    This algorithm will use fixed-period time windows that have a given limit</span>
<span class="sd">    (capacity). Each time a task requests processing time, it will drip another</span>
<span class="sd">    unit into the bucket. Once the bucket has reached its limit, nothing can</span>
<span class="sd">    drip and new tasks will be queued until the time window finishes.</span>

<span class="sd">    Once the time window finishes, the bucket will empty, returning the current</span>
<span class="sd">    capacity to zero, and tasks that are queued will start being able to drip</span>
<span class="sd">    again.</span>

<span class="sd">    Additional logic is provided by the `RESTBucket.update_rate_limit` call</span>
<span class="sd">    which allows dynamically changing the enforced rate limits at any time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_compiled_route&quot;</span><span class="p">,</span> <span class="s2">&quot;_max_rate_limit&quot;</span><span class="p">,</span> <span class="s2">&quot;_lock&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">compiled_route</span><span class="p">:</span> <span class="n">routes</span><span class="o">.</span><span class="n">CompiledRoute</span><span class="p">,</span> <span class="n">max_rate_limit</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compiled_route</span> <span class="o">=</span> <span class="n">compiled_route</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_rate_limit</span> <span class="o">=</span> <span class="n">max_rate_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__aexit__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">exc_type</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Type</span><span class="p">[</span><span class="ne">BaseException</span><span class="p">]],</span>
        <span class="n">exc</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="ne">BaseException</span><span class="p">],</span>
        <span class="n">exc_tb</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">TracebackType</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_unknown</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return `True` if the bucket represents an `UNKNOWN` bucket.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">UNKNOWN_HASH</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Acquire time on this rate limiter.</span>

<span class="sd">        .. note::</span>
<span class="sd">            You should afterwards invoke `RESTBucket.update_rate_limit` to</span>
<span class="sd">            update any rate limit information you are made aware of.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        hikari.errors.RateLimitTooLongError</span>
<span class="sd">            If the rate limit is longer than `max_rate_limit`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>
        <span class="n">retry_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">-</span> <span class="n">now</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_rate_limited</span><span class="p">(</span><span class="n">now</span><span class="p">)</span> <span class="ow">and</span> <span class="n">retry_after</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_rate_limit</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">RateLimitTooLongError</span><span class="p">(</span>
                <span class="n">route</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compiled_route</span><span class="p">,</span>
                <span class="n">retry_after</span><span class="o">=</span><span class="n">retry_after</span><span class="p">,</span>
                <span class="n">max_retry_after</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_rate_limit</span><span class="p">,</span>
                <span class="n">reset_at</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span><span class="p">,</span>
                <span class="n">limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">,</span>
                <span class="n">period</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">await</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">update_rate_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remaining</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">reset_at</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Update the rate limit information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        remaining : int</span>
<span class="sd">            The calls remaining in this time window.</span>
<span class="sd">        limit : int</span>
<span class="sd">            The total calls allowed in this time window.</span>
<span class="sd">        reset_at : float</span>
<span class="sd">            The epoch at which to reset the limit.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The `reset_at` epoch is expected to be a `time.monotonic_timestamp`</span>
<span class="sd">            monotonic epoch, rather than a `time.time` date-based epoch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remaining</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">remaining</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">reset_at</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">-</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">drip</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Decrement the remaining count for this bucket.</span>

<span class="sd">        .. note::</span>
<span class="sd">            If the bucket is marked as `RESTBucket.is_unknown`, then this will</span>
<span class="sd">            not do anything. `Unknown` buckets have infinite rate limits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We don&#39;t drip unknown buckets: we cannot rate limit them as we don&#39;t know their real bucket hash or</span>
        <span class="c1"># the current rate limit values Discord put on them...</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remaining</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">resolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">real_bucket_hash</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Resolve an unknown bucket.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        real_bucket_hash: str</span>
<span class="sd">            The real bucket hash for this bucket.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If the hash of the bucket is already known.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot resolve known bucket&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">real_bucket_hash</span>
</pre></div>

        </details>

            <div class="docstring"><p>Represents a rate limit for an HTTP endpoint.</p>

<p>Component to represent an active rate limit bucket on a specific HTTP route
with a specific major parameter combo.</p>

<p>This is somewhat similar to the <code>WindowedBurstRateLimiter</code> in how it
works.</p>

<p>This algorithm will use fixed-period time windows that have a given limit
(capacity). Each time a task requests processing time, it will drip another
unit into the bucket. Once the bucket has reached its limit, nothing can
drip and new tasks will be queued until the time window finishes.</p>

<p>Once the time window finishes, the bucket will empty, returning the current
capacity to zero, and tasks that are queued will start being able to drip
again.</p>

<p>Additional logic is provided by the <code><a href="#RESTBucket.update_rate_limit">RESTBucket.update_rate_limit</a></code> call
which allows dynamically changing the enforced rate limits at any time.</p>
</div>


                        <div id="RESTBucket.__init__" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#RESTBucket.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">RESTBucket</span><span class="signature">(
    name: str,
    compiled_route: <a href="../internal/routes.html#CompiledRoute">hikari.internal.routes.CompiledRoute</a>,
    max_rate_limit: float
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">compiled_route</span><span class="p">:</span> <span class="n">routes</span><span class="o">.</span><span class="n">CompiledRoute</span><span class="p">,</span> <span class="n">max_rate_limit</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compiled_route</span> <span class="o">=</span> <span class="n">compiled_route</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_rate_limit</span> <span class="o">=</span> <span class="n">max_rate_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
</pre></div>

        </details>

    

                        </div>
                        <div id="RESTBucket.is_unknown" class="classattr">
                                
            <div class="attr variable"><a class="headerlink" href="#RESTBucket.is_unknown">#&nbsp;&nbsp</a>

        <span class="name">is_unknown</span><span class="annotation">: bool</span>
    </div>

            <div class="docstring"><p>Return <code>True</code> if the bucket represents an <code>UNKNOWN</code> bucket.</p>
</div>


                        </div>
                        <div id="RESTBucket.acquire" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#RESTBucket.acquire">#&nbsp;&nbsp</a>

        
            <span class="def">async def</span>
            <span class="name">acquire</span><span class="signature">(self) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">async</span> <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Acquire time on this rate limiter.</span>

<span class="sd">        .. note::</span>
<span class="sd">            You should afterwards invoke `RESTBucket.update_rate_limit` to</span>
<span class="sd">            update any rate limit information you are made aware of.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        hikari.errors.RateLimitTooLongError</span>
<span class="sd">            If the rate limit is longer than `max_rate_limit`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>
        <span class="n">retry_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">-</span> <span class="n">now</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_rate_limited</span><span class="p">(</span><span class="n">now</span><span class="p">)</span> <span class="ow">and</span> <span class="n">retry_after</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_rate_limit</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">RateLimitTooLongError</span><span class="p">(</span>
                <span class="n">route</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compiled_route</span><span class="p">,</span>
                <span class="n">retry_after</span><span class="o">=</span><span class="n">retry_after</span><span class="p">,</span>
                <span class="n">max_retry_after</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_rate_limit</span><span class="p">,</span>
                <span class="n">reset_at</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span><span class="p">,</span>
                <span class="n">limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">,</span>
                <span class="n">period</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">await</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Acquire time on this rate limiter.</p>

<p><em>Note:</em>
You should afterwards invoke <code><a href="#RESTBucket.update_rate_limit">RESTBucket.update_rate_limit</a></code> to
update any rate limit information you are made aware of.</p>

<h6 id="raises">Raises</h6>

<ul>
<li><strong><a href="../errors.html#RateLimitTooLongError">hikari.errors.RateLimitTooLongError</a></strong>: If the rate limit is longer than <code>max_rate_limit</code>.</li>
</ul>
</div>


                        </div>
                        <div id="RESTBucket.update_rate_limit" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#RESTBucket.update_rate_limit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">update_rate_limit</span><span class="signature">(self, remaining: int, limit: int, reset_at: float) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">update_rate_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remaining</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">reset_at</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Update the rate limit information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        remaining : int</span>
<span class="sd">            The calls remaining in this time window.</span>
<span class="sd">        limit : int</span>
<span class="sd">            The total calls allowed in this time window.</span>
<span class="sd">        reset_at : float</span>
<span class="sd">            The epoch at which to reset the limit.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The `reset_at` epoch is expected to be a `time.monotonic_timestamp`</span>
<span class="sd">            monotonic epoch, rather than a `time.time` date-based epoch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remaining</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">remaining</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">reset_at</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">-</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">())</span>
</pre></div>

        </details>

            <div class="docstring"><p>Update the rate limit information.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>remaining</strong> (int):
The calls remaining in this time window.</li>
<li><strong>limit</strong> (int):
The total calls allowed in this time window.</li>
<li><strong>reset_at</strong> (float):
The epoch at which to reset the limit.</li>
<li><p><strong><em>Note</strong> (</em>):</p></li>
<li><p><strong>The <code><a href="#RESTBucket.reset_at">reset_at</a></code> epoch is expected to be a <code>time.monotonic_timestamp</code></strong></p></li>
<li><strong>monotonic epoch, rather than a <code>time.time</code> date-based epoch.</strong></li>
</ul>
</div>


                        </div>
                        <div id="RESTBucket.drip" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#RESTBucket.drip">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">drip</span><span class="signature">(self) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">drip</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Decrement the remaining count for this bucket.</span>

<span class="sd">        .. note::</span>
<span class="sd">            If the bucket is marked as `RESTBucket.is_unknown`, then this will</span>
<span class="sd">            not do anything. `Unknown` buckets have infinite rate limits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We don&#39;t drip unknown buckets: we cannot rate limit them as we don&#39;t know their real bucket hash or</span>
        <span class="c1"># the current rate limit values Discord put on them...</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remaining</span> <span class="o">-=</span> <span class="mi">1</span>
</pre></div>

        </details>

            <div class="docstring"><p>Decrement the remaining count for this bucket.</p>

<p><em>Note:</em>
If the bucket is marked as <code><a href="#RESTBucket.is_unknown">RESTBucket.is_unknown</a></code>, then this will
not do anything. <code>Unknown</code> buckets have infinite rate limits.</p>
</div>


                        </div>
                        <div id="RESTBucket.resolve" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#RESTBucket.resolve">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">resolve</span><span class="signature">(self, real_bucket_hash: str) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">resolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">real_bucket_hash</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Resolve an unknown bucket.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        real_bucket_hash: str</span>
<span class="sd">            The real bucket hash for this bucket.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If the hash of the bucket is already known.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot resolve known bucket&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">real_bucket_hash</span>
</pre></div>

        </details>

            <div class="docstring"><p>Resolve an unknown bucket.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>real_bucket_hash</strong> (str):
The real bucket hash for this bucket.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>RuntimeError</strong>: If the hash of the bucket is already known.</li>
</ul>
</div>


                        </div>
                        <div class="inherited">
                            <h5>Inherited Members</h5>
                            <dl>
                                <div><dt><a href="rate_limits.html#WindowedBurstRateLimiter">hikari.impl.rate_limits.WindowedBurstRateLimiter</a></dt>
            <dd id="RESTBucket.throttle_task" class="variable"><a href="rate_limits.html#WindowedBurstRateLimiter.throttle_task">throttle_task</a></dd>
    <dd id="RESTBucket.reset_at" class="variable"><a href="rate_limits.html#WindowedBurstRateLimiter.reset_at">reset_at</a></dd>
    <dd id="RESTBucket.remaining" class="variable"><a href="rate_limits.html#WindowedBurstRateLimiter.remaining">remaining</a></dd>
    <dd id="RESTBucket.period" class="variable"><a href="rate_limits.html#WindowedBurstRateLimiter.period">period</a></dd>
    <dd id="RESTBucket.limit" class="variable"><a href="rate_limits.html#WindowedBurstRateLimiter.limit">limit</a></dd>
    <dd id="RESTBucket.get_time_until_reset" class="function"><a href="rate_limits.html#WindowedBurstRateLimiter.get_time_until_reset">get_time_until_reset</a></dd>
    <dd id="RESTBucket.is_rate_limited" class="function"><a href="rate_limits.html#WindowedBurstRateLimiter.is_rate_limited">is_rate_limited</a></dd>
    <dd id="RESTBucket.throttle" class="function"><a href="rate_limits.html#WindowedBurstRateLimiter.throttle">throttle</a></dd>

    </div>
    <div><dt><a href="rate_limits.html#BurstRateLimiter">hikari.impl.rate_limits.BurstRateLimiter</a></dt>
            <dd id="RESTBucket.name" class="variable"><a href="rate_limits.html#BurstRateLimiter.name">name</a></dd>
    <dd id="RESTBucket.queue" class="variable"><a href="rate_limits.html#BurstRateLimiter.queue">queue</a></dd>
    <dd id="RESTBucket.close" class="function"><a href="rate_limits.html#BurstRateLimiter.close">close</a></dd>
    <dd id="RESTBucket.is_empty" class="variable"><a href="rate_limits.html#BurstRateLimiter.is_empty">is_empty</a></dd>

    </div>
                            </dl>
                        </div>
            </section>
            <section id="RESTBucketManager">
                    
            <div class="attr class">
        <a class="headerlink" href="#RESTBucketManager">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">RESTBucketManager</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">RESTBucketManager</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;The main rate limiter implementation for HTTP clients.</span>

<span class="sd">    This is designed to provide bucketed rate limiting for Discord HTTP</span>
<span class="sd">    endpoints that respects the `X-RateLimit-Bucket` rate limit header. To do</span>
<span class="sd">    this, it makes the assumption that any limit can change at any time.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    max_rate_limit : float</span>
<span class="sd">        The max number of seconds to backoff for when rate limited. Anything</span>
<span class="sd">        greater than this will instead raise an error.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;routes_to_hashes&quot;</span><span class="p">,</span>
        <span class="s2">&quot;real_hashes_to_buckets&quot;</span><span class="p">,</span>
        <span class="s2">&quot;closed_event&quot;</span><span class="p">,</span>
        <span class="s2">&quot;gc_task&quot;</span><span class="p">,</span>
        <span class="s2">&quot;max_rate_limit&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">routes_to_hashes</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Final</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">MutableMapping</span><span class="p">[</span><span class="n">routes</span><span class="o">.</span><span class="n">Route</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span>
    <span class="sd">&quot;&quot;&quot;Maps routes to their `X-RateLimit-Bucket` header being used.&quot;&quot;&quot;</span>

    <span class="n">real_hashes_to_buckets</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Final</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">MutableMapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">RESTBucket</span><span class="p">]]</span>
    <span class="sd">&quot;&quot;&quot;Maps full bucket hashes (`X-RateLimit-Bucket` appended with a hash of</span>
<span class="sd">    major parameters used in that compiled route) to their corresponding rate</span>
<span class="sd">    limiters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">closed_event</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Final</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;An internal event that is set when the object is shut down.&quot;&quot;&quot;</span>

    <span class="n">gc_task</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Task</span><span class="p">[</span><span class="kc">None</span><span class="p">]]</span>
    <span class="sd">&quot;&quot;&quot;The internal garbage collector task.&quot;&quot;&quot;</span>

    <span class="n">max_rate_limit</span><span class="p">:</span> <span class="nb">float</span>
    <span class="sd">&quot;&quot;&quot;The max number of seconds to backoff for when rate limited.</span>

<span class="sd">    Anything greater than this will instead raise an error.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_rate_limit</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">routes_to_hashes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">closed_event</span><span class="p">:</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Task</span><span class="p">[</span><span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_rate_limit</span> <span class="o">=</span> <span class="n">max_rate_limit</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RESTBucketManager</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">exc_type</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Type</span><span class="p">[</span><span class="ne">Exception</span><span class="p">]],</span>
        <span class="n">exc_val</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="ne">Exception</span><span class="p">],</span>
        <span class="n">exc_tb</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">TracebackType</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poll_period</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">20.0</span><span class="p">,</span> <span class="n">expire_after</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Start this ratelimiter up.</span>

<span class="sd">        This spins up internal garbage collection logic in the background to</span>
<span class="sd">        keep memory usage to an optimal level as old routes and bucket hashes</span>
<span class="sd">        get discarded and replaced.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        poll_period : float</span>
<span class="sd">            Period to poll the garbage collector at in seconds. Defaults</span>
<span class="sd">            to `20` seconds.</span>
<span class="sd">        expire_after : float</span>
<span class="sd">            Time after which the last `reset_at` was hit for a bucket to</span>
<span class="sd">            remove it. Higher values will retain unneeded ratelimit info for</span>
<span class="sd">            longer, but may produce more effective rate-limiting logic as a</span>
<span class="sd">            result. Using `0` will make the bucket get garbage collected as soon</span>
<span class="sd">            as the rate limit has reset. Defaults to `10` seconds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gc</span><span class="p">(</span><span class="n">poll_period</span><span class="p">,</span> <span class="n">expire_after</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Close the garbage collector and kill any tasks waiting on ratelimits.</span>

<span class="sd">        Once this has been called, this object is considered to be effectively</span>
<span class="sd">        dead. To reuse it, one should create a new instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">closed_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">bucket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">routes_to_hashes</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Ignore docstring not starting in an imperative mood</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">gc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poll_period</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">expire_after</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The garbage collector loop.</span>

<span class="sd">        This is designed to run in the background and manage removing unused</span>
<span class="sd">        route references from the rate-limiter collection to save memory.</span>

<span class="sd">        This will run forever until `RESTBucketManager.closed_event` is set.</span>
<span class="sd">        This will invoke `RESTBucketManager.do_gc_pass` periodically.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        poll_period : float</span>
<span class="sd">            The period to poll at.</span>
<span class="sd">        expire_after : float</span>
<span class="sd">            Time after which the last `reset_at` was hit for a bucket to</span>
<span class="sd">            remove it. Higher values will retain unneeded ratelimit info for</span>
<span class="sd">            longer, but may produce more effective ratelimiting logic as a</span>
<span class="sd">            result. Using `0` will make the bucket get garbage collected as soon</span>
<span class="sd">            as the rate limit has reset.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            You generally have no need to invoke this directly. Use</span>
<span class="sd">            `RESTBucketManager.start` and `RESTBucketManager.close` to control</span>
<span class="sd">            this instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa: D401 - Imperative mood</span>
        <span class="c1"># Prevent filling memory increasingly until we run out by removing dead buckets every 20s</span>
        <span class="c1"># Allocations are somewhat cheap if we only do them every so-many seconds, after all.</span>
        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ux</span><span class="o">.</span><span class="n">TRACE</span><span class="p">,</span> <span class="s2">&quot;rate limit garbage collector started&quot;</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">closed_event</span><span class="o">.</span><span class="n">wait</span><span class="p">(),</span> <span class="n">timeout</span><span class="o">=</span><span class="n">poll_period</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">TimeoutError</span><span class="p">:</span>
                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ux</span><span class="o">.</span><span class="n">TRACE</span><span class="p">,</span> <span class="s2">&quot;performing rate limit garbage collection pass&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">do_gc_pass</span><span class="p">(</span><span class="n">expire_after</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">do_gc_pass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expire_after</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Perform a single garbage collection pass.</span>

<span class="sd">        This will assess any routes stored in the internal mappings of this</span>
<span class="sd">        object and remove any that are deemed to be inactive or dead in order</span>
<span class="sd">        to save memory.</span>

<span class="sd">        If the removed routes are used again in the future, they will be</span>
<span class="sd">        re-cached automatically.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expire_after : float</span>
<span class="sd">            Time after which the last `reset_at` was hit for a bucket to\</span>
<span class="sd">            remove it. Defaults to `reset_at` + 20 seconds. Higher values will</span>
<span class="sd">            retain unneeded ratelimit info for longer, but may produce more</span>
<span class="sd">            effective ratelimiting logic as a result.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            You generally have no need to invoke this directly. Use</span>
<span class="sd">            `RESTBucketManager.start` and `RESTBucketManager.close` to control</span>
<span class="sd">            this instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">buckets_to_purge</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>

        <span class="c1"># We have three main states that a bucket can be in:</span>
        <span class="c1"># 1. active - the bucket is active and is not at risk of deallocation</span>
        <span class="c1"># 2. survival - the bucket is inactive but is still fresh enough to be kept alive.</span>
        <span class="c1"># 3. death - the bucket has been inactive for too long.</span>
        <span class="n">active</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Discover and purge</span>
        <span class="n">bucket_pairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">full_hash</span><span class="p">,</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="n">bucket_pairs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bucket</span><span class="o">.</span><span class="n">is_empty</span> <span class="ow">and</span> <span class="n">bucket</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">+</span> <span class="n">expire_after</span> <span class="o">&lt;</span> <span class="n">now</span><span class="p">:</span>
                <span class="c1"># If it is still running a throttle and is in memory, it will remain in memory</span>
                <span class="c1"># but we will not know about it.</span>
                <span class="n">buckets_to_purge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">full_hash</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">bucket</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">&gt;=</span> <span class="n">now</span><span class="p">:</span>
                <span class="n">active</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">dead</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">buckets_to_purge</span><span class="p">)</span>
        <span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bucket_pairs</span><span class="p">)</span>
        <span class="n">survival</span> <span class="o">=</span> <span class="n">total</span> <span class="o">-</span> <span class="n">active</span> <span class="o">-</span> <span class="n">dead</span>

        <span class="k">for</span> <span class="n">full_hash</span> <span class="ow">in</span> <span class="n">buckets_to_purge</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="p">[</span><span class="n">full_hash</span><span class="p">]</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="p">[</span><span class="n">full_hash</span><span class="p">]</span>

        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ux</span><span class="o">.</span><span class="n">TRACE</span><span class="p">,</span> <span class="s2">&quot;purged </span><span class="si">%s</span><span class="s2"> stale buckets, </span><span class="si">%s</span><span class="s2"> remain in survival, </span><span class="si">%s</span><span class="s2"> active&quot;</span><span class="p">,</span> <span class="n">dead</span><span class="p">,</span> <span class="n">survival</span><span class="p">,</span> <span class="n">active</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compiled_route</span><span class="p">:</span> <span class="n">routes</span><span class="o">.</span><span class="n">CompiledRoute</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">AsyncContextManager</span><span class="p">[</span><span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Acquire a bucket for the given route.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compiled_route : hikari.internal.routes.CompiledRoute</span>
<span class="sd">            The route to get the bucket for.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        typing.AsyncContextManager[None]</span>
<span class="sd">            A context manager to enter while doing the request.</span>

<span class="sd">        .. note::</span>
<span class="sd">            You MUST keep the context manager acquired during the whole of the</span>
<span class="sd">            request. From making the request until calling `update_rate_limits`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">compiled_route</span><span class="o">.</span><span class="n">route</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">bucket_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">routes_to_hashes</span><span class="p">[</span><span class="n">template</span><span class="p">]</span>
            <span class="n">real_bucket_hash</span> <span class="o">=</span> <span class="n">compiled_route</span><span class="o">.</span><span class="n">create_real_bucket_hash</span><span class="p">(</span><span class="n">bucket_hash</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">real_bucket_hash</span> <span class="o">=</span> <span class="n">_create_unknown_hash</span><span class="p">(</span><span class="n">compiled_route</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">bucket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="p">[</span><span class="n">real_bucket_hash</span><span class="p">]</span>
            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is being mapped to existing bucket </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">compiled_route</span><span class="p">,</span> <span class="n">real_bucket_hash</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is being mapped to new bucket </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">compiled_route</span><span class="p">,</span> <span class="n">real_bucket_hash</span><span class="p">)</span>
            <span class="n">bucket</span> <span class="o">=</span> <span class="n">RESTBucket</span><span class="p">(</span><span class="n">real_bucket_hash</span><span class="p">,</span> <span class="n">compiled_route</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_rate_limit</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="p">[</span><span class="n">real_bucket_hash</span><span class="p">]</span> <span class="o">=</span> <span class="n">bucket</span>

        <span class="k">return</span> <span class="n">bucket</span>

    <span class="k">def</span> <span class="nf">update_rate_limits</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">compiled_route</span><span class="p">:</span> <span class="n">routes</span><span class="o">.</span><span class="n">CompiledRoute</span><span class="p">,</span>
        <span class="n">bucket_header</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">remaining_header</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">limit_header</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">reset_after</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Update the rate limits for a bucket using info from a response.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compiled_route : hikari.internal.routes.CompiledRoute</span>
<span class="sd">            The compiled route to get the bucket for.</span>
<span class="sd">        bucket_header : typing.Optional[str]</span>
<span class="sd">            The `X-RateLimit-Bucket` header that was provided in the response.</span>
<span class="sd">        remaining_header : int</span>
<span class="sd">            The `X-RateLimit-Remaining` header cast to an `int`.</span>
<span class="sd">        limit_header : int</span>
<span class="sd">            The `X-RateLimit-Limit` header cast to an `int`.</span>
<span class="sd">        reset_after : float</span>
<span class="sd">            The `X-RateLimit-Reset-After` header cast to a `float`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">routes_to_hashes</span><span class="p">[</span><span class="n">compiled_route</span><span class="o">.</span><span class="n">route</span><span class="p">]</span> <span class="o">=</span> <span class="n">bucket_header</span>
        <span class="n">real_bucket_hash</span> <span class="o">=</span> <span class="n">compiled_route</span><span class="o">.</span><span class="n">create_real_bucket_hash</span><span class="p">(</span><span class="n">bucket_header</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bucket</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">real_bucket_hash</span><span class="p">):</span>
            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;updating </span><span class="si">%s</span><span class="s2"> with bucket </span><span class="si">%s</span><span class="s2"> [reset-after:</span><span class="si">%s</span><span class="s2">s, limit:</span><span class="si">%s</span><span class="s2">, remaining:</span><span class="si">%s</span><span class="s2">]&quot;</span><span class="p">,</span>
                <span class="n">compiled_route</span><span class="p">,</span>
                <span class="n">real_bucket_hash</span><span class="p">,</span>
                <span class="n">reset_after</span><span class="p">,</span>
                <span class="n">limit_header</span><span class="p">,</span>
                <span class="n">remaining_header</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unknown_bucket_hash</span> <span class="o">=</span> <span class="n">_create_unknown_hash</span><span class="p">(</span><span class="n">compiled_route</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">bucket</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">unknown_bucket_hash</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">bucket</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">real_bucket_hash</span><span class="p">)</span>
                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;remapping </span><span class="si">%s</span><span class="s2"> with existing bucket </span><span class="si">%s</span><span class="s2"> [reset-after:</span><span class="si">%s</span><span class="s2">s, limit:</span><span class="si">%s</span><span class="s2">, remaining:</span><span class="si">%s</span><span class="s2">]&quot;</span><span class="p">,</span>
                    <span class="n">compiled_route</span><span class="p">,</span>
                    <span class="n">unknown_bucket_hash</span><span class="p">,</span>
                    <span class="n">reset_after</span><span class="p">,</span>
                    <span class="n">limit_header</span><span class="p">,</span>
                    <span class="n">remaining_header</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;remapping </span><span class="si">%s</span><span class="s2"> with new bucket </span><span class="si">%s</span><span class="s2"> [reset-after:</span><span class="si">%s</span><span class="s2">s, limit:</span><span class="si">%s</span><span class="s2">, remaining:</span><span class="si">%s</span><span class="s2">]&quot;</span><span class="p">,</span>
                    <span class="n">compiled_route</span><span class="p">,</span>
                    <span class="n">real_bucket_hash</span><span class="p">,</span>
                    <span class="n">reset_after</span><span class="p">,</span>
                    <span class="n">limit_header</span><span class="p">,</span>
                    <span class="n">remaining_header</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">bucket</span> <span class="o">=</span> <span class="n">RESTBucket</span><span class="p">(</span><span class="n">real_bucket_hash</span><span class="p">,</span> <span class="n">compiled_route</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_rate_limit</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="p">[</span><span class="n">real_bucket_hash</span><span class="p">]</span> <span class="o">=</span> <span class="n">bucket</span>

        <span class="n">reset_at_monotonic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">+</span> <span class="n">reset_after</span>
        <span class="n">bucket</span><span class="o">.</span><span class="n">update_rate_limit</span><span class="p">(</span><span class="n">remaining_header</span><span class="p">,</span> <span class="n">limit_header</span><span class="p">,</span> <span class="n">reset_at_monotonic</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_started</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return `True` if the rate limiter GC task is started.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
</pre></div>

        </details>

            <div class="docstring"><p>The main rate limiter implementation for HTTP clients.</p>

<p>This is designed to provide bucketed rate limiting for Discord HTTP
endpoints that respects the <code>X-RateLimit-Bucket</code> rate limit header. To do
this, it makes the assumption that any limit can change at any time.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>max_rate_limit</strong> (float):
The max number of seconds to backoff for when rate limited. Anything
greater than this will instead raise an error.</li>
</ul>
</div>


                        <div id="RESTBucketManager.__init__" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#RESTBucketManager.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">RESTBucketManager</span><span class="signature">(max_rate_limit: float)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_rate_limit</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">routes_to_hashes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">closed_event</span><span class="p">:</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Task</span><span class="p">[</span><span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_rate_limit</span> <span class="o">=</span> <span class="n">max_rate_limit</span>
</pre></div>

        </details>

    

                        </div>
                        <div id="RESTBucketManager.routes_to_hashes" class="classattr">
                                
            <div class="attr variable"><a class="headerlink" href="#RESTBucketManager.routes_to_hashes">#&nbsp;&nbsp</a>

        <span class="name">routes_to_hashes</span><span class="annotation">: Final[MutableMapping[<a href="../internal/routes.html#Route">hikari.internal.routes.Route</a>, str]]</span>
    </div>

            <div class="docstring"><p>Maps routes to their <code>X-RateLimit-Bucket</code> header being used.</p>
</div>


                        </div>
                        <div id="RESTBucketManager.real_hashes_to_buckets" class="classattr">
                                
            <div class="attr variable"><a class="headerlink" href="#RESTBucketManager.real_hashes_to_buckets">#&nbsp;&nbsp</a>

        <span class="name">real_hashes_to_buckets</span><span class="annotation">: Final[MutableMapping[str, <a href="#RESTBucket">hikari.impl.buckets.RESTBucket</a>]]</span>
    </div>

            <div class="docstring"><p>Maps full bucket hashes (<code>X-RateLimit-Bucket</code> appended with a hash of
major parameters used in that compiled route) to their corresponding rate
limiters.</p>
</div>


                        </div>
                        <div id="RESTBucketManager.closed_event" class="classattr">
                                
            <div class="attr variable"><a class="headerlink" href="#RESTBucketManager.closed_event">#&nbsp;&nbsp</a>

        <span class="name">closed_event</span><span class="annotation">: Final[asyncio.locks.Event]</span>
    </div>

            <div class="docstring"><p>An internal event that is set when the object is shut down.</p>
</div>


                        </div>
                        <div id="RESTBucketManager.gc_task" class="classattr">
                                
            <div class="attr variable"><a class="headerlink" href="#RESTBucketManager.gc_task">#&nbsp;&nbsp</a>

        <span class="name">gc_task</span><span class="annotation">: &#39;typing.Optional[asyncio.Task[None]]&#39;</span>
    </div>

            <div class="docstring"><p>The internal garbage collector task.</p>
</div>


                        </div>
                        <div id="RESTBucketManager.max_rate_limit" class="classattr">
                                
            <div class="attr variable"><a class="headerlink" href="#RESTBucketManager.max_rate_limit">#&nbsp;&nbsp</a>

        <span class="name">max_rate_limit</span><span class="annotation">: float</span>
    </div>

            <div class="docstring"><p>The max number of seconds to backoff for when rate limited.</p>

<p>Anything greater than this will instead raise an error.</p>
</div>


                        </div>
                        <div id="RESTBucketManager.start" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#RESTBucketManager.start">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">start</span><span class="signature">(self, poll_period: float = 20.0, expire_after: float = 10.0) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poll_period</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">20.0</span><span class="p">,</span> <span class="n">expire_after</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Start this ratelimiter up.</span>

<span class="sd">        This spins up internal garbage collection logic in the background to</span>
<span class="sd">        keep memory usage to an optimal level as old routes and bucket hashes</span>
<span class="sd">        get discarded and replaced.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        poll_period : float</span>
<span class="sd">            Period to poll the garbage collector at in seconds. Defaults</span>
<span class="sd">            to `20` seconds.</span>
<span class="sd">        expire_after : float</span>
<span class="sd">            Time after which the last `reset_at` was hit for a bucket to</span>
<span class="sd">            remove it. Higher values will retain unneeded ratelimit info for</span>
<span class="sd">            longer, but may produce more effective rate-limiting logic as a</span>
<span class="sd">            result. Using `0` will make the bucket get garbage collected as soon</span>
<span class="sd">            as the rate limit has reset. Defaults to `10` seconds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gc</span><span class="p">(</span><span class="n">poll_period</span><span class="p">,</span> <span class="n">expire_after</span><span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>Start this ratelimiter up.</p>

<p>This spins up internal garbage collection logic in the background to
keep memory usage to an optimal level as old routes and bucket hashes
get discarded and replaced.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>poll_period</strong> (float):
Period to poll the garbage collector at in seconds. Defaults
to <code>20</code> seconds.</li>
<li><strong>expire_after</strong> (float):
Time after which the last <code>reset_at</code> was hit for a bucket to
remove it. Higher values will retain unneeded ratelimit info for
longer, but may produce more effective rate-limiting logic as a
result. Using <code>0</code> will make the bucket get garbage collected as soon
as the rate limit has reset. Defaults to <code>10</code> seconds.</li>
</ul>
</div>


                        </div>
                        <div id="RESTBucketManager.close" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#RESTBucketManager.close">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">close</span><span class="signature">(self) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Close the garbage collector and kill any tasks waiting on ratelimits.</span>

<span class="sd">        Once this has been called, this object is considered to be effectively</span>
<span class="sd">        dead. To reuse it, one should create a new instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">closed_event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">bucket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">routes_to_hashes</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>

        </details>

            <div class="docstring"><p>Close the garbage collector and kill any tasks waiting on ratelimits.</p>

<p>Once this has been called, this object is considered to be effectively
dead. To reuse it, one should create a new instance.</p>
</div>


                        </div>
                        <div id="RESTBucketManager.gc" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#RESTBucketManager.gc">#&nbsp;&nbsp</a>

        
            <span class="def">async def</span>
            <span class="name">gc</span><span class="signature">(self, poll_period: float, expire_after: float) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">async</span> <span class="k">def</span> <span class="nf">gc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poll_period</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">expire_after</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;The garbage collector loop.</span>

<span class="sd">        This is designed to run in the background and manage removing unused</span>
<span class="sd">        route references from the rate-limiter collection to save memory.</span>

<span class="sd">        This will run forever until `RESTBucketManager.closed_event` is set.</span>
<span class="sd">        This will invoke `RESTBucketManager.do_gc_pass` periodically.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        poll_period : float</span>
<span class="sd">            The period to poll at.</span>
<span class="sd">        expire_after : float</span>
<span class="sd">            Time after which the last `reset_at` was hit for a bucket to</span>
<span class="sd">            remove it. Higher values will retain unneeded ratelimit info for</span>
<span class="sd">            longer, but may produce more effective ratelimiting logic as a</span>
<span class="sd">            result. Using `0` will make the bucket get garbage collected as soon</span>
<span class="sd">            as the rate limit has reset.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            You generally have no need to invoke this directly. Use</span>
<span class="sd">            `RESTBucketManager.start` and `RESTBucketManager.close` to control</span>
<span class="sd">            this instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa: D401 - Imperative mood</span>
        <span class="c1"># Prevent filling memory increasingly until we run out by removing dead buckets every 20s</span>
        <span class="c1"># Allocations are somewhat cheap if we only do them every so-many seconds, after all.</span>
        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ux</span><span class="o">.</span><span class="n">TRACE</span><span class="p">,</span> <span class="s2">&quot;rate limit garbage collector started&quot;</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed_event</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">closed_event</span><span class="o">.</span><span class="n">wait</span><span class="p">(),</span> <span class="n">timeout</span><span class="o">=</span><span class="n">poll_period</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">TimeoutError</span><span class="p">:</span>
                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ux</span><span class="o">.</span><span class="n">TRACE</span><span class="p">,</span> <span class="s2">&quot;performing rate limit garbage collection pass&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">do_gc_pass</span><span class="p">(</span><span class="n">expire_after</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gc_task</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>

        </details>

            <div class="docstring"><p>The garbage collector loop.</p>

<p>This is designed to run in the background and manage removing unused
route references from the rate-limiter collection to save memory.</p>

<p>This will run forever until <code><a href="#RESTBucketManager.closed_event">RESTBucketManager.closed_event</a></code> is set.
This will invoke <code><a href="#RESTBucketManager.do_gc_pass">RESTBucketManager.do_gc_pass</a></code> periodically.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>poll_period</strong> (float):
The period to poll at.</li>
<li><strong>expire_after</strong> (float):
Time after which the last <code>reset_at</code> was hit for a bucket to
remove it. Higher values will retain unneeded ratelimit info for
longer, but may produce more effective ratelimiting logic as a
result. Using <code>0</code> will make the bucket get garbage collected as soon
as the rate limit has reset.</li>
<li><p><strong><em>Warning</strong> (</em>):</p></li>
<li><p><strong>You generally have no need to invoke this directly. Use</strong></p></li>
<li><strong><code><a href="#RESTBucketManager.start">RESTBucketManager.start</a></code> and <code><a href="#RESTBucketManager.close">RESTBucketManager.close</a></code> to control</strong></li>
<li><strong>this instead.</strong></li>
</ul>
</div>


                        </div>
                        <div id="RESTBucketManager.do_gc_pass" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#RESTBucketManager.do_gc_pass">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">do_gc_pass</span><span class="signature">(self, expire_after: float) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">do_gc_pass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expire_after</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Perform a single garbage collection pass.</span>

<span class="sd">        This will assess any routes stored in the internal mappings of this</span>
<span class="sd">        object and remove any that are deemed to be inactive or dead in order</span>
<span class="sd">        to save memory.</span>

<span class="sd">        If the removed routes are used again in the future, they will be</span>
<span class="sd">        re-cached automatically.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expire_after : float</span>
<span class="sd">            Time after which the last `reset_at` was hit for a bucket to\</span>
<span class="sd">            remove it. Defaults to `reset_at` + 20 seconds. Higher values will</span>
<span class="sd">            retain unneeded ratelimit info for longer, but may produce more</span>
<span class="sd">            effective ratelimiting logic as a result.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            You generally have no need to invoke this directly. Use</span>
<span class="sd">            `RESTBucketManager.start` and `RESTBucketManager.close` to control</span>
<span class="sd">            this instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">buckets_to_purge</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>

        <span class="c1"># We have three main states that a bucket can be in:</span>
        <span class="c1"># 1. active - the bucket is active and is not at risk of deallocation</span>
        <span class="c1"># 2. survival - the bucket is inactive but is still fresh enough to be kept alive.</span>
        <span class="c1"># 3. death - the bucket has been inactive for too long.</span>
        <span class="n">active</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Discover and purge</span>
        <span class="n">bucket_pairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">full_hash</span><span class="p">,</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="n">bucket_pairs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bucket</span><span class="o">.</span><span class="n">is_empty</span> <span class="ow">and</span> <span class="n">bucket</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">+</span> <span class="n">expire_after</span> <span class="o">&lt;</span> <span class="n">now</span><span class="p">:</span>
                <span class="c1"># If it is still running a throttle and is in memory, it will remain in memory</span>
                <span class="c1"># but we will not know about it.</span>
                <span class="n">buckets_to_purge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">full_hash</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">bucket</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">&gt;=</span> <span class="n">now</span><span class="p">:</span>
                <span class="n">active</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">dead</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">buckets_to_purge</span><span class="p">)</span>
        <span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bucket_pairs</span><span class="p">)</span>
        <span class="n">survival</span> <span class="o">=</span> <span class="n">total</span> <span class="o">-</span> <span class="n">active</span> <span class="o">-</span> <span class="n">dead</span>

        <span class="k">for</span> <span class="n">full_hash</span> <span class="ow">in</span> <span class="n">buckets_to_purge</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="p">[</span><span class="n">full_hash</span><span class="p">]</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="p">[</span><span class="n">full_hash</span><span class="p">]</span>

        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ux</span><span class="o">.</span><span class="n">TRACE</span><span class="p">,</span> <span class="s2">&quot;purged </span><span class="si">%s</span><span class="s2"> stale buckets, </span><span class="si">%s</span><span class="s2"> remain in survival, </span><span class="si">%s</span><span class="s2"> active&quot;</span><span class="p">,</span> <span class="n">dead</span><span class="p">,</span> <span class="n">survival</span><span class="p">,</span> <span class="n">active</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Perform a single garbage collection pass.</p>

<p>This will assess any routes stored in the internal mappings of this
object and remove any that are deemed to be inactive or dead in order
to save memory.</p>

<p>If the removed routes are used again in the future, they will be
re-cached automatically.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>expire_after</strong> (float):
Time after which the last <code>reset_at</code> was hit for a bucket to            remove it. Defaults to <code>reset_at</code> + 20 seconds. Higher values will
retain unneeded ratelimit info for longer, but may produce more
effective ratelimiting logic as a result.</li>
<li><p><strong><em>Warning</strong> (</em>):</p></li>
<li><p><strong>You generally have no need to invoke this directly. Use</strong></p></li>
<li><strong><code><a href="#RESTBucketManager.start">RESTBucketManager.start</a></code> and <code><a href="#RESTBucketManager.close">RESTBucketManager.close</a></code> to control</strong></li>
<li><strong>this instead.</strong></li>
</ul>
</div>


                        </div>
                        <div id="RESTBucketManager.acquire" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#RESTBucketManager.acquire">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">acquire</span><span class="signature">(
    self,
    compiled_route: <a href="../internal/routes.html#CompiledRoute">hikari.internal.routes.CompiledRoute</a>
) -&gt; AbstractAsyncContextManager[NoneType]</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compiled_route</span><span class="p">:</span> <span class="n">routes</span><span class="o">.</span><span class="n">CompiledRoute</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">AsyncContextManager</span><span class="p">[</span><span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Acquire a bucket for the given route.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compiled_route : hikari.internal.routes.CompiledRoute</span>
<span class="sd">            The route to get the bucket for.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        typing.AsyncContextManager[None]</span>
<span class="sd">            A context manager to enter while doing the request.</span>

<span class="sd">        .. note::</span>
<span class="sd">            You MUST keep the context manager acquired during the whole of the</span>
<span class="sd">            request. From making the request until calling `update_rate_limits`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">compiled_route</span><span class="o">.</span><span class="n">route</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">bucket_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">routes_to_hashes</span><span class="p">[</span><span class="n">template</span><span class="p">]</span>
            <span class="n">real_bucket_hash</span> <span class="o">=</span> <span class="n">compiled_route</span><span class="o">.</span><span class="n">create_real_bucket_hash</span><span class="p">(</span><span class="n">bucket_hash</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">real_bucket_hash</span> <span class="o">=</span> <span class="n">_create_unknown_hash</span><span class="p">(</span><span class="n">compiled_route</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">bucket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="p">[</span><span class="n">real_bucket_hash</span><span class="p">]</span>
            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is being mapped to existing bucket </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">compiled_route</span><span class="p">,</span> <span class="n">real_bucket_hash</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is being mapped to new bucket </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">compiled_route</span><span class="p">,</span> <span class="n">real_bucket_hash</span><span class="p">)</span>
            <span class="n">bucket</span> <span class="o">=</span> <span class="n">RESTBucket</span><span class="p">(</span><span class="n">real_bucket_hash</span><span class="p">,</span> <span class="n">compiled_route</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_rate_limit</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="p">[</span><span class="n">real_bucket_hash</span><span class="p">]</span> <span class="o">=</span> <span class="n">bucket</span>

        <span class="k">return</span> <span class="n">bucket</span>
</pre></div>

        </details>

            <div class="docstring"><p>Acquire a bucket for the given route.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>compiled_route</strong> (<a href="../internal/routes.html#CompiledRoute">hikari.internal.routes.CompiledRoute</a>):
The route to get the bucket for.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>typing.AsyncContextManager[None]</strong>: A context manager to enter while doing the request.</li>
<li><p><strong><em>Note</strong> (</em>):</p></li>
<li><p><strong>You MUST keep the context manager acquired during the whole of the</strong></p></li>
<li><strong>request. From making the request until calling <code><a href="#RESTBucketManager.update_rate_limits">update_rate_limits</a></code>.</strong></li>
</ul>
</div>


                        </div>
                        <div id="RESTBucketManager.update_rate_limits" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#RESTBucketManager.update_rate_limits">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">update_rate_limits</span><span class="signature">(
    self,
    compiled_route: <a href="../internal/routes.html#CompiledRoute">hikari.internal.routes.CompiledRoute</a>,
    bucket_header: str,
    remaining_header: int,
    limit_header: int,
    reset_after: float
) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">update_rate_limits</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">compiled_route</span><span class="p">:</span> <span class="n">routes</span><span class="o">.</span><span class="n">CompiledRoute</span><span class="p">,</span>
        <span class="n">bucket_header</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">remaining_header</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">limit_header</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">reset_after</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Update the rate limits for a bucket using info from a response.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compiled_route : hikari.internal.routes.CompiledRoute</span>
<span class="sd">            The compiled route to get the bucket for.</span>
<span class="sd">        bucket_header : typing.Optional[str]</span>
<span class="sd">            The `X-RateLimit-Bucket` header that was provided in the response.</span>
<span class="sd">        remaining_header : int</span>
<span class="sd">            The `X-RateLimit-Remaining` header cast to an `int`.</span>
<span class="sd">        limit_header : int</span>
<span class="sd">            The `X-RateLimit-Limit` header cast to an `int`.</span>
<span class="sd">        reset_after : float</span>
<span class="sd">            The `X-RateLimit-Reset-After` header cast to a `float`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">routes_to_hashes</span><span class="p">[</span><span class="n">compiled_route</span><span class="o">.</span><span class="n">route</span><span class="p">]</span> <span class="o">=</span> <span class="n">bucket_header</span>
        <span class="n">real_bucket_hash</span> <span class="o">=</span> <span class="n">compiled_route</span><span class="o">.</span><span class="n">create_real_bucket_hash</span><span class="p">(</span><span class="n">bucket_header</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bucket</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">real_bucket_hash</span><span class="p">):</span>
            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;updating </span><span class="si">%s</span><span class="s2"> with bucket </span><span class="si">%s</span><span class="s2"> [reset-after:</span><span class="si">%s</span><span class="s2">s, limit:</span><span class="si">%s</span><span class="s2">, remaining:</span><span class="si">%s</span><span class="s2">]&quot;</span><span class="p">,</span>
                <span class="n">compiled_route</span><span class="p">,</span>
                <span class="n">real_bucket_hash</span><span class="p">,</span>
                <span class="n">reset_after</span><span class="p">,</span>
                <span class="n">limit_header</span><span class="p">,</span>
                <span class="n">remaining_header</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unknown_bucket_hash</span> <span class="o">=</span> <span class="n">_create_unknown_hash</span><span class="p">(</span><span class="n">compiled_route</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">bucket</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">unknown_bucket_hash</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">bucket</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">real_bucket_hash</span><span class="p">)</span>
                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;remapping </span><span class="si">%s</span><span class="s2"> with existing bucket </span><span class="si">%s</span><span class="s2"> [reset-after:</span><span class="si">%s</span><span class="s2">s, limit:</span><span class="si">%s</span><span class="s2">, remaining:</span><span class="si">%s</span><span class="s2">]&quot;</span><span class="p">,</span>
                    <span class="n">compiled_route</span><span class="p">,</span>
                    <span class="n">unknown_bucket_hash</span><span class="p">,</span>
                    <span class="n">reset_after</span><span class="p">,</span>
                    <span class="n">limit_header</span><span class="p">,</span>
                    <span class="n">remaining_header</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;remapping </span><span class="si">%s</span><span class="s2"> with new bucket </span><span class="si">%s</span><span class="s2"> [reset-after:</span><span class="si">%s</span><span class="s2">s, limit:</span><span class="si">%s</span><span class="s2">, remaining:</span><span class="si">%s</span><span class="s2">]&quot;</span><span class="p">,</span>
                    <span class="n">compiled_route</span><span class="p">,</span>
                    <span class="n">real_bucket_hash</span><span class="p">,</span>
                    <span class="n">reset_after</span><span class="p">,</span>
                    <span class="n">limit_header</span><span class="p">,</span>
                    <span class="n">remaining_header</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">bucket</span> <span class="o">=</span> <span class="n">RESTBucket</span><span class="p">(</span><span class="n">real_bucket_hash</span><span class="p">,</span> <span class="n">compiled_route</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_rate_limit</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">real_hashes_to_buckets</span><span class="p">[</span><span class="n">real_bucket_hash</span><span class="p">]</span> <span class="o">=</span> <span class="n">bucket</span>

        <span class="n">reset_at_monotonic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">+</span> <span class="n">reset_after</span>
        <span class="n">bucket</span><span class="o">.</span><span class="n">update_rate_limit</span><span class="p">(</span><span class="n">remaining_header</span><span class="p">,</span> <span class="n">limit_header</span><span class="p">,</span> <span class="n">reset_at_monotonic</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Update the rate limits for a bucket using info from a response.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>compiled_route</strong> (<a href="../internal/routes.html#CompiledRoute">hikari.internal.routes.CompiledRoute</a>):
The compiled route to get the bucket for.</li>
<li><strong>bucket_header</strong> (typing.Optional[str]):
The <code>X-RateLimit-Bucket</code> header that was provided in the response.</li>
<li><strong>remaining_header</strong> (int):
The <code>X-RateLimit-Remaining</code> header cast to an <code>int</code>.</li>
<li><strong>limit_header</strong> (int):
The <code>X-RateLimit-Limit</code> header cast to an <code>int</code>.</li>
<li><strong>reset_after</strong> (float):
The <code>X-RateLimit-Reset-After</code> header cast to a <code>float</code>.</li>
</ul>
</div>


                        </div>
                        <div id="RESTBucketManager.is_started" class="classattr">
                                
            <div class="attr variable"><a class="headerlink" href="#RESTBucketManager.is_started">#&nbsp;&nbsp</a>

        <span class="name">is_started</span><span class="annotation">: bool</span>
    </div>

            <div class="docstring"><p>Return <code>True</code> if the rate limiter GC task is started.</p>
</div>


                        </div>
            </section>
    </main>
    <script src="../../../version_switcher.js"></script>
    <script>
        "use strict";
        const html = document.querySelector("html");
        const sidebarToggle = document.getElementById("sidebar-toggle");

        // Button control
        sidebarToggle.addEventListener('click', function () {
            if (html.classList.contains("sidebar-hidden")) {
                html.classList.remove("sidebar-hidden");
            } else {
                html.classList.add("sidebar-hidden");
            }
        });

        // Swipe controls
        let firstContact = null;

        document.addEventListener('touchstart', function (e) {
            firstContact = {
                x: e.touches[0].clientX,
                time: Date.now()
            };
        }, { passive: true });

        document.addEventListener('touchmove', function (e) {
            if (!firstContact)
                return;
            let curX = e.touches[0].clientX;
            let xDiff = curX - firstContact.x;
            let tDiff = Date.now() - firstContact.time;
            if (tDiff < 300 && Math.abs(xDiff) >= 100) {
                if (xDiff >= 0 && firstContact.x < Math.min(document.body.clientWidth * 0.25, 300)) {
                    html.classList.remove("sidebar-hidden");
                    firstContact = null;
                }
                else if (xDiff < 0 && curX < 150) {
                    html.classList.add("sidebar-hidden");
                    firstContact = null;
                }
            }
        }, { passive: true });
    </script>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "../../search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `../../${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.type) {
                    case "function":
                        heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">(${doc.parameters.join(", ")})</span>`;
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>