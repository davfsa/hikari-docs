<!doctype html>
<html lang="en" class="sidebar-hidden">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 8.0.1" />
    <title>hikari.impl.rate_limits API documentation | v2.0.0.dev104</title>
    <link rel="icon" href="https://www.hikari-py.dev/logo.png"/>

    
<style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>

<style>:root{--pdoc-background:#212529;}.pdoc{--text:#f7f7f7;--muted:#9d9d9d;--link:#d264d0;--link-hover:#3989ff;--code:#333;--active:#555;--accent:#343434;--accent2:#555;--nav-hover:rgba(0, 0, 0, 0.1);--def:#ff79c6;--name:#61aeee;--annotation:#F471E6;font-family:SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;word-break:break-word;}@media (max-width:1079px){:root{--sidebar-width:30rem;}html{font-size:3vw;}main, header{padding:2rem 3vw 0 1.5rem;}html:not(.sidebar-hidden) body{overflow:hidden !important;}.sidebar-hidden nav.pdoc{transform:translateX(calc(0px - var(--sidebar-width)));}nav.pdoc{transition:transform 0.2s;}.pdoc .sidebar-toggle{position:fixed;top:0;bottom:calc(100% - 6rem);left:var(--sidebar-width);border-left:5px solid grey;border-top:5px solid rgba(0, 0, 0, 0);border-bottom:5px solid rgba(0, 0, 0, 0);}}@media (min-width:1080px){:root{--sidebar-width:clamp(12.5rem, 28vw, 26rem);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);}}nav.pdoc{position:fixed;left:0;top:0;bottom:0;height:100vh;width:var(--sidebar-width);z-index:1;}.pdoc .sidebar{height:100vh;overflow:auto;padding:1rem 1rem;background-color:var(--accent);border-right:1px solid var(--accent2);scrollbar-color:var(--accent2) transparent }.pdoc .sidebar::-webkit-scrollbar-thumb{background-color:var(--accent2); }.pdoc .sidebar input[type=search]{display:block;outline-offset:0;width:102%;}.pdoc .sidebar ul{list-style:none;padding-left:1rem;}.pdoc .sidebar li{display:block;margin:0;padding:.2rem 0 .2rem .5rem;transition:all 100ms;}.pdoc .sidebar > ul > li{padding-left:0;}.pdoc .sidebar li:hover{background-color:var(--nav-hover);}.pdoc .sidebar a:hover{color:var(--text);}.pdoc .sidebar a{display:block;}.pdoc .sidebar a.function, .pdoc .sidebar a.variable{color:#bd93f9;}.pdoc .sidebar > h2:first-of-type{margin-top:1rem;}.pdoc .sidebar .class:before{content:"class ";color:var(--muted);}.pdoc .sidebar .function:after{content:"()";color:var(--muted);}.pdoc .sidebar .sidebar-buttons{display:flex;width:100%;margin-bottom:.5rem;align-items:end;}.pdoc .sidebar .sidebar-buttons .push{margin-left:auto;}.pdoc .svg-button > svg{width:1.5rem;margin:0 .2rem 0 .2rem;cursor:pointer;}.pdoc .version-selector{background-color:var(--accent);color:var(--text);border:hidden;}.pdoc .version-selector:disabled{-webkit-appearance:none;}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc p{font-weight:300;margin-top:0;margin-bottom:.5rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{color:#de4f91;font-weight:bold;margin:0.3em 0;padding:0.2em 0;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .modulename a:hover{filter:brightness(80%);}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{--shift:-2.4rem;text-align:right;margin-top:var(--shift);margin-bottom:calc(0px - var(--shift));clear:both;filter:opacity(1);}.pdoc details:not([open]){height:0;overflow:visible;}.pdoc details > summary{font-size:.75rem;cursor:pointer;color:var(--muted);border-width:0;padding:0 .7em;display:inline-block;display:inline list-item;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc details > div{margin-top:calc(0px - var(--shift) / 2);text-align:left;}.pdoc .docstring{margin:0 0 2rem 2rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc .docstring li{margin-bottom:15px;}.pdoc .docstring li:last-child{margin-bottom:0;}.pdoc span.name{color:#61aeee;}.pdoc span.base{color:#8be9fd;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc li strong{color:#DB61D9;}b, strong{font-weight:bold;}.pdoc em{color:orange;}.pdoc h6{padding-top:1rem;font-size:2rem;color:white;}.pdoc h6#notes{color:orange;}.pdoc h6#raises{color:#ff6666;}.pdoc div.decorator{color:#61aeee;}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .inherited dt,.pdoc .inherited dt::before{color:#61aeee;}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:1rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:3rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited div{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;color:white;}.pdoc .c{color:#6a7aaa;}.pdoc .err{color:#ff5555;background-color:#1e0010;}.pdoc .k{color:#ff79c6;}.pdoc .l{color:#ae81ff;}.pdoc .n{color:#f8f8f2;}.pdoc .o{color:#ff79c6;}.pdoc .p{color:#f8f8f2;}.pdoc .ch{color:#6a7aaa;}.pdoc .cm{color:#6a7aaa;}.pdoc .cp{color:#6a7aaa;}.pdoc .cpf{color:#6a7aaa;}.pdoc .c1{color:#6a7aaa;}.pdoc .cs{color:#6a7aaa;}.pdoc .gd{color:#6a7aaa;}.pdoc .ge{font-style:italic;}.pdoc .gi{color:#a6e22e;}.pdoc .go{color:#ff79c6;}.pdoc .gp{color:#f92672;font-weight:bold;}.pdoc .gs{font-weight:bold;}.pdoc .gu{color:#75715e;}.pdoc .kc{color:#ff79c6;}.pdoc .kd{color:#bd93f9;}.pdoc .kn{color:#ff79c6;}.pdoc .kp{color:#bd93f9;}.pdoc .kr{color:#ff79c6;}.pdoc .kt{color:#ff79c6;}.pdoc .ld{color:#e6db74;}.pdoc .m{color:#ae81ff;}.pdoc .s{color:#e6db74;}.pdoc .na{color:#a6e22e;}.pdoc .nb{color:#8be9fd;}.pdoc .nc{color:#e6c07b;}.pdoc .no{color:#ff79c6;}.pdoc .ni{color:#ff79c6;}.pdoc .ne{color:#8be9fd;}.pdoc .nf{color:#61aeee;}.pdoc .nl{color:#f8f8f2;}.pdoc .nn{color:#f8f8f2;}.pdoc .nx{color:#a6e22e;}.pdoc .py{color:#f8f8f2;}.pdoc .nt{color:#f92672;}.pdoc .nv{color:#f8f8f2;}.pdoc .ow{color:#ff79c6;}.pdoc .w{color:#f8f8f2;}.pdoc .mb{color:#ae81ff;}.pdoc .mf{color:#ae81ff;}.pdoc .mh{color:#ae81ff;}.pdoc .mi{color:#ae81ff;}.pdoc .mo{color:#ae81ff;}.pdoc .sa{color:#ff79c6;}.pdoc .sb{color:#e6db74;}.pdoc .sc{color:#e6db74;}.pdoc .dl{color:#e6db74;}.pdoc .sd{color:#6272a4;}.pdoc .s2{color:#e6db74;}.pdoc .se{color:#ae81ff;}.pdoc .sh{color:#e6db74;}.pdoc .si{color:#bd93f9;}.pdoc .sx{color:#e6db74;}.pdoc .sr{color:#e6db74;}.pdoc .s1{color:#e6db74;}.pdoc .ss{color:#e6db74;}.pdoc .bp{color:#bd93f9;}.pdoc .fm{color:#bd93f9;}.pdoc .vc{color:#bd93f9;}.pdoc .vg{color:#f8f8f2;}.pdoc .vi{color:#ffffff;}.pdoc .vm{color:#bd93f9;}.pdoc .il{color:#ae81ff;}.pdoc .nd{color:#61aeee;}.pdoc .kc{color:#bd93f9;}</style>
</head>
<body>    <nav class="pdoc">
        <div id="sidebar" class="sidebar">
            <div class="sidebar-buttons">
                <label>
                    Hikari <select class="version-selector" id="version-selector" disabled><option>2.0.0.dev104</option></select>
                </label>
                <div class="push"></div>
                <a href="../../index.html" class="svg-button"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 576 512" >
    <path d="M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z" fill="#ffffff"/>
</svg></a>
                <a href="https://discord.gg/Jx4cNGG" class="svg-button"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 71 55">
    <path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z" fill="#ffffff"/>
</svg></a>
                <a href="https://pypi.org/project/hikari" class="svg-button"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 512 512">
    <path d="M488.6 250.2L392 214V105.5c0-15-9.3-28.4-23.4-33.7l-100-37.5c-8.1-3.1-17.1-3.1-25.3 0l-100 37.5c-14.1 5.3-23.4 18.7-23.4 33.7V214l-96.6 36.2C9.3 255.5 0 268.9 0 283.9V394c0 13.6 7.7 26.1 19.9 32.2l100 50c10.1 5.1 22.1 5.1 32.2 0l103.9-52 103.9 52c10.1 5.1 22.1 5.1 32.2 0l100-50c12.2-6.1 19.9-18.6 19.9-32.2V283.9c0-15-9.3-28.4-23.4-33.7zM358 214.8l-85 31.9v-68.2l85-37v73.3zM154 104.1l102-38.2 102 38.2v.6l-102 41.4-102-41.4v-.6zm84 291.1l-85 42.5v-79.1l85-38.8v75.4zm0-112l-102 41.4-102-41.4v-.6l102-38.2 102 38.2v.6zm240 112l-85 42.5v-79.1l85-38.8v75.4zm0-112l-102 41.4-102-41.4v-.6l102-38.2 102 38.2v.6z" fill="#ffffff"/>
</svg></a>
            </div>

                <input type="search" placeholder="Search..." role="searchbox" title="Search the documentation" pattern=".+">



                <h2>API Documentation</h2>
                    <ul class="memberlist">
            <li>
                    <a class="class" href="#BaseRateLimiter">BaseRateLimiter</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#BaseRateLimiter.acquire">acquire</a>
                        </li>
                        <li>
                                <a class="function" href="#BaseRateLimiter.close">close</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#BurstRateLimiter">BurstRateLimiter</a>
                            <ul class="memberlist">
                        <li>
                                <a class="variable" href="#BurstRateLimiter.name">name</a>
                        </li>
                        <li>
                                <a class="variable" href="#BurstRateLimiter.throttle_task">throttle_task</a>
                        </li>
                        <li>
                                <a class="variable" href="#BurstRateLimiter.queue">queue</a>
                        </li>
                        <li>
                                <a class="function" href="#BurstRateLimiter.acquire">acquire</a>
                        </li>
                        <li>
                                <a class="function" href="#BurstRateLimiter.close">close</a>
                        </li>
                        <li>
                                <a class="variable" href="#BurstRateLimiter.is_empty">is_empty</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#ManualRateLimiter">ManualRateLimiter</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#ManualRateLimiter.__init__">ManualRateLimiter</a>
                        </li>
                        <li>
                                <a class="variable" href="#ManualRateLimiter.throttle_task">throttle_task</a>
                        </li>
                        <li>
                                <a class="function" href="#ManualRateLimiter.acquire">acquire</a>
                        </li>
                        <li>
                                <a class="function" href="#ManualRateLimiter.throttle">throttle</a>
                        </li>
                        <li>
                                <a class="function" href="#ManualRateLimiter.unlock_later">unlock_later</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#WindowedBurstRateLimiter">WindowedBurstRateLimiter</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#WindowedBurstRateLimiter.__init__">WindowedBurstRateLimiter</a>
                        </li>
                        <li>
                                <a class="variable" href="#WindowedBurstRateLimiter.throttle_task">throttle_task</a>
                        </li>
                        <li>
                                <a class="variable" href="#WindowedBurstRateLimiter.reset_at">reset_at</a>
                        </li>
                        <li>
                                <a class="variable" href="#WindowedBurstRateLimiter.remaining">remaining</a>
                        </li>
                        <li>
                                <a class="variable" href="#WindowedBurstRateLimiter.period">period</a>
                        </li>
                        <li>
                                <a class="variable" href="#WindowedBurstRateLimiter.limit">limit</a>
                        </li>
                        <li>
                                <a class="function" href="#WindowedBurstRateLimiter.acquire">acquire</a>
                        </li>
                        <li>
                                <a class="function" href="#WindowedBurstRateLimiter.get_time_until_reset">get_time_until_reset</a>
                        </li>
                        <li>
                                <a class="function" href="#WindowedBurstRateLimiter.is_rate_limited">is_rate_limited</a>
                        </li>
                        <li>
                                <a class="function" href="#WindowedBurstRateLimiter.drip">drip</a>
                        </li>
                        <li>
                                <a class="function" href="#WindowedBurstRateLimiter.throttle">throttle</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#ExponentialBackOff">ExponentialBackOff</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#ExponentialBackOff.__init__">ExponentialBackOff</a>
                        </li>
                        <li>
                                <a class="variable" href="#ExponentialBackOff.base">base</a>
                        </li>
                        <li>
                                <a class="variable" href="#ExponentialBackOff.increment">increment</a>
                        </li>
                        <li>
                                <a class="variable" href="#ExponentialBackOff.maximum">maximum</a>
                        </li>
                        <li>
                                <a class="variable" href="#ExponentialBackOff.jitter_multiplier">jitter_multiplier</a>
                        </li>
                        <li>
                                <a class="function" href="#ExponentialBackOff.reset">reset</a>
                        </li>
                </ul>

            </li>
    </ul>


            <a class="attribution" href="https://pdoc.dev">built with pdoc v8.0.1</a>
        </div>

        <div class="sidebar-toggle" id="sidebar-toggle"></div>
    </nav>

    <main class="pdoc">
        
        <section>
                <h1 class="modulename">
<a href="./../../index.html">hikari</a><wbr>.<a href="./../impl.html">impl</a><wbr>.rate_limits    </h1>

                    <div class="docstring"><p>Basic lazy ratelimit systems for asyncio.</p>

<p>See <code><a href="buckets.html">hikari.impl.buckets</a></code> for HTTP-specific rate-limiting logic.</p>
</div>

                    <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># cython: language_level=3</span>
<span class="c1"># Copyright (c) 2020 Nekokatt</span>
<span class="c1"># Copyright (c) 2021 davfsa</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="c1"># of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<span class="c1"># in the Software without restriction, including without limitation the rights</span>
<span class="c1"># to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="c1"># copies of the Software, and to permit persons to whom the Software is</span>
<span class="c1"># furnished to do so, subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be included in all</span>
<span class="c1"># copies or substantial portions of the Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="c1"># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="c1"># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="c1"># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="c1"># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="c1"># OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="c1"># SOFTWARE.</span>
<span class="sd">&quot;&quot;&quot;Basic lazy ratelimit systems for asyncio.</span>

<span class="sd">See `hikari.impl.buckets` for HTTP-specific rate-limiting logic.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="n">__all__</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;BaseRateLimiter&quot;</span><span class="p">,</span>
    <span class="s2">&quot;BurstRateLimiter&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ManualRateLimiter&quot;</span><span class="p">,</span>
    <span class="s2">&quot;WindowedBurstRateLimiter&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ExponentialBackOff&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">typing</span>

<span class="kn">from</span> <span class="nn">hikari.internal</span> <span class="kn">import</span> <span class="n">time</span>

<span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">types</span>

<span class="n">_LOGGER</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Final</span><span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">]</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;hikari.ratelimits&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BaseRateLimiter</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base for any asyncio-based rate limiter being used.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Acquire permission to perform a task that needs to have rate limit management enforced.</span>

<span class="sd">        Calling this function will cause it to block until you are not longer</span>
<span class="sd">        being rate limited.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Close the rate limiter, cancelling any internal tasks that are executing.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BaseRateLimiter</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">exc_type</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Type</span><span class="p">[</span><span class="ne">Exception</span><span class="p">]],</span>
        <span class="n">exc_val</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="ne">Exception</span><span class="p">],</span>
        <span class="n">exc_tb</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">TracebackType</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">BurstRateLimiter</span><span class="p">(</span><span class="n">BaseRateLimiter</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base implementation for a burst-based rate limiter.</span>

<span class="sd">    This provides an internal queue and throttling placeholder, as well as</span>
<span class="sd">    complete logic for safely aborting any pending tasks when being shut down.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;throttle_task&quot;</span><span class="p">,</span> <span class="s2">&quot;queue&quot;</span><span class="p">,</span> <span class="s2">&quot;_closed&quot;</span><span class="p">)</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="sd">&quot;&quot;&quot;The name of the rate limiter.&quot;&quot;&quot;</span>

    <span class="n">throttle_task</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Task</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Any</span><span class="p">]]</span>
    <span class="sd">&quot;&quot;&quot;The throttling task, or `None` if it is not running.&quot;&quot;&quot;</span>

    <span class="n">queue</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Any</span><span class="p">]]</span>
    <span class="sd">&quot;&quot;&quot;The queue of any futures under a rate limit.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Acquire time on this rate limiter.</span>

<span class="sd">        Calling this function will cause it to block until you are not longer</span>
<span class="sd">        being rate limited.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Close the rate limiter, and shut down any pending tasks.</span>

<span class="sd">        Once this is invoked, you should not reuse this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">failed_tasks</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">:</span>
            <span class="n">failed_tasks</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># Make the future complete with an exception</span>
            <span class="n">future</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">failed_tasks</span><span class="p">:</span>
            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> rate limiter closed with </span><span class="si">%s</span><span class="s2"> pending tasks!&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">failed_tasks</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> rate limiter closed&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return `True` if no futures are on the queue being rate limited.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>


<span class="nd">@typing</span><span class="o">.</span><span class="n">final</span>
<span class="k">class</span> <span class="nc">ManualRateLimiter</span><span class="p">(</span><span class="n">BurstRateLimiter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rate limit handler for the global HTTP rate limit.</span>

<span class="sd">    This is a non-preemptive rate limiting algorithm that will always return</span>
<span class="sd">    completed futures until `ManualRateLimiter.throttle` is invoked. Once this</span>
<span class="sd">    is invoked, any subsequent calls to `ManualRateLimiter.acquire` will return</span>
<span class="sd">    incomplete futures that will be enqueued to an internal queue. A task will</span>
<span class="sd">    be spun up to wait for a period of time given to the</span>
<span class="sd">    `ManualRateLimiter.throttle`. Once that has passed, the lock will begin to</span>
<span class="sd">    re-consume incomplete futures on the queue, completing them.</span>

<span class="sd">    Triggering a throttle when it is already set will cancel the current</span>
<span class="sd">    throttle task that is sleeping and replace it.</span>

<span class="sd">    This is used to enforce the global HTTP rate limit that will occur</span>
<span class="sd">    &quot;randomly&quot; during HTTP API interaction.</span>

<span class="sd">    Expect random occurrences.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>

    <span class="n">throttle_task</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Task</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Any</span><span class="p">]]</span>
    <span class="c1"># &lt;&lt;inherited docstring from BurstRateLimiter&gt;&gt;.</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;global&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Acquire time on this rate limiter.</span>

<span class="sd">        Calling this function will cause it to block until you are not longer</span>
<span class="sd">        being rate limited.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
        <span class="n">future</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">future</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">await</span> <span class="n">future</span>

    <span class="k">def</span> <span class="nf">throttle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">retry_after</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Perform the throttling rate limiter logic.</span>

<span class="sd">        Iterates repeatedly while the queue is not empty, adhering to any</span>
<span class="sd">        rate limits that occur in the mean time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        retry_after : float</span>
<span class="sd">            How long to sleep for before unlocking and releasing any futures</span>
<span class="sd">            in the queue.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This will invoke `ManualRateLimiter.unlock_later` as a scheduled</span>
<span class="sd">            task in the future (it will not await it to finish).</span>

<span class="sd">            When the `ManualRateLimiter.unlock_later` coroutine function</span>
<span class="sd">            completes, it should be expected to set the `throttle_task` to</span>
<span class="sd">            `None`. This means you can check if throttling is occurring</span>
<span class="sd">            by checking if `throttle_task` is not `None`.</span>

<span class="sd">            If this is invoked while another throttle is in progress, that one</span>
<span class="sd">            is cancelled and a new one is started. This enables new rate limits</span>
<span class="sd">            to override existing ones.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

        <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unlock_later</span><span class="p">(</span><span class="n">retry_after</span><span class="p">))</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">unlock_later</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">retry_after</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sleeps for a while, then removes the lock.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        retry_after : float</span>
<span class="sd">            How long to sleep for before unlocking and releasing any futures</span>
<span class="sd">            in the queue.</span>

<span class="sd">        .. note::</span>
<span class="sd">            You should not need to invoke this directly. Call</span>
<span class="sd">            `ManualRateLimiter.throttle` instead.</span>

<span class="sd">            When the `ManualRateLimiter.unlock_later` coroutine function</span>
<span class="sd">            completes, it should be expected to set the `throttle_task` to</span>
<span class="sd">            `None`. This means you can check if throttling is occurring</span>
<span class="sd">            by checking if `throttle_task` is not `None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;you are being globally rate limited for </span><span class="si">%s</span><span class="s2">s&quot;</span><span class="p">,</span> <span class="n">retry_after</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">retry_after</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">:</span>
            <span class="n">next_future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">next_future</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">WindowedBurstRateLimiter</span><span class="p">(</span><span class="n">BurstRateLimiter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Windowed burst rate limiter.</span>

<span class="sd">    Rate limiter for rate limits that last fixed periods of time with a</span>
<span class="sd">    fixed number of times it can be used in that time frame.</span>

<span class="sd">    To use this, you should call WindowedBurstRateLimiter.aquire` and await the</span>
<span class="sd">    result immediately before performing your rate-limited task.</span>

<span class="sd">    If the rate limit has been hit, acquiring time will return an incomplete</span>
<span class="sd">    future that is placed on the internal queue. A throttle task is then spun up</span>
<span class="sd">    if not already running that will be expected to provide some implementation</span>
<span class="sd">    of backing off and sleeping for a given period of time until the limit has</span>
<span class="sd">    passed, and then proceed to consume futures from the queue while adhering</span>
<span class="sd">    to those rate limits.</span>

<span class="sd">    If the throttle task is already running, the acquired future will always be</span>
<span class="sd">    incomplete and enqueued regardless of whether the rate limit is actively</span>
<span class="sd">    reached or not.</span>

<span class="sd">    Acquiring a future from this limiter when no throttling task is running and</span>
<span class="sd">    when the rate limit is not reached will always result in the task invoking</span>
<span class="sd">    a drip and a completed future being returned.</span>

<span class="sd">    Dripping is left to the implementation of this class, but will be expected</span>
<span class="sd">    to provide some mechanism for updating the internal statistics to represent</span>
<span class="sd">    that a unit has been placed into the bucket.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;reset_at&quot;</span><span class="p">,</span> <span class="s2">&quot;remaining&quot;</span><span class="p">,</span> <span class="s2">&quot;limit&quot;</span><span class="p">,</span> <span class="s2">&quot;period&quot;</span><span class="p">)</span>

    <span class="n">throttle_task</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Task</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Any</span><span class="p">]]</span>
    <span class="c1"># &lt;&lt;inherited docstring from BurstRateLimiter&gt;&gt;.</span>

    <span class="n">reset_at</span><span class="p">:</span> <span class="nb">float</span>
    <span class="sd">&quot;&quot;&quot;The `time.monotonic_timestamp` that the limit window ends at.&quot;&quot;&quot;</span>

    <span class="n">remaining</span><span class="p">:</span> <span class="nb">int</span>
    <span class="sd">&quot;&quot;&quot;The number of `WindowedBurstRateLimiter.acquire`&#39;s left in this window</span>
<span class="sd">    before you will get rate limited.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">period</span><span class="p">:</span> <span class="nb">float</span>
    <span class="sd">&quot;&quot;&quot;How long the window lasts for from the start in seconds.&quot;&quot;&quot;</span>

    <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span>
    <span class="sd">&quot;&quot;&quot;The maximum number of `WindowedBurstRateLimiter.acquire`&#39;s allowed in</span>
<span class="sd">    this time window.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">period</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remaining</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">period</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Acquire time on this rate limiter.</span>

<span class="sd">        Calling this function will cause it to block until you are not longer</span>
<span class="sd">        being rate limited.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
        <span class="n">future</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>

        <span class="c1"># If we are rate limited, delegate invoking this to the throttler and spin it up</span>
        <span class="c1"># if it hasn&#39;t started. Likewise, if the throttle task is still running, we should</span>
        <span class="c1"># delegate releasing the future to the throttler task so that we still process</span>
        <span class="c1"># first-come-first-serve</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_rate_limited</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">throttle</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">drip</span><span class="p">()</span>
            <span class="n">future</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">await</span> <span class="n">future</span>

    <span class="k">def</span> <span class="nf">get_time_until_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">now</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Determine how long until the current rate limit is reset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        now : float</span>
<span class="sd">            The monotonic `time.monotonic_timestamp` timestamp.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Invoking this method will update the internal state if we were</span>
<span class="sd">            previously rate limited, but at the given time are no longer under</span>
<span class="sd">            that limit. This makes it imperative that you only pass the current</span>
<span class="sd">            timestamp to this function, and not past or future timestamps. The</span>
<span class="sd">            effects of doing the latter are undefined behaviour.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The time left to sleep before the rate limit is reset. If no rate limit</span>
<span class="sd">            is in effect, then this will return `0.0` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_rate_limited</span><span class="p">(</span><span class="n">now</span><span class="p">):</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">-</span> <span class="n">now</span>

    <span class="k">def</span> <span class="nf">is_rate_limited</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">now</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Determine if we are under a rate limit at the given time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        now : float</span>
<span class="sd">            The monotonic `time.monotonic_timestamp` timestamp.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            `True` if we are being rate limited, or `False` if</span>
<span class="sd">            we are not.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Invoking this method will update the internal state if we were</span>
<span class="sd">            previously rate limited, but at the given time are no longer under</span>
<span class="sd">            that limit. This makes it imperative that you only pass the current</span>
<span class="sd">            timestamp to this function, and not past or future timestamps. The</span>
<span class="sd">            effects of doing the latter are undefined behaviour.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">&lt;=</span> <span class="n">now</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remaining</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limit</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remaining</span> <span class="o">&lt;=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">drip</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Decrements the remaining counter.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remaining</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">throttle</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Perform the throttling rate limiter logic.</span>

<span class="sd">        Iterates repeatedly while the queue is not empty, adhering to any</span>
<span class="sd">        rate limits that occur in the mean time.</span>

<span class="sd">        .. note::</span>
<span class="sd">            You should usually not need to invoke this directly, but if you do,</span>
<span class="sd">            ensure to call it using `asyncio.create_task`, and store the</span>
<span class="sd">            task immediately in `throttle_task`.</span>

<span class="sd">            When this coroutine function completes, it will set the</span>
<span class="sd">            `throttle_task` to `None`. This means you can check if throttling</span>
<span class="sd">            is occurring by checking if `throttle_task` is not `None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;you are being rate limited on bucket </span><span class="si">%s</span><span class="s2">, backing off for </span><span class="si">%s</span><span class="s2">s&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_time_until_reset</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()),</span>
        <span class="p">)</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">:</span>
            <span class="n">sleep_for</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_time_until_reset</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">())</span>
            <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">sleep_for</span><span class="p">)</span>

            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">remaining</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">drip</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="o">=</span> <span class="kc">None</span>


<span class="nd">@typing</span><span class="o">.</span><span class="n">final</span>
<span class="k">class</span> <span class="nc">ExponentialBackOff</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Implementation of an asyncio-compatible exponential back-off algorithm with random jitter.</span>

<span class="sd">    .. math::</span>

<span class="sd">        t_{backoff} = b^{i} +  m \cdot \mathrm{rand}()</span>

<span class="sd">    Such that \(t_{backoff}\) is the backoff time, \(b\) is the base,</span>
<span class="sd">    \(i\) is the increment that increases by 1 for each invocation, and</span>
<span class="sd">    \(m\) is the jitter multiplier. \(\mathrm{rand}()\) returns a value in</span>
<span class="sd">    the range \([0,1]\).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    base : float</span>
<span class="sd">        The base to use. Defaults to `2.0`.</span>
<span class="sd">    maximum : float</span>
<span class="sd">        The max value the backoff can be in a single iteration. Anything above</span>
<span class="sd">        this will be capped to this base value plus random jitter.</span>
<span class="sd">    jitter_multiplier : float</span>
<span class="sd">        The multiplier for the random jitter. Defaults to `1.0`.</span>
<span class="sd">        Set to `0` to disable jitter.</span>
<span class="sd">    initial_increment : int</span>
<span class="sd">        The initial increment to start at. Defaults to `0`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If an `int` that&#39;s too big to be represented as a</span>
<span class="sd">        `float` or a non-finite value is passed in place of a field</span>
<span class="sd">        that&#39;s annotated as `float`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;base&quot;</span><span class="p">,</span> <span class="s2">&quot;increment&quot;</span><span class="p">,</span> <span class="s2">&quot;maximum&quot;</span><span class="p">,</span> <span class="s2">&quot;jitter_multiplier&quot;</span><span class="p">)</span>

    <span class="n">base</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Final</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;The base to use. Defaults to 2.0.&quot;&quot;&quot;</span>

    <span class="n">increment</span><span class="p">:</span> <span class="nb">int</span>
    <span class="sd">&quot;&quot;&quot;The current increment.&quot;&quot;&quot;</span>

    <span class="n">maximum</span><span class="p">:</span> <span class="nb">float</span>
    <span class="sd">&quot;&quot;&quot;This is the max value the backoff can be in a single iteration before an</span>
<span class="sd">    `asyncio.TimeoutError` is raised.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">jitter_multiplier</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Final</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;The multiplier for the random jitter.</span>

<span class="sd">    This defaults to `1.0`. Set to `0.0` to disable jitter.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">base</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="n">maximum</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">64.0</span><span class="p">,</span>
        <span class="n">jitter_multiplier</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">initial_increment</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># https://mypy.readthedocs.io/en/stable/duck_type_compatibility.html</span>
        <span class="c1"># Mypy makes the assumption that ints will always be compatible with floats, this isn&#39;t the case and could lead</span>
        <span class="c1"># to some edge cases that we&#39;d be better off catching earlier on by ensuring these values are actually valid</span>
        <span class="c1"># (most notably floats have a system based maximum size whereas integers theoretically don&#39;t with implicit</span>
        <span class="c1"># conversion to a float raising an error if an integer that&#39;s too big to be a float is handled).</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">maximum</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jitter_multiplier</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">jitter_multiplier</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OverflowError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;int too large to be represented as a float&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;base must be a finite number&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maximum</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;maximum must be a finite number&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jitter_multiplier</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jitter_multiplier must be a finite number&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">increment</span> <span class="o">=</span> <span class="n">initial_increment</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the next back off to sleep by.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">increment</span>

            <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This should only be incremented after we verify we haven&#39;t hit the maximum value.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">increment</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">OverflowError</span><span class="p">:</span>
            <span class="c1"># If this happened then we can be sure that we&#39;ve passed maximum.</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span>

        <span class="k">return</span> <span class="n">value</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">jitter_multiplier</span>  <span class="c1"># nosec  # noqa S311 rng for cryptography</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ExponentialBackOff</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return this object, as it is an iterator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Reset the exponential back-off.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">increment</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>

        </details>

        </section>

            <section id="BaseRateLimiter">
                    
            <div class="attr class">
        <a class="headerlink" href="#BaseRateLimiter">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">BaseRateLimiter</span><wbr>(<span class="base">abc.ABC</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">BaseRateLimiter</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base for any asyncio-based rate limiter being used.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Acquire permission to perform a task that needs to have rate limit management enforced.</span>

<span class="sd">        Calling this function will cause it to block until you are not longer</span>
<span class="sd">        being rate limited.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Close the rate limiter, cancelling any internal tasks that are executing.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BaseRateLimiter</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">exc_type</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Type</span><span class="p">[</span><span class="ne">Exception</span><span class="p">]],</span>
        <span class="n">exc_val</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="ne">Exception</span><span class="p">],</span>
        <span class="n">exc_tb</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">TracebackType</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Base for any asyncio-based rate limiter being used.</p>
</div>


                        <div id="BaseRateLimiter.acquire" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#BaseRateLimiter.acquire">#&nbsp;&nbsp</a>

                <div class="decorator">@abc.abstractmethod</div>

            <span class="def">async def</span>
            <span class="name">acquire</span><span class="signature">(self) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Acquire permission to perform a task that needs to have rate limit management enforced.</span>

<span class="sd">        Calling this function will cause it to block until you are not longer</span>
<span class="sd">        being rate limited.</span>
<span class="sd">        &quot;&quot;&quot;</span>
</pre></div>

        </details>

            <div class="docstring"><p>Acquire permission to perform a task that needs to have rate limit management enforced.</p>

<p>Calling this function will cause it to block until you are not longer
being rate limited.</p>
</div>


                        </div>
                        <div id="BaseRateLimiter.close" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#BaseRateLimiter.close">#&nbsp;&nbsp</a>

                <div class="decorator">@abc.abstractmethod</div>

            <span class="def">def</span>
            <span class="name">close</span><span class="signature">(self) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Close the rate limiter, cancelling any internal tasks that are executing.&quot;&quot;&quot;</span>
</pre></div>

        </details>

            <div class="docstring"><p>Close the rate limiter, cancelling any internal tasks that are executing.</p>
</div>


                        </div>
            </section>
            <section id="BurstRateLimiter">
                    
            <div class="attr class">
        <a class="headerlink" href="#BurstRateLimiter">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">BurstRateLimiter</span><wbr>(<span class="base"><a href="#BaseRateLimiter">BaseRateLimiter</a></span>, <span class="base">abc.ABC</span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">BurstRateLimiter</span><span class="p">(</span><span class="n">BaseRateLimiter</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base implementation for a burst-based rate limiter.</span>

<span class="sd">    This provides an internal queue and throttling placeholder, as well as</span>
<span class="sd">    complete logic for safely aborting any pending tasks when being shut down.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;throttle_task&quot;</span><span class="p">,</span> <span class="s2">&quot;queue&quot;</span><span class="p">,</span> <span class="s2">&quot;_closed&quot;</span><span class="p">)</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="sd">&quot;&quot;&quot;The name of the rate limiter.&quot;&quot;&quot;</span>

    <span class="n">throttle_task</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Task</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Any</span><span class="p">]]</span>
    <span class="sd">&quot;&quot;&quot;The throttling task, or `None` if it is not running.&quot;&quot;&quot;</span>

    <span class="n">queue</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Any</span><span class="p">]]</span>
    <span class="sd">&quot;&quot;&quot;The queue of any futures under a rate limit.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Acquire time on this rate limiter.</span>

<span class="sd">        Calling this function will cause it to block until you are not longer</span>
<span class="sd">        being rate limited.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Close the rate limiter, and shut down any pending tasks.</span>

<span class="sd">        Once this is invoked, you should not reuse this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">failed_tasks</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">:</span>
            <span class="n">failed_tasks</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># Make the future complete with an exception</span>
            <span class="n">future</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">failed_tasks</span><span class="p">:</span>
            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> rate limiter closed with </span><span class="si">%s</span><span class="s2"> pending tasks!&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">failed_tasks</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> rate limiter closed&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return `True` if no futures are on the queue being rate limited.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>

        </details>

            <div class="docstring"><p>Base implementation for a burst-based rate limiter.</p>

<p>This provides an internal queue and throttling placeholder, as well as
complete logic for safely aborting any pending tasks when being shut down.</p>
</div>


                        <div id="BurstRateLimiter.name" class="classattr">
                                
            <div class="attr variable"><a class="headerlink" href="#BurstRateLimiter.name">#&nbsp;&nbsp</a>

        <span class="name">name</span><span class="annotation">: str</span>
    </div>

            <div class="docstring"><p>The name of the rate limiter.</p>
</div>


                        </div>
                        <div id="BurstRateLimiter.throttle_task" class="classattr">
                                
            <div class="attr variable"><a class="headerlink" href="#BurstRateLimiter.throttle_task">#&nbsp;&nbsp</a>

        <span class="name">throttle_task</span><span class="annotation">: &#39;typing.Optional[asyncio.Task[typing.Any]]&#39;</span>
    </div>

            <div class="docstring"><p>The throttling task, or <code>None</code> if it is not running.</p>
</div>


                        </div>
                        <div id="BurstRateLimiter.queue" class="classattr">
                                
            <div class="attr variable"><a class="headerlink" href="#BurstRateLimiter.queue">#&nbsp;&nbsp</a>

        <span class="name">queue</span><span class="annotation">: &#39;typing.List[asyncio.Future[typing.Any]]&#39;</span>
    </div>

            <div class="docstring"><p>The queue of any futures under a rate limit.</p>
</div>


                        </div>
                        <div id="BurstRateLimiter.acquire" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#BurstRateLimiter.acquire">#&nbsp;&nbsp</a>

                <div class="decorator">@abc.abstractmethod</div>

            <span class="def">async def</span>
            <span class="name">acquire</span><span class="signature">(self) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Acquire time on this rate limiter.</span>

<span class="sd">        Calling this function will cause it to block until you are not longer</span>
<span class="sd">        being rate limited.</span>
<span class="sd">        &quot;&quot;&quot;</span>
</pre></div>

        </details>

            <div class="docstring"><p>Acquire time on this rate limiter.</p>

<p>Calling this function will cause it to block until you are not longer
being rate limited.</p>
</div>


                        </div>
                        <div id="BurstRateLimiter.close" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#BurstRateLimiter.close">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">close</span><span class="signature">(self) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Close the rate limiter, and shut down any pending tasks.</span>

<span class="sd">        Once this is invoked, you should not reuse this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">failed_tasks</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">:</span>
            <span class="n">failed_tasks</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># Make the future complete with an exception</span>
            <span class="n">future</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">failed_tasks</span><span class="p">:</span>
            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> rate limiter closed with </span><span class="si">%s</span><span class="s2"> pending tasks!&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">failed_tasks</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> rate limiter closed&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>

        </details>

            <div class="docstring"><p>Close the rate limiter, and shut down any pending tasks.</p>

<p>Once this is invoked, you should not reuse this object.</p>
</div>


                        </div>
                        <div id="BurstRateLimiter.is_empty" class="classattr">
                                
            <div class="attr variable"><a class="headerlink" href="#BurstRateLimiter.is_empty">#&nbsp;&nbsp</a>

        <span class="name">is_empty</span><span class="annotation">: bool</span>
    </div>

            <div class="docstring"><p>Return <code>True</code> if no futures are on the queue being rate limited.</p>
</div>


                        </div>
            </section>
            <section id="ManualRateLimiter">
                    
            <div class="attr class">
        <a class="headerlink" href="#ManualRateLimiter">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">ManualRateLimiter</span><wbr>(<span class="base"><a href="#BurstRateLimiter">BurstRateLimiter</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">ManualRateLimiter</span><span class="p">(</span><span class="n">BurstRateLimiter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rate limit handler for the global HTTP rate limit.</span>

<span class="sd">    This is a non-preemptive rate limiting algorithm that will always return</span>
<span class="sd">    completed futures until `ManualRateLimiter.throttle` is invoked. Once this</span>
<span class="sd">    is invoked, any subsequent calls to `ManualRateLimiter.acquire` will return</span>
<span class="sd">    incomplete futures that will be enqueued to an internal queue. A task will</span>
<span class="sd">    be spun up to wait for a period of time given to the</span>
<span class="sd">    `ManualRateLimiter.throttle`. Once that has passed, the lock will begin to</span>
<span class="sd">    re-consume incomplete futures on the queue, completing them.</span>

<span class="sd">    Triggering a throttle when it is already set will cancel the current</span>
<span class="sd">    throttle task that is sleeping and replace it.</span>

<span class="sd">    This is used to enforce the global HTTP rate limit that will occur</span>
<span class="sd">    &quot;randomly&quot; during HTTP API interaction.</span>

<span class="sd">    Expect random occurrences.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>

    <span class="n">throttle_task</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Task</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Any</span><span class="p">]]</span>
    <span class="c1"># &lt;&lt;inherited docstring from BurstRateLimiter&gt;&gt;.</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;global&quot;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Acquire time on this rate limiter.</span>

<span class="sd">        Calling this function will cause it to block until you are not longer</span>
<span class="sd">        being rate limited.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
        <span class="n">future</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">future</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">await</span> <span class="n">future</span>

    <span class="k">def</span> <span class="nf">throttle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">retry_after</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Perform the throttling rate limiter logic.</span>

<span class="sd">        Iterates repeatedly while the queue is not empty, adhering to any</span>
<span class="sd">        rate limits that occur in the mean time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        retry_after : float</span>
<span class="sd">            How long to sleep for before unlocking and releasing any futures</span>
<span class="sd">            in the queue.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This will invoke `ManualRateLimiter.unlock_later` as a scheduled</span>
<span class="sd">            task in the future (it will not await it to finish).</span>

<span class="sd">            When the `ManualRateLimiter.unlock_later` coroutine function</span>
<span class="sd">            completes, it should be expected to set the `throttle_task` to</span>
<span class="sd">            `None`. This means you can check if throttling is occurring</span>
<span class="sd">            by checking if `throttle_task` is not `None`.</span>

<span class="sd">            If this is invoked while another throttle is in progress, that one</span>
<span class="sd">            is cancelled and a new one is started. This enables new rate limits</span>
<span class="sd">            to override existing ones.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

        <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unlock_later</span><span class="p">(</span><span class="n">retry_after</span><span class="p">))</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">unlock_later</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">retry_after</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sleeps for a while, then removes the lock.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        retry_after : float</span>
<span class="sd">            How long to sleep for before unlocking and releasing any futures</span>
<span class="sd">            in the queue.</span>

<span class="sd">        .. note::</span>
<span class="sd">            You should not need to invoke this directly. Call</span>
<span class="sd">            `ManualRateLimiter.throttle` instead.</span>

<span class="sd">            When the `ManualRateLimiter.unlock_later` coroutine function</span>
<span class="sd">            completes, it should be expected to set the `throttle_task` to</span>
<span class="sd">            `None`. This means you can check if throttling is occurring</span>
<span class="sd">            by checking if `throttle_task` is not `None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;you are being globally rate limited for </span><span class="si">%s</span><span class="s2">s&quot;</span><span class="p">,</span> <span class="n">retry_after</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">retry_after</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">:</span>
            <span class="n">next_future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">next_future</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>

        </details>

            <div class="docstring"><p>Rate limit handler for the global HTTP rate limit.</p>

<p>This is a non-preemptive rate limiting algorithm that will always return
completed futures until <code><a href="#ManualRateLimiter.throttle">ManualRateLimiter.throttle</a></code> is invoked. Once this
is invoked, any subsequent calls to <code><a href="#ManualRateLimiter.acquire">ManualRateLimiter.acquire</a></code> will return
incomplete futures that will be enqueued to an internal queue. A task will
be spun up to wait for a period of time given to the
<code><a href="#ManualRateLimiter.throttle">ManualRateLimiter.throttle</a></code>. Once that has passed, the lock will begin to
re-consume incomplete futures on the queue, completing them.</p>

<p>Triggering a throttle when it is already set will cancel the current
throttle task that is sleeping and replace it.</p>

<p>This is used to enforce the global HTTP rate limit that will occur
"randomly" during HTTP API interaction.</p>

<p>Expect random occurrences.</p>
</div>


                        <div id="ManualRateLimiter.__init__" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#ManualRateLimiter.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">ManualRateLimiter</span><span class="signature">()</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;global&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                        </div>
                        <div id="ManualRateLimiter.throttle_task" class="classattr">
                                
            <div class="attr variable"><a class="headerlink" href="#ManualRateLimiter.throttle_task">#&nbsp;&nbsp</a>

        <span class="name">throttle_task</span><span class="annotation">: &#39;typing.Optional[asyncio.Task[typing.Any]]&#39;</span>
    </div>

            <div class="docstring"><p>The throttling task, or <code>None</code> if it is not running.</p>
</div>


                        </div>
                        <div id="ManualRateLimiter.acquire" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#ManualRateLimiter.acquire">#&nbsp;&nbsp</a>

        
            <span class="def">async def</span>
            <span class="name">acquire</span><span class="signature">(self) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">async</span> <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Acquire time on this rate limiter.</span>

<span class="sd">        Calling this function will cause it to block until you are not longer</span>
<span class="sd">        being rate limited.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
        <span class="n">future</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">future</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">await</span> <span class="n">future</span>
</pre></div>

        </details>

            <div class="docstring"><p>Acquire time on this rate limiter.</p>

<p>Calling this function will cause it to block until you are not longer
being rate limited.</p>
</div>


                        </div>
                        <div id="ManualRateLimiter.throttle" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#ManualRateLimiter.throttle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">throttle</span><span class="signature">(self, retry_after: float) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">throttle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">retry_after</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Perform the throttling rate limiter logic.</span>

<span class="sd">        Iterates repeatedly while the queue is not empty, adhering to any</span>
<span class="sd">        rate limits that occur in the mean time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        retry_after : float</span>
<span class="sd">            How long to sleep for before unlocking and releasing any futures</span>
<span class="sd">            in the queue.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This will invoke `ManualRateLimiter.unlock_later` as a scheduled</span>
<span class="sd">            task in the future (it will not await it to finish).</span>

<span class="sd">            When the `ManualRateLimiter.unlock_later` coroutine function</span>
<span class="sd">            completes, it should be expected to set the `throttle_task` to</span>
<span class="sd">            `None`. This means you can check if throttling is occurring</span>
<span class="sd">            by checking if `throttle_task` is not `None`.</span>

<span class="sd">            If this is invoked while another throttle is in progress, that one</span>
<span class="sd">            is cancelled and a new one is started. This enables new rate limits</span>
<span class="sd">            to override existing ones.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

        <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unlock_later</span><span class="p">(</span><span class="n">retry_after</span><span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>Perform the throttling rate limiter logic.</p>

<p>Iterates repeatedly while the queue is not empty, adhering to any
rate limits that occur in the mean time.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>retry_after</strong> (float):
How long to sleep for before unlocking and releasing any futures
in the queue.</li>
<li><p><strong><em>Note</strong> (</em>):</p></li>
<li><p><strong>This will invoke <code><a href="#ManualRateLimiter.unlock_later">ManualRateLimiter.unlock_later</a></code> as a scheduled</strong></p></li>
<li><strong>task in the future (it will not await it to finish).</strong></li>
<li><strong>When the <code><a href="#ManualRateLimiter.unlock_later">ManualRateLimiter.unlock_later</a></code> coroutine function</strong></li>
<li><strong>completes, it should be expected to set the <code><a href="#ManualRateLimiter.throttle_task">throttle_task</a></code> to</strong></li>
<li><strong><code>None</code>. This means you can check if throttling is occurring</strong></li>
<li><strong>by checking if <code><a href="#ManualRateLimiter.throttle_task">throttle_task</a></code> is not <code>None</code>.</strong></li>
<li><strong>If this is invoked while another throttle is in progress, that one</strong></li>
<li><strong>is cancelled and a new one is started. This enables new rate limits</strong></li>
<li><strong>to override existing ones.</strong></li>
</ul>
</div>


                        </div>
                        <div id="ManualRateLimiter.unlock_later" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#ManualRateLimiter.unlock_later">#&nbsp;&nbsp</a>

        
            <span class="def">async def</span>
            <span class="name">unlock_later</span><span class="signature">(self, retry_after: float) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">async</span> <span class="k">def</span> <span class="nf">unlock_later</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">retry_after</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sleeps for a while, then removes the lock.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        retry_after : float</span>
<span class="sd">            How long to sleep for before unlocking and releasing any futures</span>
<span class="sd">            in the queue.</span>

<span class="sd">        .. note::</span>
<span class="sd">            You should not need to invoke this directly. Call</span>
<span class="sd">            `ManualRateLimiter.throttle` instead.</span>

<span class="sd">            When the `ManualRateLimiter.unlock_later` coroutine function</span>
<span class="sd">            completes, it should be expected to set the `throttle_task` to</span>
<span class="sd">            `None`. This means you can check if throttling is occurring</span>
<span class="sd">            by checking if `throttle_task` is not `None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;you are being globally rate limited for </span><span class="si">%s</span><span class="s2">s&quot;</span><span class="p">,</span> <span class="n">retry_after</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">retry_after</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">:</span>
            <span class="n">next_future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">next_future</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sleeps for a while, then removes the lock.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>retry_after</strong> (float):
How long to sleep for before unlocking and releasing any futures
in the queue.</li>
<li><p><strong><em>Note</strong> (</em>):</p></li>
<li><p><strong>You should not need to invoke this directly. Call</strong></p></li>
<li><strong><code><a href="#ManualRateLimiter.throttle">ManualRateLimiter.throttle</a></code> instead.</strong></li>
<li><strong>When the <code><a href="#ManualRateLimiter.unlock_later">ManualRateLimiter.unlock_later</a></code> coroutine function</strong></li>
<li><strong>completes, it should be expected to set the <code><a href="#ManualRateLimiter.throttle_task">throttle_task</a></code> to</strong></li>
<li><strong><code>None</code>. This means you can check if throttling is occurring</strong></li>
<li><strong>by checking if <code><a href="#ManualRateLimiter.throttle_task">throttle_task</a></code> is not <code>None</code>.</strong></li>
</ul>
</div>


                        </div>
                        <div class="inherited">
                            <h5>Inherited Members</h5>
                            <dl>
                                <div><dt><a href="#BurstRateLimiter">BurstRateLimiter</a></dt>
            <dd id="ManualRateLimiter.name" class="variable"><a href="#BurstRateLimiter.name">name</a></dd>
    <dd id="ManualRateLimiter.queue" class="variable"><a href="#BurstRateLimiter.queue">queue</a></dd>
    <dd id="ManualRateLimiter.close" class="function"><a href="#BurstRateLimiter.close">close</a></dd>
    <dd id="ManualRateLimiter.is_empty" class="variable"><a href="#BurstRateLimiter.is_empty">is_empty</a></dd>

    </div>
                            </dl>
                        </div>
            </section>
            <section id="WindowedBurstRateLimiter">
                    
            <div class="attr class">
        <a class="headerlink" href="#WindowedBurstRateLimiter">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">WindowedBurstRateLimiter</span><wbr>(<span class="base"><a href="#BurstRateLimiter">BurstRateLimiter</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">WindowedBurstRateLimiter</span><span class="p">(</span><span class="n">BurstRateLimiter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Windowed burst rate limiter.</span>

<span class="sd">    Rate limiter for rate limits that last fixed periods of time with a</span>
<span class="sd">    fixed number of times it can be used in that time frame.</span>

<span class="sd">    To use this, you should call WindowedBurstRateLimiter.aquire` and await the</span>
<span class="sd">    result immediately before performing your rate-limited task.</span>

<span class="sd">    If the rate limit has been hit, acquiring time will return an incomplete</span>
<span class="sd">    future that is placed on the internal queue. A throttle task is then spun up</span>
<span class="sd">    if not already running that will be expected to provide some implementation</span>
<span class="sd">    of backing off and sleeping for a given period of time until the limit has</span>
<span class="sd">    passed, and then proceed to consume futures from the queue while adhering</span>
<span class="sd">    to those rate limits.</span>

<span class="sd">    If the throttle task is already running, the acquired future will always be</span>
<span class="sd">    incomplete and enqueued regardless of whether the rate limit is actively</span>
<span class="sd">    reached or not.</span>

<span class="sd">    Acquiring a future from this limiter when no throttling task is running and</span>
<span class="sd">    when the rate limit is not reached will always result in the task invoking</span>
<span class="sd">    a drip and a completed future being returned.</span>

<span class="sd">    Dripping is left to the implementation of this class, but will be expected</span>
<span class="sd">    to provide some mechanism for updating the internal statistics to represent</span>
<span class="sd">    that a unit has been placed into the bucket.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;reset_at&quot;</span><span class="p">,</span> <span class="s2">&quot;remaining&quot;</span><span class="p">,</span> <span class="s2">&quot;limit&quot;</span><span class="p">,</span> <span class="s2">&quot;period&quot;</span><span class="p">)</span>

    <span class="n">throttle_task</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Task</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Any</span><span class="p">]]</span>
    <span class="c1"># &lt;&lt;inherited docstring from BurstRateLimiter&gt;&gt;.</span>

    <span class="n">reset_at</span><span class="p">:</span> <span class="nb">float</span>
    <span class="sd">&quot;&quot;&quot;The `time.monotonic_timestamp` that the limit window ends at.&quot;&quot;&quot;</span>

    <span class="n">remaining</span><span class="p">:</span> <span class="nb">int</span>
    <span class="sd">&quot;&quot;&quot;The number of `WindowedBurstRateLimiter.acquire`&#39;s left in this window</span>
<span class="sd">    before you will get rate limited.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">period</span><span class="p">:</span> <span class="nb">float</span>
    <span class="sd">&quot;&quot;&quot;How long the window lasts for from the start in seconds.&quot;&quot;&quot;</span>

    <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span>
    <span class="sd">&quot;&quot;&quot;The maximum number of `WindowedBurstRateLimiter.acquire`&#39;s allowed in</span>
<span class="sd">    this time window.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">period</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remaining</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">period</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Acquire time on this rate limiter.</span>

<span class="sd">        Calling this function will cause it to block until you are not longer</span>
<span class="sd">        being rate limited.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
        <span class="n">future</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>

        <span class="c1"># If we are rate limited, delegate invoking this to the throttler and spin it up</span>
        <span class="c1"># if it hasn&#39;t started. Likewise, if the throttle task is still running, we should</span>
        <span class="c1"># delegate releasing the future to the throttler task so that we still process</span>
        <span class="c1"># first-come-first-serve</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_rate_limited</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">throttle</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">drip</span><span class="p">()</span>
            <span class="n">future</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">await</span> <span class="n">future</span>

    <span class="k">def</span> <span class="nf">get_time_until_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">now</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Determine how long until the current rate limit is reset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        now : float</span>
<span class="sd">            The monotonic `time.monotonic_timestamp` timestamp.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Invoking this method will update the internal state if we were</span>
<span class="sd">            previously rate limited, but at the given time are no longer under</span>
<span class="sd">            that limit. This makes it imperative that you only pass the current</span>
<span class="sd">            timestamp to this function, and not past or future timestamps. The</span>
<span class="sd">            effects of doing the latter are undefined behaviour.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The time left to sleep before the rate limit is reset. If no rate limit</span>
<span class="sd">            is in effect, then this will return `0.0` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_rate_limited</span><span class="p">(</span><span class="n">now</span><span class="p">):</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">-</span> <span class="n">now</span>

    <span class="k">def</span> <span class="nf">is_rate_limited</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">now</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Determine if we are under a rate limit at the given time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        now : float</span>
<span class="sd">            The monotonic `time.monotonic_timestamp` timestamp.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            `True` if we are being rate limited, or `False` if</span>
<span class="sd">            we are not.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Invoking this method will update the internal state if we were</span>
<span class="sd">            previously rate limited, but at the given time are no longer under</span>
<span class="sd">            that limit. This makes it imperative that you only pass the current</span>
<span class="sd">            timestamp to this function, and not past or future timestamps. The</span>
<span class="sd">            effects of doing the latter are undefined behaviour.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">&lt;=</span> <span class="n">now</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remaining</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limit</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remaining</span> <span class="o">&lt;=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">drip</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Decrements the remaining counter.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remaining</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">throttle</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Perform the throttling rate limiter logic.</span>

<span class="sd">        Iterates repeatedly while the queue is not empty, adhering to any</span>
<span class="sd">        rate limits that occur in the mean time.</span>

<span class="sd">        .. note::</span>
<span class="sd">            You should usually not need to invoke this directly, but if you do,</span>
<span class="sd">            ensure to call it using `asyncio.create_task`, and store the</span>
<span class="sd">            task immediately in `throttle_task`.</span>

<span class="sd">            When this coroutine function completes, it will set the</span>
<span class="sd">            `throttle_task` to `None`. This means you can check if throttling</span>
<span class="sd">            is occurring by checking if `throttle_task` is not `None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;you are being rate limited on bucket </span><span class="si">%s</span><span class="s2">, backing off for </span><span class="si">%s</span><span class="s2">s&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_time_until_reset</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()),</span>
        <span class="p">)</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">:</span>
            <span class="n">sleep_for</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_time_until_reset</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">())</span>
            <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">sleep_for</span><span class="p">)</span>

            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">remaining</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">drip</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>

        </details>

            <div class="docstring"><p>Windowed burst rate limiter.</p>

<p>Rate limiter for rate limits that last fixed periods of time with a
fixed number of times it can be used in that time frame.</p>

<p>To use this, you should call WindowedBurstRateLimiter.aquire` and await the
result immediately before performing your rate-limited task.</p>

<p>If the rate limit has been hit, acquiring time will return an incomplete
future that is placed on the internal queue. A throttle task is then spun up
if not already running that will be expected to provide some implementation
of backing off and sleeping for a given period of time until the limit has
passed, and then proceed to consume futures from the queue while adhering
to those rate limits.</p>

<p>If the throttle task is already running, the acquired future will always be
incomplete and enqueued regardless of whether the rate limit is actively
reached or not.</p>

<p>Acquiring a future from this limiter when no throttling task is running and
when the rate limit is not reached will always result in the task invoking
a drip and a completed future being returned.</p>

<p>Dripping is left to the implementation of this class, but will be expected
to provide some mechanism for updating the internal statistics to represent
that a unit has been placed into the bucket.</p>
</div>


                        <div id="WindowedBurstRateLimiter.__init__" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#WindowedBurstRateLimiter.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">WindowedBurstRateLimiter</span><span class="signature">(name: str, period: float, limit: int)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">period</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remaining</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">period</span>
</pre></div>

        </details>

    

                        </div>
                        <div id="WindowedBurstRateLimiter.throttle_task" class="classattr">
                                
            <div class="attr variable"><a class="headerlink" href="#WindowedBurstRateLimiter.throttle_task">#&nbsp;&nbsp</a>

        <span class="name">throttle_task</span><span class="annotation">: &#39;typing.Optional[asyncio.Task[typing.Any]]&#39;</span>
    </div>

            <div class="docstring"><p>The throttling task, or <code>None</code> if it is not running.</p>
</div>


                        </div>
                        <div id="WindowedBurstRateLimiter.reset_at" class="classattr">
                                
            <div class="attr variable"><a class="headerlink" href="#WindowedBurstRateLimiter.reset_at">#&nbsp;&nbsp</a>

        <span class="name">reset_at</span><span class="annotation">: float</span>
    </div>

            <div class="docstring"><p>The <code>time.monotonic_timestamp</code> that the limit window ends at.</p>
</div>


                        </div>
                        <div id="WindowedBurstRateLimiter.remaining" class="classattr">
                                
            <div class="attr variable"><a class="headerlink" href="#WindowedBurstRateLimiter.remaining">#&nbsp;&nbsp</a>

        <span class="name">remaining</span><span class="annotation">: int</span>
    </div>

            <div class="docstring"><p>The number of <code><a href="#WindowedBurstRateLimiter.acquire">WindowedBurstRateLimiter.acquire</a></code>'s left in this window
before you will get rate limited.</p>
</div>


                        </div>
                        <div id="WindowedBurstRateLimiter.period" class="classattr">
                                
            <div class="attr variable"><a class="headerlink" href="#WindowedBurstRateLimiter.period">#&nbsp;&nbsp</a>

        <span class="name">period</span><span class="annotation">: float</span>
    </div>

            <div class="docstring"><p>How long the window lasts for from the start in seconds.</p>
</div>


                        </div>
                        <div id="WindowedBurstRateLimiter.limit" class="classattr">
                                
            <div class="attr variable"><a class="headerlink" href="#WindowedBurstRateLimiter.limit">#&nbsp;&nbsp</a>

        <span class="name">limit</span><span class="annotation">: int</span>
    </div>

            <div class="docstring"><p>The maximum number of <code><a href="#WindowedBurstRateLimiter.acquire">WindowedBurstRateLimiter.acquire</a></code>'s allowed in
this time window.</p>
</div>


                        </div>
                        <div id="WindowedBurstRateLimiter.acquire" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#WindowedBurstRateLimiter.acquire">#&nbsp;&nbsp</a>

        
            <span class="def">async def</span>
            <span class="name">acquire</span><span class="signature">(self) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">async</span> <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Acquire time on this rate limiter.</span>

<span class="sd">        Calling this function will cause it to block until you are not longer</span>
<span class="sd">        being rate limited.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>
        <span class="n">future</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>

        <span class="c1"># If we are rate limited, delegate invoking this to the throttler and spin it up</span>
        <span class="c1"># if it hasn&#39;t started. Likewise, if the throttle task is still running, we should</span>
        <span class="c1"># delegate releasing the future to the throttler task so that we still process</span>
        <span class="c1"># first-come-first-serve</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_rate_limited</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">throttle</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">drip</span><span class="p">()</span>
            <span class="n">future</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">await</span> <span class="n">future</span>
</pre></div>

        </details>

            <div class="docstring"><p>Acquire time on this rate limiter.</p>

<p>Calling this function will cause it to block until you are not longer
being rate limited.</p>
</div>


                        </div>
                        <div id="WindowedBurstRateLimiter.get_time_until_reset" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#WindowedBurstRateLimiter.get_time_until_reset">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_time_until_reset</span><span class="signature">(self, now: float) -&gt; float</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_time_until_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">now</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Determine how long until the current rate limit is reset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        now : float</span>
<span class="sd">            The monotonic `time.monotonic_timestamp` timestamp.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Invoking this method will update the internal state if we were</span>
<span class="sd">            previously rate limited, but at the given time are no longer under</span>
<span class="sd">            that limit. This makes it imperative that you only pass the current</span>
<span class="sd">            timestamp to this function, and not past or future timestamps. The</span>
<span class="sd">            effects of doing the latter are undefined behaviour.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The time left to sleep before the rate limit is reset. If no rate limit</span>
<span class="sd">            is in effect, then this will return `0.0` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_rate_limited</span><span class="p">(</span><span class="n">now</span><span class="p">):</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">-</span> <span class="n">now</span>
</pre></div>

        </details>

            <div class="docstring"><p>Determine how long until the current rate limit is reset.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>now</strong> (float):
The monotonic <code>time.monotonic_timestamp</code> timestamp.</li>
<li><p><strong><em>Warning</strong> (</em>):</p></li>
<li><p><strong>Invoking this method will update the internal state if we were</strong></p></li>
<li><strong>previously rate limited, but at the given time are no longer under</strong></li>
<li><strong>that limit. This makes it imperative that you only pass the current</strong></li>
<li><strong>timestamp to this function, and not past or future timestamps. The</strong></li>
<li><strong>effects of doing the latter are undefined behaviour.</strong></li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>float</strong>: The time left to sleep before the rate limit is reset. If no rate limit
is in effect, then this will return <code>0.0</code> instead.</li>
</ul>
</div>


                        </div>
                        <div id="WindowedBurstRateLimiter.is_rate_limited" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#WindowedBurstRateLimiter.is_rate_limited">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">is_rate_limited</span><span class="signature">(self, now: float) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">is_rate_limited</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">now</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Determine if we are under a rate limit at the given time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        now : float</span>
<span class="sd">            The monotonic `time.monotonic_timestamp` timestamp.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            `True` if we are being rate limited, or `False` if</span>
<span class="sd">            we are not.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Invoking this method will update the internal state if we were</span>
<span class="sd">            previously rate limited, but at the given time are no longer under</span>
<span class="sd">            that limit. This makes it imperative that you only pass the current</span>
<span class="sd">            timestamp to this function, and not past or future timestamps. The</span>
<span class="sd">            effects of doing the latter are undefined behaviour.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">&lt;=</span> <span class="n">now</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remaining</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limit</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset_at</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remaining</span> <span class="o">&lt;=</span> <span class="mi">0</span>
</pre></div>

        </details>

            <div class="docstring"><p>Determine if we are under a rate limit at the given time.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>now</strong> (float):
The monotonic <code>time.monotonic_timestamp</code> timestamp.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>bool</strong>: <code>True</code> if we are being rate limited, or <code>False</code> if
we are not.</li>
<li><p><strong><em>Warning</strong> (</em>):</p></li>
<li><p><strong>Invoking this method will update the internal state if we were</strong></p></li>
<li><strong>previously rate limited, but at the given time are no longer under</strong></li>
<li><strong>that limit. This makes it imperative that you only pass the current</strong></li>
<li><strong>timestamp to this function, and not past or future timestamps. The</strong></li>
<li><strong>effects of doing the latter are undefined behaviour.</strong></li>
</ul>
</div>


                        </div>
                        <div id="WindowedBurstRateLimiter.drip" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#WindowedBurstRateLimiter.drip">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">drip</span><span class="signature">(self) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">drip</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Decrements the remaining counter.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remaining</span> <span class="o">-=</span> <span class="mi">1</span>
</pre></div>

        </details>

            <div class="docstring"><p>Decrements the remaining counter.</p>
</div>


                        </div>
                        <div id="WindowedBurstRateLimiter.throttle" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#WindowedBurstRateLimiter.throttle">#&nbsp;&nbsp</a>

        
            <span class="def">async def</span>
            <span class="name">throttle</span><span class="signature">(self) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">async</span> <span class="k">def</span> <span class="nf">throttle</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Perform the throttling rate limiter logic.</span>

<span class="sd">        Iterates repeatedly while the queue is not empty, adhering to any</span>
<span class="sd">        rate limits that occur in the mean time.</span>

<span class="sd">        .. note::</span>
<span class="sd">            You should usually not need to invoke this directly, but if you do,</span>
<span class="sd">            ensure to call it using `asyncio.create_task`, and store the</span>
<span class="sd">            task immediately in `throttle_task`.</span>

<span class="sd">            When this coroutine function completes, it will set the</span>
<span class="sd">            `throttle_task` to `None`. This means you can check if throttling</span>
<span class="sd">            is occurring by checking if `throttle_task` is not `None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_LOGGER</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;you are being rate limited on bucket </span><span class="si">%s</span><span class="s2">, backing off for </span><span class="si">%s</span><span class="s2">s&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_time_until_reset</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()),</span>
        <span class="p">)</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">:</span>
            <span class="n">sleep_for</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_time_until_reset</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">())</span>
            <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">sleep_for</span><span class="p">)</span>

            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">remaining</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">drip</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">throttle_task</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>

        </details>

            <div class="docstring"><p>Perform the throttling rate limiter logic.</p>

<p>Iterates repeatedly while the queue is not empty, adhering to any
rate limits that occur in the mean time.</p>

<p><em>Note:</em>
You should usually not need to invoke this directly, but if you do,
ensure to call it using <code>asyncio.create_task</code>, and store the
task immediately in <code><a href="#WindowedBurstRateLimiter.throttle_task">throttle_task</a></code>.</p>

<p>When this coroutine function completes, it will set the
<code><a href="#WindowedBurstRateLimiter.throttle_task">throttle_task</a></code> to <code>None</code>. This means you can check if throttling
is occurring by checking if <code><a href="#WindowedBurstRateLimiter.throttle_task">throttle_task</a></code> is not <code>None</code>.</p>
</div>


                        </div>
                        <div class="inherited">
                            <h5>Inherited Members</h5>
                            <dl>
                                <div><dt><a href="#BurstRateLimiter">BurstRateLimiter</a></dt>
            <dd id="WindowedBurstRateLimiter.name" class="variable"><a href="#BurstRateLimiter.name">name</a></dd>
    <dd id="WindowedBurstRateLimiter.queue" class="variable"><a href="#BurstRateLimiter.queue">queue</a></dd>
    <dd id="WindowedBurstRateLimiter.close" class="function"><a href="#BurstRateLimiter.close">close</a></dd>
    <dd id="WindowedBurstRateLimiter.is_empty" class="variable"><a href="#BurstRateLimiter.is_empty">is_empty</a></dd>

    </div>
                            </dl>
                        </div>
            </section>
            <section id="ExponentialBackOff">
                    
            <div class="attr class">
        <a class="headerlink" href="#ExponentialBackOff">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">ExponentialBackOff</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">ExponentialBackOff</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Implementation of an asyncio-compatible exponential back-off algorithm with random jitter.</span>

<span class="sd">    .. math::</span>

<span class="sd">        t_{backoff} = b^{i} +  m \cdot \mathrm{rand}()</span>

<span class="sd">    Such that \(t_{backoff}\) is the backoff time, \(b\) is the base,</span>
<span class="sd">    \(i\) is the increment that increases by 1 for each invocation, and</span>
<span class="sd">    \(m\) is the jitter multiplier. \(\mathrm{rand}()\) returns a value in</span>
<span class="sd">    the range \([0,1]\).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    base : float</span>
<span class="sd">        The base to use. Defaults to `2.0`.</span>
<span class="sd">    maximum : float</span>
<span class="sd">        The max value the backoff can be in a single iteration. Anything above</span>
<span class="sd">        this will be capped to this base value plus random jitter.</span>
<span class="sd">    jitter_multiplier : float</span>
<span class="sd">        The multiplier for the random jitter. Defaults to `1.0`.</span>
<span class="sd">        Set to `0` to disable jitter.</span>
<span class="sd">    initial_increment : int</span>
<span class="sd">        The initial increment to start at. Defaults to `0`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If an `int` that&#39;s too big to be represented as a</span>
<span class="sd">        `float` or a non-finite value is passed in place of a field</span>
<span class="sd">        that&#39;s annotated as `float`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;base&quot;</span><span class="p">,</span> <span class="s2">&quot;increment&quot;</span><span class="p">,</span> <span class="s2">&quot;maximum&quot;</span><span class="p">,</span> <span class="s2">&quot;jitter_multiplier&quot;</span><span class="p">)</span>

    <span class="n">base</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Final</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;The base to use. Defaults to 2.0.&quot;&quot;&quot;</span>

    <span class="n">increment</span><span class="p">:</span> <span class="nb">int</span>
    <span class="sd">&quot;&quot;&quot;The current increment.&quot;&quot;&quot;</span>

    <span class="n">maximum</span><span class="p">:</span> <span class="nb">float</span>
    <span class="sd">&quot;&quot;&quot;This is the max value the backoff can be in a single iteration before an</span>
<span class="sd">    `asyncio.TimeoutError` is raised.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">jitter_multiplier</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Final</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;The multiplier for the random jitter.</span>

<span class="sd">    This defaults to `1.0`. Set to `0.0` to disable jitter.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">base</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="n">maximum</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">64.0</span><span class="p">,</span>
        <span class="n">jitter_multiplier</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">initial_increment</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># https://mypy.readthedocs.io/en/stable/duck_type_compatibility.html</span>
        <span class="c1"># Mypy makes the assumption that ints will always be compatible with floats, this isn&#39;t the case and could lead</span>
        <span class="c1"># to some edge cases that we&#39;d be better off catching earlier on by ensuring these values are actually valid</span>
        <span class="c1"># (most notably floats have a system based maximum size whereas integers theoretically don&#39;t with implicit</span>
        <span class="c1"># conversion to a float raising an error if an integer that&#39;s too big to be a float is handled).</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">maximum</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jitter_multiplier</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">jitter_multiplier</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OverflowError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;int too large to be represented as a float&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;base must be a finite number&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maximum</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;maximum must be a finite number&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jitter_multiplier</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jitter_multiplier must be a finite number&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">increment</span> <span class="o">=</span> <span class="n">initial_increment</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the next back off to sleep by.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">increment</span>

            <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This should only be incremented after we verify we haven&#39;t hit the maximum value.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">increment</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">OverflowError</span><span class="p">:</span>
            <span class="c1"># If this happened then we can be sure that we&#39;ve passed maximum.</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span>

        <span class="k">return</span> <span class="n">value</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">jitter_multiplier</span>  <span class="c1"># nosec  # noqa S311 rng for cryptography</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ExponentialBackOff</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return this object, as it is an iterator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Reset the exponential back-off.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">increment</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>

        </details>

            <div class="docstring"><p>Implementation of an asyncio-compatible exponential back-off algorithm with random jitter.</p>

<p>$$t_{backoff} = b^{i} +  m \cdot \mathrm{rand}()$$</p>

<p>Such that (t_{backoff}) is the backoff time, (b) is the base,
(i) is the increment that increases by 1 for each invocation, and
(m) is the jitter multiplier. (\mathrm{rand}()) returns a value in
the range ([0,1]).</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>base</strong> (float):
The base to use. Defaults to <code>2.0</code>.</li>
<li><strong>maximum</strong> (float):
The max value the backoff can be in a single iteration. Anything above
this will be capped to this base value plus random jitter.</li>
<li><strong>jitter_multiplier</strong> (float):
The multiplier for the random jitter. Defaults to <code>1.0</code>.
Set to <code>0</code> to disable jitter.</li>
<li><strong>initial_increment</strong> (int):
The initial increment to start at. Defaults to <code>0</code>.</li>
</ul>

<h6 id="raises">Raises</h6>

<ul>
<li><strong>ValueError</strong>: If an <code>int</code> that's too big to be represented as a
<code>float</code> or a non-finite value is passed in place of a field
that's annotated as <code>float</code>.</li>
</ul>
</div>


                        <div id="ExponentialBackOff.__init__" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#ExponentialBackOff.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">ExponentialBackOff</span><span class="signature">(
    base: float = 2.0,
    maximum: float = 64.0,
    jitter_multiplier: float = 1.0,
    initial_increment: int = 0
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">base</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="n">maximum</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">64.0</span><span class="p">,</span>
        <span class="n">jitter_multiplier</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">initial_increment</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># https://mypy.readthedocs.io/en/stable/duck_type_compatibility.html</span>
        <span class="c1"># Mypy makes the assumption that ints will always be compatible with floats, this isn&#39;t the case and could lead</span>
        <span class="c1"># to some edge cases that we&#39;d be better off catching earlier on by ensuring these values are actually valid</span>
        <span class="c1"># (most notably floats have a system based maximum size whereas integers theoretically don&#39;t with implicit</span>
        <span class="c1"># conversion to a float raising an error if an integer that&#39;s too big to be a float is handled).</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">maximum</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jitter_multiplier</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">jitter_multiplier</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OverflowError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;int too large to be represented as a float&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;base must be a finite number&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maximum</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;maximum must be a finite number&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jitter_multiplier</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jitter_multiplier must be a finite number&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">increment</span> <span class="o">=</span> <span class="n">initial_increment</span>
</pre></div>

        </details>

    

                        </div>
                        <div id="ExponentialBackOff.base" class="classattr">
                                
            <div class="attr variable"><a class="headerlink" href="#ExponentialBackOff.base">#&nbsp;&nbsp</a>

        <span class="name">base</span><span class="annotation">: Final[float]</span>
    </div>

            <div class="docstring"><p>The base to use. Defaults to 2.0.</p>
</div>


                        </div>
                        <div id="ExponentialBackOff.increment" class="classattr">
                                
            <div class="attr variable"><a class="headerlink" href="#ExponentialBackOff.increment">#&nbsp;&nbsp</a>

        <span class="name">increment</span><span class="annotation">: int</span>
    </div>

            <div class="docstring"><p>The current increment.</p>
</div>


                        </div>
                        <div id="ExponentialBackOff.maximum" class="classattr">
                                
            <div class="attr variable"><a class="headerlink" href="#ExponentialBackOff.maximum">#&nbsp;&nbsp</a>

        <span class="name">maximum</span><span class="annotation">: float</span>
    </div>

            <div class="docstring"><p>This is the max value the backoff can be in a single iteration before an
<code>asyncio.TimeoutError</code> is raised.</p>
</div>


                        </div>
                        <div id="ExponentialBackOff.jitter_multiplier" class="classattr">
                                
            <div class="attr variable"><a class="headerlink" href="#ExponentialBackOff.jitter_multiplier">#&nbsp;&nbsp</a>

        <span class="name">jitter_multiplier</span><span class="annotation">: Final[float]</span>
    </div>

            <div class="docstring"><p>The multiplier for the random jitter.</p>

<p>This defaults to <code>1.0</code>. Set to <code>0.0</code> to disable jitter.</p>
</div>


                        </div>
                        <div id="ExponentialBackOff.reset" class="classattr">
                                
        <div class="attr function"><a class="headerlink" href="#ExponentialBackOff.reset">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">reset</span><span class="signature">(self) -&gt; None</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Reset the exponential back-off.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">increment</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>

        </details>

            <div class="docstring"><p>Reset the exponential back-off.</p>
</div>


                        </div>
            </section>
    </main>
    <script src="../../../version_switcher.js"></script>
    <script>
        "use strict";
        const html = document.querySelector("html");
        const sidebarToggle = document.getElementById("sidebar-toggle");

        // Button control
        sidebarToggle.addEventListener('click', function () {
            if (html.classList.contains("sidebar-hidden")) {
                html.classList.remove("sidebar-hidden");
            } else {
                html.classList.add("sidebar-hidden");
            }
        });

        // Swipe controls
        let firstContact = null;

        document.addEventListener('touchstart', function (e) {
            firstContact = {
                x: e.touches[0].clientX,
                time: Date.now()
            };
        }, { passive: true });

        document.addEventListener('touchmove', function (e) {
            if (!firstContact)
                return;
            let curX = e.touches[0].clientX;
            let xDiff = curX - firstContact.x;
            let tDiff = Date.now() - firstContact.time;
            if (tDiff < 300 && Math.abs(xDiff) >= 100) {
                if (xDiff >= 0 && firstContact.x < Math.min(document.body.clientWidth * 0.25, 300)) {
                    html.classList.remove("sidebar-hidden");
                    firstContact = null;
                }
                else if (xDiff < 0 && curX < 150) {
                    html.classList.add("sidebar-hidden");
                    firstContact = null;
                }
            }
        }, { passive: true });
    </script>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "../../search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `../../${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.type) {
                    case "function":
                        heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">(${doc.parameters.join(", ")})</span>`;
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>