<!doctypehtml><html class=sidebar-hidden lang=en><meta charset=utf-8><meta content=width=device-width,initial-scale=1 name=viewport><meta content="pdoc 9.0.1"name=generator><title>hikari.api.rest API documentation</title><meta content=website property=og:type><meta content=https://www.hikari-py.dev/logo.png property=og:image><meta content="hikari.api.rest API documentation"property=og:title><meta content="A Discord Bot framework for modern Python and asyncio built on good intentions"property=og:description><meta content=#ff029a property=theme-color><link rel="shortcut icon"href=https://www.hikari-py.dev/logo.png type=image/png><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.1.3/css/bootstrap-reboot.css integrity=sha512-MiwRA9Okl+Pah06DKec2BuhcKl6RnH8dFrlmosZPAvUuHAx2grCGHC35eXHrQwSIsDOPvwRteRZzRwFU6Qoj7w== referrerpolicy=no-referrer rel=stylesheet><style>:root{--pdoc-background: #212529;--text: #f7f7f7;--muted: #9d9d9d;--link: #DB61D9 ;--link-hover: #3989ff;--code: #333;--accent: #343434;--accent2: #555;--nav-hover: rgba(0, 0, 0, .1);--def: #ff79c6;--name: #61aeee;--annotation: #DE4F91}body{background-color:var(--pdoc-background)}html,body{width:100%;height:100%;overflow-wrap:break-word;scroll-behavior:smooth;font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}@media (max-width: 1079px){:root{--sidebar-width: 26rem}html{font-size:3.5vw}main,header{padding:2rem 3vw 0 1.5rem}html:not(.sidebar-hidden) body{overflow:hidden!important}html:not(.sidebar-hidden) main{pointer-events:none!important}.sidebar-hidden nav{transform:translate(calc(0px - var(--sidebar-width)))}nav{transition:transform .2s}.sidebar-toggle{position:fixed;top:0;bottom:calc(100% - 6rem);left:var(--sidebar-width);border-left:10px solid grey;border-top:5px solid rgba(0,0,0,0);border-bottom:5px solid rgba(0,0,0,0)}}@media (min-width: 1080px){:root{--sidebar-width: clamp(12.5rem, 37vw, 28rem)}html{font-size:1rem}main,header{padding:3rem 4rem 3rem calc(var(--sidebar-width) + 3rem)}}nav{position:fixed;left:0;top:0;bottom:0;height:100vh;width:var(--sidebar-width);z-index:1}.sidebar{height:100vh;overflow:auto;padding:.5rem 1.5rem 0 1rem;background-color:var(--accent);border-right:1px solid var(--accent2);scrollbar-color:var(--accent2) transparent}::-webkit-scrollbar{width:10px;background:var(--accent) transparent}::-webkit-scrollbar-thumb{-webkit-border-radius:1ex;background:var(--accent2)}.sidebar input[type=search]{display:block;outline-offset:0;width:102%}.sidebar ul{list-style:none;padding-left:1rem}.sidebar li{display:block;margin:0;padding:.2rem 0 .2rem .5rem;transition:all .1s}.sidebar>ul>li{padding-left:0}.sidebar li:hover{background-color:var(--nav-hover)}.sidebar a:hover{color:var(--text)}.sidebar a{display:block}.sidebar a.function,.sidebar a.variable{color:#bd93f9}.sidebar>h2:first-of-type{margin-top:1rem}.sidebar .class:before{content:"class ";color:var(--muted)}.sidebar .function:after{content:"()";color:var(--muted)}.sidebar .sidebar-buttons{display:flex;width:103%;margin-bottom:.5rem;align-items:center}.sidebar .sidebar-buttons .push{margin-left:auto}.svg-button>svg{width:1.7rem;margin:0 .3rem;cursor:pointer}.version-selector{background-color:var(--accent);color:var(--text);border:hidden}.version-selector:disabled{-webkit-appearance:none}.version-warning{background-color:#520000;padding:1rem;margin-right:3rem;text-align:center}.version-warning:empty{display:none}.version-warning a{color:#81d9ff}.version-warning a:hover{color:#00b2ff}nav,main{color:var(--text);box-sizing:border-box;line-height:1.5;background:none}h1,h2,h3{font-weight:300;margin:.3em 0;padding:.2em 0}a{text-decoration:none;color:var(--link)}a:hover{color:var(--link-hover)}blockquote{margin-left:2rem}p{font-weight:300;margin-bottom:.5rem}pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto}code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px}a>code{color:inherit}pre>code{display:inline-block;font-size:inherit;background:none;border:none;padding:0}.modulename{color:var(--annotation);font-weight:bold}.modulename a{color:var(--link);transition:.1s all}.modulename a:hover{filter:brightness(80%)}.git-button{float:right;border:solid var(--link) 1px}.git-button:hover{background-color:var(--link);color:var(--pdoc-background)}details{--shift: -2.4rem;text-align:right;margin-top:var(--shift);margin-bottom:calc(0px - var(--shift));clear:both;filter:opacity(1)}details:not([open]){height:0;overflow:visible}details>summary{font-size:.75rem;cursor:pointer;color:var(--muted);border-width:0;padding:0 1rem;display:inline-block;display:inline list-item;user-select:none}details>summary:focus{outline:0}details>div{margin-top:calc(0px - var(--shift) / 2);text-align:left}.docstring{margin:0 0 2rem 2rem}.docstring pre{margin-left:1em;margin-right:1em}.docstring li{margin-bottom:15px}.docstring li:last-child{margin-bottom:0}span.name{color:#61aeee}span.base{color:#8be9fd}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background-color:var(--accent2);box-shadow:-1rem 0 0 0 var(--accent2)}li strong{color:var(--def)}b,strong{font-weight:bold}em{color:orange}h6{padding-top:1rem;font-size:1.7rem;color:#fff}h6#notes{color:orange}h6#raises{color:#f66}div.decorator{color:#61aeee}div:target>.attr,section:target>.attr,dd:target>a{background-color:var(--accent2)}.inherited dt,.inherited dt:before{color:#61aeee}.attr:hover{filter:contrast(.95)}.headerlink{position:absolute;margin-left:-2.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all .1s ease-in-out;opacity:0}*:hover>.headerlink,*:target>.attr>.headerlink{opacity:1}.attr{display:block;color:var(--text);margin:2rem 0 .5rem 1rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent)}.attr:first-of-type{margin-left:0}.member_divisor{margin-left:3rem}.member_divisor>h5{margin-left:-1rem;font-size:1.5rem;color:#a9a9a9}.member_divisor .attr:first-of-type{margin-top:0}.name{color:var(--name);font-weight:bold}.def{color:var(--def);font-weight:bold}.signature{white-space:pre-wrap}.annotation{color:var(--annotation)}.inherited{margin-left:4rem}.inherited div{margin-left:2rem}.inherited dt{font-weight:700}.inherited dt,.inherited dd{display:inline;margin-left:0;margin-bottom:.5rem}.inherited dd:not(:last-child):after{content:", "}.inherited .class:before{content:"class "}.inherited .function a:after{content:"()"}.search-result .docstring{overflow:auto;max-height:25vh}.search-result.focused>.attr{background-color:var(--accent2)}.attribution{margin-top:2rem;display:block;opacity:.5;transition:all .2s;filter:grayscale(100%)}.attribution:hover{opacity:1;color:#fff}.c{color:#6a7aaa}.err{color:#f55;background-color:#1e0010}.k{color:#ff79c6}.l{color:#ae81ff}.n{color:#f8f8f2}.o{color:#ff79c6}.p{color:#f8f8f2}.ch{color:#6a7aaa}.cm{color:#6a7aaa}.cp{color:#6a7aaa}.cpf{color:#6a7aaa}.c1{color:#6a7aaa}.cs{color:#6a7aaa}.gd{color:#6a7aaa}.ge{font-style:italic}.gi{color:#a6e22e}.go{color:#ff79c6}.gp{color:#f92672;font-weight:bold}.gs{font-weight:bold}.gu{color:#75715e}.kc{color:#ff79c6}.kd{color:#bd93f9}.kn{color:#ff79c6}.kp{color:#bd93f9}.kr{color:#ff79c6}.kt{color:#ff79c6}.ld{color:#e6db74}.m{color:#ae81ff}.s{color:#e6db74}.na{color:#a6e22e}.nb{color:#8be9fd}.nc{color:#e6c07b}.no{color:#ff79c6}.ni{color:#ff79c6}.ne{color:#8be9fd}.nf{color:#61aeee}.nl{color:#f8f8f2}.nn{color:#f8f8f2}.nx{color:#a6e22e}.py{color:#f8f8f2}.nt{color:#f92672}.nv{color:#f8f8f2}.ow{color:#ff79c6}.w{color:#f8f8f2}.mb{color:#ae81ff}.mf{color:#ae81ff}.mh{color:#ae81ff}.mi{color:#ae81ff}.mo{color:#ae81ff}.sa{color:#ff79c6}.sb{color:#e6db74}.sc{color:#e6db74}.dl{color:#e6db74}.sd{color:#6272a4}.s2{color:#e6db74}.se{color:#ae81ff}.sh{color:#e6db74}.si{color:#bd93f9}.sx{color:#e6db74}.sr{color:#e6db74}.s1{color:#e6db74}.ss{color:#e6db74}.bp{color:#bd93f9}.fm{color:#bd93f9}.vc{color:#bd93f9}.vg{color:#f8f8f2}.vi{color:#fff}.vm{color:#bd93f9}.il{color:#ae81ff}.nd{color:#61aeee}.kc{color:#bd93f9}</style><body><nav class=pdoc><div class=sidebar id=sidebar><div class=sidebar-buttons><label>Hikari (<select class=version-selector disabled id=version-selector><option>2.0.0.dev107</select>)</label><div class=push></div><a class=svg-button href=../../index.html><svg viewbox="0 0 576 512"height=32 width=32 xmlns=http://www.w3.org/2000/svg><path d="M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z"fill=#ffffff /></svg></a><a class=svg-button href=https://discord.gg/Jx4cNGG><svg viewbox="0 0 71 55"height=32 width=32 xmlns=http://www.w3.org/2000/svg><path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z"fill=#ffffff /></svg></a><a class=svg-button href=https://github.com/hikari-py/hikari><svg viewbox="0 0 16 16"height=32 width=32 xmlns=http://www.w3.org/2000/svg><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"fill=#ffffff></path></svg></a><a class=svg-button href=https://pypi.org/project/hikari><svg viewbox="0 0 512 512"height=32 width=32 xmlns=http://www.w3.org/2000/svg><path d="M488.6 250.2L392 214V105.5c0-15-9.3-28.4-23.4-33.7l-100-37.5c-8.1-3.1-17.1-3.1-25.3 0l-100 37.5c-14.1 5.3-23.4 18.7-23.4 33.7V214l-96.6 36.2C9.3 255.5 0 268.9 0 283.9V394c0 13.6 7.7 26.1 19.9 32.2l100 50c10.1 5.1 22.1 5.1 32.2 0l103.9-52 103.9 52c10.1 5.1 22.1 5.1 32.2 0l100-50c12.2-6.1 19.9-18.6 19.9-32.2V283.9c0-15-9.3-28.4-23.4-33.7zM358 214.8l-85 31.9v-68.2l85-37v73.3zM154 104.1l102-38.2 102 38.2v.6l-102 41.4-102-41.4v-.6zm84 291.1l-85 42.5v-79.1l85-38.8v75.4zm0-112l-102 41.4-102-41.4v-.6l102-38.2 102 38.2v.6zm240 112l-85 42.5v-79.1l85-38.8v75.4zm0-112l-102 41.4-102-41.4v-.6l102-38.2 102 38.2v.6z"fill=#ffffff /></svg></a></div><input title="Search the documentation"pattern=.+ placeholder=Search... role=searchbox type=search><h2>API Documentation</h2><ul class=memberlist><li><a class=class href=#RESTClient>RESTClient</a> <ul class=memberlist><li><a class=function href=#RESTClient.add_reaction>add_reaction</a><li><a class=function href=#RESTClient.add_role_to_member>add_role_to_member</a><li><a class=function href=#RESTClient.add_user_to_guild>add_user_to_guild</a><li><a class=function href=#RESTClient.authorize_access_token>authorize_access_token</a><li><a class=function href=#RESTClient.authorize_client_credentials_token>authorize_client_credentials_token</a><li><a class=function href=#RESTClient.ban_member>ban_member</a><li><a class=function href=#RESTClient.ban_user>ban_user</a><li><a class=function href=#RESTClient.begin_guild_prune>begin_guild_prune</a><li><a class=function href=#RESTClient.build_action_row>build_action_row</a><li><a class=function href=#RESTClient.close>close</a><li><a class=function href=#RESTClient.command_builder>command_builder</a><li><a class=function href=#RESTClient.context_menu_command_builder>context_menu_command_builder</a><li><a class=function href=#RESTClient.create_application_command>create_application_command</a><li><a class=function href=#RESTClient.create_autocomplete_response>create_autocomplete_response</a><li><a class=function href=#RESTClient.create_context_menu_command>create_context_menu_command</a><li><a class=function href=#RESTClient.create_dm_channel>create_dm_channel</a><li><a class=function href=#RESTClient.create_emoji>create_emoji</a><li><a class=function href=#RESTClient.create_guild_category>create_guild_category</a><li><a class=function href=#RESTClient.create_guild_from_template>create_guild_from_template</a><li><a class=function href=#RESTClient.create_guild_news_channel>create_guild_news_channel</a><li><a class=function href=#RESTClient.create_guild_stage_channel>create_guild_stage_channel</a><li><a class=function href=#RESTClient.create_guild_text_channel>create_guild_text_channel</a><li><a class=function href=#RESTClient.create_guild_voice_channel>create_guild_voice_channel</a><li><a class=function href=#RESTClient.create_interaction_response>create_interaction_response</a><li><a class=function href=#RESTClient.create_invite>create_invite</a><li><a class=function href=#RESTClient.create_message>create_message</a><li><a class=function href=#RESTClient.create_role>create_role</a><li><a class=function href=#RESTClient.create_slash_command>create_slash_command</a><li><a class=function href=#RESTClient.create_sticker>create_sticker</a><li><a class=function href=#RESTClient.create_template>create_template</a><li><a class=function href=#RESTClient.create_webhook>create_webhook</a><li><a class=function href=#RESTClient.crosspost_message>crosspost_message</a><li><a class=function href=#RESTClient.delete_all_reactions>delete_all_reactions</a><li><a class=function href=#RESTClient.delete_all_reactions_for_emoji>delete_all_reactions_for_emoji</a><li><a class=function href=#RESTClient.delete_application_command>delete_application_command</a><li><a class=function href=#RESTClient.delete_channel>delete_channel</a><li><a class=function href=#RESTClient.delete_emoji>delete_emoji</a><li><a class=function href=#RESTClient.delete_guild>delete_guild</a><li><a class=function href=#RESTClient.delete_interaction_response>delete_interaction_response</a><li><a class=function href=#RESTClient.delete_invite>delete_invite</a><li><a class=function href=#RESTClient.delete_message>delete_message</a><li><a class=function href=#RESTClient.delete_messages>delete_messages</a><li><a class=function href=#RESTClient.delete_my_reaction>delete_my_reaction</a><li><a class=function href=#RESTClient.delete_permission_overwrite>delete_permission_overwrite</a><li><a class=function href=#RESTClient.delete_reaction>delete_reaction</a><li><a class=function href=#RESTClient.delete_role>delete_role</a><li><a class=function href=#RESTClient.delete_sticker>delete_sticker</a><li><a class=function href=#RESTClient.delete_template>delete_template</a><li><a class=function href=#RESTClient.delete_webhook>delete_webhook</a><li><a class=function href=#RESTClient.delete_webhook_message>delete_webhook_message</a><li><a class=function href=#RESTClient.edit_application_command>edit_application_command</a><li><a class=function href=#RESTClient.edit_channel>edit_channel</a><li><a class=function href=#RESTClient.edit_emoji>edit_emoji</a><li><a class=function href=#RESTClient.edit_guild>edit_guild</a><li><a class=function href=#RESTClient.edit_interaction_response>edit_interaction_response</a><li><a class=function href=#RESTClient.edit_member>edit_member</a><li><a class=function href=#RESTClient.edit_message>edit_message</a><li><a class=function href=#RESTClient.edit_my_member>edit_my_member</a><li><a class=function href=#RESTClient.edit_my_nick>edit_my_nick</a><li><a class=function href=#RESTClient.edit_my_user>edit_my_user</a><li><a class=function href=#RESTClient.edit_my_voice_state>edit_my_voice_state</a><li><a class=function href=#RESTClient.edit_permission_overwrites>edit_permission_overwrites</a><li><a class=function href=#RESTClient.edit_role>edit_role</a><li><a class=function href=#RESTClient.edit_sticker>edit_sticker</a><li><a class=function href=#RESTClient.edit_template>edit_template</a><li><a class=function href=#RESTClient.edit_voice_state>edit_voice_state</a><li><a class=function href=#RESTClient.edit_webhook>edit_webhook</a><li><a class=function href=#RESTClient.edit_webhook_message>edit_webhook_message</a><li><a class=function href=#RESTClient.edit_welcome_screen>edit_welcome_screen</a><li><a class=function href=#RESTClient.edit_widget>edit_widget</a><li><a class=variable href=#RESTClient.entity_factory>entity_factory</a><li><a class=function href=#RESTClient.estimate_guild_prune_count>estimate_guild_prune_count</a><li><a class=function href=#RESTClient.execute_webhook>execute_webhook</a><li><a class=function href=#RESTClient.fetch_application>fetch_application</a><li><a class=function href=#RESTClient.fetch_application_command>fetch_application_command</a><li><a class=function href=#RESTClient.fetch_application_command_permissions>fetch_application_command_permissions</a><li><a class=function href=#RESTClient.fetch_application_commands>fetch_application_commands</a><li><a class=function href=#RESTClient.fetch_application_guild_commands_permissions>fetch_application_guild_commands_permissions</a><li><a class=function href=#RESTClient.fetch_audit_log>fetch_audit_log</a><li><a class=function href=#RESTClient.fetch_authorization>fetch_authorization</a><li><a class=function href=#RESTClient.fetch_available_sticker_packs>fetch_available_sticker_packs</a><li><a class=function href=#RESTClient.fetch_ban>fetch_ban</a><li><a class=function href=#RESTClient.fetch_bans>fetch_bans</a><li><a class=function href=#RESTClient.fetch_channel>fetch_channel</a><li><a class=function href=#RESTClient.fetch_channel_invites>fetch_channel_invites</a><li><a class=function href=#RESTClient.fetch_channel_webhooks>fetch_channel_webhooks</a><li><a class=function href=#RESTClient.fetch_emoji>fetch_emoji</a><li><a class=function href=#RESTClient.fetch_gateway_bot_info>fetch_gateway_bot_info</a><li><a class=function href=#RESTClient.fetch_gateway_url>fetch_gateway_url</a><li><a class=function href=#RESTClient.fetch_guild>fetch_guild</a><li><a class=function href=#RESTClient.fetch_guild_channels>fetch_guild_channels</a><li><a class=function href=#RESTClient.fetch_guild_emojis>fetch_guild_emojis</a><li><a class=function href=#RESTClient.fetch_guild_invites>fetch_guild_invites</a><li><a class=function href=#RESTClient.fetch_guild_preview>fetch_guild_preview</a><li><a class=function href=#RESTClient.fetch_guild_sticker>fetch_guild_sticker</a><li><a class=function href=#RESTClient.fetch_guild_stickers>fetch_guild_stickers</a><li><a class=function href=#RESTClient.fetch_guild_templates>fetch_guild_templates</a><li><a class=function href=#RESTClient.fetch_guild_voice_regions>fetch_guild_voice_regions</a><li><a class=function href=#RESTClient.fetch_guild_webhooks>fetch_guild_webhooks</a><li><a class=function href=#RESTClient.fetch_integrations>fetch_integrations</a><li><a class=function href=#RESTClient.fetch_interaction_response>fetch_interaction_response</a><li><a class=function href=#RESTClient.fetch_invite>fetch_invite</a><li><a class=function href=#RESTClient.fetch_member>fetch_member</a><li><a class=function href=#RESTClient.fetch_members>fetch_members</a><li><a class=function href=#RESTClient.fetch_message>fetch_message</a><li><a class=function href=#RESTClient.fetch_messages>fetch_messages</a><li><a class=function href=#RESTClient.fetch_my_connections>fetch_my_connections</a><li><a class=function href=#RESTClient.fetch_my_guilds>fetch_my_guilds</a><li><a class=function href=#RESTClient.fetch_my_member>fetch_my_member</a><li><a class=function href=#RESTClient.fetch_my_user>fetch_my_user</a><li><a class=function href=#RESTClient.fetch_pins>fetch_pins</a><li><a class=function href=#RESTClient.fetch_reactions_for_emoji>fetch_reactions_for_emoji</a><li><a class=function href=#RESTClient.fetch_roles>fetch_roles</a><li><a class=function href=#RESTClient.fetch_sticker>fetch_sticker</a><li><a class=function href=#RESTClient.fetch_template>fetch_template</a><li><a class=function href=#RESTClient.fetch_user>fetch_user</a><li><a class=function href=#RESTClient.fetch_vanity_url>fetch_vanity_url</a><li><a class=function href=#RESTClient.fetch_voice_regions>fetch_voice_regions</a><li><a class=function href=#RESTClient.fetch_webhook>fetch_webhook</a><li><a class=function href=#RESTClient.fetch_webhook_message>fetch_webhook_message</a><li><a class=function href=#RESTClient.fetch_welcome_screen>fetch_welcome_screen</a><li><a class=function href=#RESTClient.fetch_widget>fetch_widget</a><li><a class=function href=#RESTClient.follow_channel>follow_channel</a><li><a class=function href=#RESTClient.guild_builder>guild_builder</a><li><a class=variable href=#RESTClient.http_settings>http_settings</a><li><a class=function href=#RESTClient.interaction_autocomplete_builder>interaction_autocomplete_builder</a><li><a class=function href=#RESTClient.interaction_deferred_builder>interaction_deferred_builder</a><li><a class=function href=#RESTClient.interaction_message_builder>interaction_message_builder</a><li><a class=variable href=#RESTClient.is_alive>is_alive</a><li><a class=function href=#RESTClient.kick_member>kick_member</a><li><a class=function href=#RESTClient.kick_user>kick_user</a><li><a class=function href=#RESTClient.leave_guild>leave_guild</a><li><a class=function href=#RESTClient.pin_message>pin_message</a><li><a class=variable href=#RESTClient.proxy_settings>proxy_settings</a><li><a class=function href=#RESTClient.refresh_access_token>refresh_access_token</a><li><a class=function href=#RESTClient.remove_role_from_member>remove_role_from_member</a><li><a class=function href=#RESTClient.reposition_channels>reposition_channels</a><li><a class=function href=#RESTClient.reposition_roles>reposition_roles</a><li><a class=function href=#RESTClient.revoke_access_token>revoke_access_token</a><li><a class=function href=#RESTClient.search_members>search_members</a><li><a class=function href=#RESTClient.set_application_command_permissions>set_application_command_permissions</a><li><a class=function href=#RESTClient.set_application_commands>set_application_commands</a><li><a class=function href=#RESTClient.set_application_guild_commands_permissions>set_application_guild_commands_permissions</a><li><a class=function href=#RESTClient.slash_command_builder>slash_command_builder</a><li><a class=function href=#RESTClient.sync_guild_template>sync_guild_template</a><li><a class=variable href=#RESTClient.token_type>token_type</a><li><a class=function href=#RESTClient.trigger_typing>trigger_typing</a><li><a class=function href=#RESTClient.unban_member>unban_member</a><li><a class=function href=#RESTClient.unban_user>unban_user</a><li><a class=function href=#RESTClient.unpin_message>unpin_message</a></ul><li><a class=class href=#TokenStrategy>TokenStrategy</a> <ul class=memberlist><li><a class=function href=#TokenStrategy.acquire>acquire</a><li><a class=function href=#TokenStrategy.invalidate>invalidate</a><li><a class=variable href=#TokenStrategy.token_type>token_type</a></ul></ul><a class=attribution href=https://pdoc.dev>built with pdoc v9.0.1</a></div><div class=sidebar-toggle id=sidebar-toggle></div></nav><main class=pdoc><div class=version-warning id=version-warning></div><section><h1 class=modulename><a href=./../../index.html>hikari</a><wbr>.<a href=./../api.html>api</a><wbr>.rest</h1><div class=docstring><p>Provides an interface for REST API implementations to follow.</div><details><summary>View Source</summary> <div class=codehilite><pre><span></span><span class=c1># -*- coding: utf-8 -*-</span>
<span class=c1># cython: language_level=3</span>
<span class=c1># Copyright (c) 2020 Nekokatt</span>
<span class=c1># Copyright (c) 2021-present davfsa</span>
<span class=c1>#</span>
<span class=c1># Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class=c1># of this software and associated documentation files (the "Software"), to deal</span>
<span class=c1># in the Software without restriction, including without limitation the rights</span>
<span class=c1># to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class=c1># copies of the Software, and to permit persons to whom the Software is</span>
<span class=c1># furnished to do so, subject to the following conditions:</span>
<span class=c1>#</span>
<span class=c1># The above copyright notice and this permission notice shall be included in all</span>
<span class=c1># copies or substantial portions of the Software.</span>
<span class=c1>#</span>
<span class=c1># THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class=c1># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class=c1># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class=c1># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class=c1># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class=c1># OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class=c1># SOFTWARE.</span>
<span class=sd>"""Provides an interface for REST API implementations to follow."""</span>
<span class=kn>from</span> <span class=nn>__future__</span> <span class=kn>import</span> <span class=n>annotations</span>

<span class=n>__all__</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>List</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span><span class=s2>"RESTClient"</span><span class=p>,</span> <span class=s2>"TokenStrategy"</span><span class=p>]</span>

<span class=kn>import</span> <span class=nn>abc</span>
<span class=kn>import</span> <span class=nn>typing</span>

<span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>traits</span>
<span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>undefined</span>
<span class=kn>from</span> <span class=nn>hikari.internal</span> <span class=kn>import</span> <span class=n>deprecation</span>

<span class=k>if</span> <span class=n>typing</span><span class=o>.</span><span class=n>TYPE_CHECKING</span><span class=p>:</span>
    <span class=kn>import</span> <span class=nn>datetime</span>

    <span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>applications</span>
    <span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>audit_logs</span>
    <span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>channels</span> <span class=k>as</span> <span class=n>channels_</span>
    <span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>colors</span>
    <span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>commands</span>
    <span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>embeds</span> <span class=k>as</span> <span class=n>embeds_</span>
    <span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>emojis</span>
    <span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>files</span>
    <span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>guilds</span>
    <span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>invites</span>
    <span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>iterators</span>
    <span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>messages</span> <span class=k>as</span> <span class=n>messages_</span>
    <span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>permissions</span> <span class=k>as</span> <span class=n>permissions_</span>
    <span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>sessions</span>
    <span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>snowflakes</span>
    <span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>stickers</span>
    <span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>templates</span>
    <span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>users</span>
    <span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>voices</span>
    <span class=kn>from</span> <span class=nn>hikari</span> <span class=kn>import</span> <span class=n>webhooks</span>
    <span class=kn>from</span> <span class=nn>hikari.api</span> <span class=kn>import</span> <span class=n>entity_factory</span> <span class=k>as</span> <span class=n>entity_factory_</span>
    <span class=kn>from</span> <span class=nn>hikari.api</span> <span class=kn>import</span> <span class=n>special_endpoints</span>
    <span class=kn>from</span> <span class=nn>hikari.interactions</span> <span class=kn>import</span> <span class=n>base_interactions</span>
    <span class=kn>from</span> <span class=nn>hikari.internal</span> <span class=kn>import</span> <span class=n>time</span>


<span class=k>class</span> <span class=nc>TokenStrategy</span><span class=p>(</span><span class=n>abc</span><span class=o>.</span><span class=n>ABC</span><span class=p>):</span>
    <span class=sd>"""Interface of an object used for managing OAuth2 access."""</span>

    <span class=vm>__slots__</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=p>()</span>

    <span class=nd>@property</span>
    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>token_type</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>applications</span><span class=o>.</span><span class=n>TokenType</span><span class=p>,</span> <span class=nb>str</span><span class=p>]:</span>
        <span class=sd>"""Type of token this strategy returns."""</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>acquire</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>client</span><span class=p>:</span> <span class=n>RESTClient</span><span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>
        <span class=sd>"""Acquire an authorization token (including the prefix).</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        str</span>
<span class=sd>            The current authorization token to use for this client and it's</span>
<span class=sd>            prefix.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>invalidate</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>token</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=nb>str</span><span class=p>])</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Invalidate the cached token in this handler.</span>

<span class=sd>        .. note::</span>
<span class=sd>            `token` may be provided in-order to avoid newly generated tokens</span>
<span class=sd>            from being invalidated due to multiple calls being made by separate</span>
<span class=sd>            subroutines which are handling the same token.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        token : typing.Optional[str]</span>
<span class=sd>            The token to specifically invalidate. If provided then this will only</span>
<span class=sd>            invalidate the cached token if it matches this, otherwise it'll be</span>
<span class=sd>            invalidated regardless.</span>
<span class=sd>        """</span>


<span class=k>class</span> <span class=nc>RESTClient</span><span class=p>(</span><span class=n>traits</span><span class=o>.</span><span class=n>NetworkSettingsAware</span><span class=p>,</span> <span class=n>abc</span><span class=o>.</span><span class=n>ABC</span><span class=p>):</span>
    <span class=sd>"""Interface for functionality that a REST API implementation provides."""</span>

    <span class=vm>__slots__</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=p>()</span>

    <span class=nd>@property</span>
    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>is_alive</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=nb>bool</span><span class=p>:</span>
        <span class=sd>"""Whether this component is alive."""</span>

    <span class=nd>@property</span>
    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>entity_factory</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>entity_factory_</span><span class=o>.</span><span class=n>EntityFactory</span><span class=p>:</span>
        <span class=sd>"""Entity factory used by this REST client."""</span>

    <span class=nd>@property</span>
    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>token_type</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>applications</span><span class=o>.</span><span class=n>TokenType</span><span class=p>,</span> <span class=kc>None</span><span class=p>]:</span>
        <span class=sd>"""Type of token this client is using for most requests.</span>

<span class=sd>        If this is `None` then this client will likely only work</span>
<span class=sd>        for some endpoints such as public and webhook ones.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>close</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Close the client session."""</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PartialChannel</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>PartialChannel</span><span class=p>:</span>
        <span class=sd>"""Fetch a channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel]</span>
<span class=sd>            The channel to fetch. This may be the object or the ID of an</span>
<span class=sd>            existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.PartialChannel</span>
<span class=sd>            The channel. This will be a _derivative_ of</span>
<span class=sd>            `hikari.channels.PartialChannel`, depending on the type of</span>
<span class=sd>            channel you request for.</span>

<span class=sd>            This means that you may get one of</span>
<span class=sd>            `hikari.channels.DMChannel`,</span>
<span class=sd>            `hikari.channels.GroupDMChannel`,</span>
<span class=sd>            `hikari.channels.GuildTextChannel`,</span>
<span class=sd>            `hikari.channels.GuildVoiceChannel`,</span>
<span class=sd>            `hikari.channels.GuildStoreChannel`,</span>
<span class=sd>            `hikari.channels.GuildNewsChannel`.</span>

<span class=sd>            Likewise, the `hikari.channels.GuildChannel` can be used to</span>
<span class=sd>            determine if a channel is guild-bound, and</span>
<span class=sd>            `hikari.channels.TextableChannel` can be used to determine</span>
<span class=sd>            if the channel provides textual functionality to the application.</span>

<span class=sd>            You can check for these using the `isinstance`</span>
<span class=sd>            builtin function.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `READ_MESSAGES` permission in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>],</span>
        <span class=o>/</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>position</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>topic</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>nsfw</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>bitrate</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>video_quality_mode</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>VideoQualityMode</span><span class=p>,</span> <span class=nb>int</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_limit</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>rate_limit_per_user</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>time</span><span class=o>.</span><span class=n>Intervalish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>region</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>voices</span><span class=o>.</span><span class=n>VoiceRegion</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permission_overwrites</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>parent_category</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildCategory</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>PartialChannel</span><span class=p>:</span>
        <span class=sd>"""Edit a channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]</span>
<span class=sd>            The channel to edit. This may be the object or the ID of an</span>
<span class=sd>            existing channel.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[[str]</span>
<span class=sd>            If provided, the new name for the channel.</span>
<span class=sd>        position : hikari.undefined.UndefinedOr[[int]</span>
<span class=sd>            If provided, the new position for the channel.</span>
<span class=sd>        topic : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new topic for the channel.</span>
<span class=sd>        nsfw : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the channel should be marked as NSFW or not.</span>
<span class=sd>        bitrate : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the new bitrate for the channel.</span>
<span class=sd>        video_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, int]]</span>
<span class=sd>            If provided, the new video quality mode for the channel.</span>
<span class=sd>        user_limit : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the new user limit in the channel.</span>
<span class=sd>        rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]</span>
<span class=sd>            If provided, the new rate limit per user in the channel.</span>
<span class=sd>        region : hikari.undefined.UndefinedOr[typing.Union[str, hikari.voices.VoiceRegion]]</span>
<span class=sd>            If provided, the voice region to set for this channel. Passing</span>
<span class=sd>            `None` here will set it to "auto" mode where the used</span>
<span class=sd>            region will be decided based on the first person who connects to it</span>
<span class=sd>            when it's empty.</span>
<span class=sd>        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]</span>
<span class=sd>            If provided, the new permission overwrites for the channel.</span>
<span class=sd>        parent_category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]</span>
<span class=sd>            If provided, the new guild category for the channel.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.PartialChannel</span>
<span class=sd>            The edited channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing permissions to edit the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>follow_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>news_channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildNewsChannel</span><span class=p>],</span>
        <span class=n>target_channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>ChannelFollow</span><span class=p>:</span>
        <span class=sd>"""Follow a news channel to send messages to a target channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        news_channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildNewsChannel]</span>
<span class=sd>            The object or ID of the news channel to follow.</span>
<span class=sd>        target_channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]</span>
<span class=sd>            The object or ID of the channel to target.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.ChannelFollow</span>
<span class=sd>            Information about the new relationship that was made.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If you try to follow a channel that's not a news channel or if the</span>
<span class=sd>            target channel has reached it's webhook limit, which is 10 at the</span>
<span class=sd>            time of writing.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_WEBHOOKS` permission in the target</span>
<span class=sd>            channel or are missing the `VIEW_CHANNEL` permission in the origin</span>
<span class=sd>            channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the origin or target channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PartialChannel</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>PartialChannel</span><span class=p>:</span>
        <span class=sd>"""Delete a channel in a guild, or close a DM.</span>

<span class=sd>        .. note::</span>
<span class=sd>            For Public servers, the set 'Rules' or 'Guidelines' channels and the</span>
<span class=sd>            'Public Server Updates' channel cannot be deleted.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel]</span>
<span class=sd>            The channel to delete. This may be the object or the ID of an</span>
<span class=sd>            existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.PartialChannel</span>
<span class=sd>            Object of the channel that was deleted.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_my_voice_state</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildStageChannel</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>suppress</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>request_to_speak</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedType</span><span class=p>,</span> <span class=nb>bool</span><span class=p>,</span> <span class=n>datetime</span><span class=o>.</span><span class=n>datetime</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Edit the current user's voice state in a stage channel.</span>

<span class=sd>        .. note::</span>
<span class=sd>            The current user has to have already joined the target stage channel</span>
<span class=sd>            before any calls can be made to this endpoint.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or Id of the guild to edit a voice state in.</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildStageChannel]</span>
<span class=sd>            Object or Id of the channel to edit a voice state in.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        suppress : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If specified, whether the user should be allowed to become a speaker</span>
<span class=sd>            in the target stage channel with `builtin.True` suppressing them from</span>
<span class=sd>            becoming one.</span>
<span class=sd>        request_to_speak : typing.Union[hikari.undefined.UndefinedType, bool, datetime.datetime]</span>
<span class=sd>            Whether to request to speak. This may be one of the following:</span>

<span class=sd>            * `True` to indicate that the bot wants to speak.</span>
<span class=sd>            * `False` to remove any previously set request to speak.</span>
<span class=sd>            * `datetime.datetime` to specify when they want their request to</span>
<span class=sd>                speak timestamp to be set to. If a datetime from the past is</span>
<span class=sd>                passed then Discord will use the current time instead.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If you try to target a non-staging channel.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MUTE_MEMBERS` permission in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel, message or voice state is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_voice_state</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildStageChannel</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>suppress</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Edit an existing voice state in a stage channel.</span>

<span class=sd>        .. note::</span>
<span class=sd>            The target user must already be present in the stage channel before</span>
<span class=sd>            any calls are made to this endpoint.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or Id of the guild to edit a voice state in.</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildStageChannel]</span>
<span class=sd>            Object or Id of the channel to edit a voice state in.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            Object or Id of the user to to edit the voice state of.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        suppress : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If defined, whether the user should be allowed to become a speaker</span>
<span class=sd>            in the target stage channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If you try to target a non-staging channel.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MUTE_MEMBERS` permission in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel, message or voice state is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@typing</span><span class=o>.</span><span class=n>overload</span>
    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_permission_overwrites</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>],</span>
        <span class=n>target</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>,</span> <span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>,</span> <span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>allow</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>permissions_</span><span class=o>.</span><span class=n>Permissions</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>deny</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>permissions_</span><span class=o>.</span><span class=n>Permissions</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Edit permissions for a target entity."""</span>

    <span class=nd>@typing</span><span class=o>.</span><span class=n>overload</span>
    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_permission_overwrites</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>],</span>
        <span class=n>target</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>Snowflakeish</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>target_type</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwriteType</span><span class=p>,</span> <span class=nb>int</span><span class=p>],</span>
        <span class=n>allow</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>permissions_</span><span class=o>.</span><span class=n>Permissions</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>deny</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>permissions_</span><span class=o>.</span><span class=n>Permissions</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Edit permissions for a given entity ID and type."""</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_permission_overwrites</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>],</span>
        <span class=n>target</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>Snowflakeish</span><span class=p>,</span> <span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>,</span> <span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>,</span> <span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span>
        <span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>target_type</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwriteType</span><span class=p>,</span> <span class=nb>int</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>allow</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>permissions_</span><span class=o>.</span><span class=n>Permissions</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>deny</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>permissions_</span><span class=o>.</span><span class=n>Permissions</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Edit permissions for a specific entity in the given guild channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]</span>
<span class=sd>            The channel to edit a permission overwrite in. This may be the</span>
<span class=sd>            object, or the ID of an existing channel.</span>
<span class=sd>        target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish]</span>
<span class=sd>            The channel overwrite to edit. This may be the object or the ID of an</span>
<span class=sd>            existing overwrite.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        target_type : hikari.undefined.UndefinedOr[typing.Union[hikari.channels.PermissionOverwriteType, int]]</span>
<span class=sd>            If provided, the type of the target to update. If unset, will attempt to get</span>
<span class=sd>            the type from `target`.</span>
<span class=sd>        allow : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]</span>
<span class=sd>            If provided, the new vale of all allowed permissions.</span>
<span class=sd>        deny : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]</span>
<span class=sd>            If provided, the new vale of all disallowed permissions.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        TypeError</span>
<span class=sd>            If `target_type` is unset and we were unable to determine the type</span>
<span class=sd>            from `target`.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_PERMISSIONS` permission in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found or the target is not found if it is</span>
<span class=sd>            a role.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_permission_overwrite</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>],</span>
        <span class=n>target</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span>
            <span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>,</span> <span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>,</span> <span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>,</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>Snowflakeish</span>
        <span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a custom permission for an entity in a given guild channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]</span>
<span class=sd>            The channel to delete a permission overwrite in. This may be the</span>
<span class=sd>            object, or the ID of an existing channel.</span>
<span class=sd>        target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish]</span>
<span class=sd>            The channel overwrite to delete.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_PERMISSIONS` permission in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found or the target is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_channel_invites</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>invites</span><span class=o>.</span><span class=n>InviteWithMetadata</span><span class=p>]:</span>
        <span class=sd>"""Fetch all invites pointing to the given guild channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]</span>
<span class=sd>            The channel to fetch the invites from. This may be a channel</span>
<span class=sd>            object, or the ID of an existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.invites.InviteWithMetadata]</span>
<span class=sd>            The invites pointing to the given guild channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found in any guilds you are a member of.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_invite</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>max_age</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>time</span><span class=o>.</span><span class=n>Intervalish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>max_uses</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>temporary</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>unique</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>target_type</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>invites</span><span class=o>.</span><span class=n>TargetType</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>target_user</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>target_application</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>invites</span><span class=o>.</span><span class=n>InviteWithMetadata</span><span class=p>:</span>
        <span class=sd>"""Create an invite to the given guild channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]</span>
<span class=sd>            The channel to create a invite for. This may be the object</span>
<span class=sd>            or the ID of an existing channel.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        max_age : hikari.undefined.UndefinedOr[typing.Union[datetime.timedelta, float, int]]</span>
<span class=sd>            If provided, the duration of the invite before expiry.</span>
<span class=sd>        max_uses : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the max uses the invite can have.</span>
<span class=sd>        temporary : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the invite only grants temporary membership.</span>
<span class=sd>        unique : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the invite should be unique.</span>
<span class=sd>        target_type : hikari.undefined.UndefinedOr[hikari.invites.TargetType]</span>
<span class=sd>            If provided, the target type of this invite.</span>
<span class=sd>        target_user : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]]</span>
<span class=sd>            If provided, the target user id for this invite. This may be the</span>
<span class=sd>            object or the ID of an existing user.</span>

<span class=sd>            .. note::</span>
<span class=sd>                This is required if `target_type` is `STREAM` and the targeted</span>
<span class=sd>                user must be streaming into the channel.</span>
<span class=sd>        target_application : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]]</span>
<span class=sd>            If provided, the target application id for this invite. This may be</span>
<span class=sd>            the object or the ID of an existing application.</span>

<span class=sd>            .. note::</span>
<span class=sd>                This is required if `target_type` is `EMBEDDED_APPLICATION` and</span>
<span class=sd>                the targeted application must have the `EMBEDDED` flag.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.invites.InviteWithMetadata</span>
<span class=sd>            The invite to the given guild channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNELS` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found, or if the target user does not exist,</span>
<span class=sd>            if provided.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>trigger_typing</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>TypingIndicator</span><span class=p>:</span>
        <span class=sd>"""Trigger typing in a text channel.</span>

<span class=sd>        .. note::</span>
<span class=sd>            The result of this call can be awaited to trigger typing once, or</span>
<span class=sd>            can be used as an async context manager to continually type until the</span>
<span class=sd>            context manager is left. Any errors documented below will happen then.</span>

<span class=sd>        Examples</span>
<span class=sd>        --------</span>
<span class=sd>        ```py</span>
<span class=sd>        # Trigger typing just once.</span>
<span class=sd>        await rest.trigger_typing(channel)</span>

<span class=sd>        # Trigger typing repeatedly for 1 minute.</span>
<span class=sd>        async with rest.trigger_typing(channel):</span>
<span class=sd>            await asyncio.sleep(60)</span>
<span class=sd>        ```</span>

<span class=sd>        .. warning::</span>
<span class=sd>            Sending a message to the channel will cause the typing indicator</span>
<span class=sd>            to disappear until it is re-triggered.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to trigger typing in. This may be the object or</span>
<span class=sd>            the ID of an existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.TypingIndicator</span>
<span class=sd>            A typing indicator to use.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `SEND_MESSAGES` in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_pins</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>]:</span>
        <span class=sd>"""Fetch the pinned messages in this text channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to fetch pins from. This may be the object or</span>
<span class=sd>            the ID of an existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.messages.Message]</span>
<span class=sd>            The pinned messages in this text channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `READ_MESSAGES` in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>pin_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Pin an existing message in the given text channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to pin a message in. This may be the object or</span>
<span class=sd>            the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to pin. This may be the object or the ID</span>
<span class=sd>            of an existing message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_MESSAGES` in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found, or if the message does not exist in</span>
<span class=sd>            the given channel.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>unpin_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Unpin a given message from a given text channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to unpin a message in. This may be the object or</span>
<span class=sd>            the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to unpin. This may be the object or the ID of an</span>
<span class=sd>            existing message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_MESSAGES` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found or the message is not a pinned message</span>
<span class=sd>            in the given channel.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>fetch_messages</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>before</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SearchableSnowflakeishOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>Unique</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>after</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SearchableSnowflakeishOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>Unique</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>around</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SearchableSnowflakeishOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>Unique</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>iterators</span><span class=o>.</span><span class=n>LazyIterator</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>]:</span>
        <span class=sd>"""Browse the message history for a given text channel.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        This call is not a coroutine function, it returns a special type of</span>
<span class=sd>        lazy iterator that will perform API calls as you iterate across it,</span>
<span class=sd>        thus any errors documented below will happen then.</span>

<span class=sd>        See `hikari.iterators` for the full API for this iterator type.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to fetch messages in. This may be the object or</span>
<span class=sd>            the ID of an existing channel.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]</span>
<span class=sd>            If provided, fetch messages before this snowflake. If you provide</span>
<span class=sd>            a datetime object, it will be transformed into a snowflake. This</span>
<span class=sd>            may be any other Discord entity that has an ID. In this case, the</span>
<span class=sd>            date the object was first created will be used.</span>
<span class=sd>        after : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]</span>
<span class=sd>            If provided, fetch messages after this snowflake. If you provide</span>
<span class=sd>            a datetime object, it will be transformed into a snowflake. This</span>
<span class=sd>            may be any other Discord entity that has an ID. In this case, the</span>
<span class=sd>            date the object was first created will be used.</span>
<span class=sd>        around : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]</span>
<span class=sd>            If provided, fetch messages around this snowflake. If you provide</span>
<span class=sd>            a datetime object, it will be transformed into a snowflake. This</span>
<span class=sd>            may be any other Discord entity that has an ID. In this case, the</span>
<span class=sd>            date the object was first created will be used.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.iterators.LazyIterator[hikari.messages.Message]</span>
<span class=sd>            An iterator to fetch the messages.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        TypeError</span>
<span class=sd>            If you specify more than one of `before`, `after`, `about`.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `READ_MESSAGE_HISTORY` in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Fetch a specific message in the given text channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to fetch messages in. This may be the object or</span>
<span class=sd>            the ID of an existing message.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to fetch. This may be the object or the ID of an</span>
<span class=sd>            existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The requested message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `READ_MESSAGE_HISTORY` in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found or the message is not found in the</span>
<span class=sd>            given text channel.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>content</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Any</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>attachment</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachments</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>component</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>components</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embed</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embeds</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>tts</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>nonce</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reply</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mentions_everyone</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mentions_reply</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>role_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Create a message in the given channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to create the message in.</span>
<span class=sd>        content : hikari.undefined.UndefinedOr[typing.Any]</span>
<span class=sd>            If provided, the message contents. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then nothing will be sent</span>
<span class=sd>            in the content. Any other value here will be cast to a</span>
<span class=sd>            `str`.</span>

<span class=sd>            If this is a `hikari.embeds.Embed` and no `embed` nor `embeds` kwarg</span>
<span class=sd>            is provided, then this will instead update the embed. This allows</span>
<span class=sd>            for simpler syntax when sending an embed alone.</span>

<span class=sd>            Likewise, if this is a `hikari.files.Resource`, then the</span>
<span class=sd>            content is instead treated as an attachment if no `attachment` and</span>
<span class=sd>            no `attachments` kwargs are provided.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish],</span>
<span class=sd>            If provided, the message attachment. This can be a resource,</span>
<span class=sd>            or string of a path on your computer or a URL.</span>

<span class=sd>            Attachments can be passed as many different things, to aid in</span>
<span class=sd>            convenience.</span>

<span class=sd>            - If a `pathlib.PurePath` or `str` to a valid URL, the</span>
<span class=sd>                resource at the given URL will be streamed to Discord when</span>
<span class=sd>                sending the message. Subclasses of</span>
<span class=sd>                `hikari.files.WebResource` such as</span>
<span class=sd>                `hikari.files.URL`,</span>
<span class=sd>                `hikari.messages.Attachment`,</span>
<span class=sd>                `hikari.emojis.Emoji`,</span>
<span class=sd>                `EmbedResource`, etc will also be uploaded this way.</span>
<span class=sd>                This will use bit-inception, so only a small percentage of the</span>
<span class=sd>                resource will remain in memory at any one time, thus aiding in</span>
<span class=sd>                scalability.</span>
<span class=sd>            - If a `hikari.files.Bytes` is passed, or a `str`</span>
<span class=sd>                that contains a valid data URI is passed, then this is uploaded</span>
<span class=sd>                with a randomized file name if not provided.</span>
<span class=sd>            - If a `hikari.files.File`, `pathlib.PurePath` or</span>
<span class=sd>                `str` that is an absolute or relative path to a file</span>
<span class=sd>                on your file system is passed, then this resource is uploaded</span>
<span class=sd>                as an attachment using non-blocking code internally and streamed</span>
<span class=sd>                using bit-inception where possible. This depends on the</span>
<span class=sd>                type of `concurrent.futures.Executor` that is being used for</span>
<span class=sd>                the application (default is a thread pool which supports this</span>
<span class=sd>                behaviour).</span>
<span class=sd>        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]],</span>
<span class=sd>            If provided, the message attachments. These can be resources, or</span>
<span class=sd>            strings consisting of paths on your computer or URLs.</span>
<span class=sd>        component : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder]</span>
<span class=sd>            If provided, builder object of the component to include in this message.</span>
<span class=sd>        components : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]</span>
<span class=sd>            If provided, a sequence of the component builder objects to include</span>
<span class=sd>            in this message.</span>
<span class=sd>        embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed]</span>
<span class=sd>            If provided, the message embed.</span>
<span class=sd>        embeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed]]</span>
<span class=sd>            If provided, the message embeds.</span>
<span class=sd>        tts : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the message will be read out by a screen</span>
<span class=sd>            reader using Discord's TTS (text-to-speech) system.</span>
<span class=sd>        nonce : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            An arbitrary identifier to associate with the message. This</span>
<span class=sd>            can be used to identify it later in received events. If provided,</span>
<span class=sd>            this must be less than 32 bytes. If not provided, then</span>
<span class=sd>            a null value is placed on the message instead. All users can</span>
<span class=sd>            see this value.</span>
<span class=sd>        reply : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]]</span>
<span class=sd>            If provided, the message to reply to.</span>
<span class=sd>        mentions_everyone : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the message should parse @everyone/@here</span>
<span class=sd>            mentions.</span>
<span class=sd>        mentions_reply : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to mention the author of the message</span>
<span class=sd>            that is being replied to.</span>

<span class=sd>            This will not do anything if not being used with `reply`.</span>
<span class=sd>        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], bool]]</span>
<span class=sd>            If provided, and `True`, all user mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all user mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.users.PartialUser` derivatives to enforce mentioning</span>
<span class=sd>            specific users.</span>
<span class=sd>        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], bool]]</span>
<span class=sd>            If provided, and `True`, all role mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all role mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.guilds.PartialRole` derivatives to enforce mentioning</span>
<span class=sd>            specific roles.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The created message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        ValueError</span>
<span class=sd>            If more than 100 unique objects/entities are passed for</span>
<span class=sd>            `role_mentions` or `user_mentions` or if both `attachment` and</span>
<span class=sd>            `attachments`, `component` and `components` or `embed` and `embeds`</span>
<span class=sd>            are specified.</span>
<span class=sd>        TypeError</span>
<span class=sd>            If `attachments`, `components` or `embeds` is passed but is not a</span>
<span class=sd>            sequence.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            This may be raised in several discrete situations, such as messages</span>
<span class=sd>            being empty with no attachments or embeds; messages with more than</span>
<span class=sd>            2000 characters in them, embeds that exceed one of the many embed</span>
<span class=sd>            limits; too many attachments; attachments that are too large;</span>
<span class=sd>            invalid image URLs in embeds; if `reply` is not found or not in the</span>
<span class=sd>            same channel as `channel`; too many components.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `SEND_MESSAGES` in the channel or the</span>
<span class=sd>            person you are trying to message has the DM's disabled.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>crosspost_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildNewsChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Broadcast an announcement message.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildNewsChannel]</span>
<span class=sd>            The object or ID of the news channel to crosspost a message in.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The object or ID of the message to crosspost.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The message object that was crossposted.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If you tried to crosspost a message that has already been broadcast.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you try to crosspost a message by the current user without the</span>
<span class=sd>            `SEND_MESSAGES` permission for the target news channel or try to</span>
<span class=sd>            crosspost a message by another user without both the `SEND_MESSAGES`</span>
<span class=sd>            and `MANAGE_MESSAGES` permissions for the target channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
        <span class=n>content</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Any</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>attachment</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachments</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>component</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>components</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embed</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embeds</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>replace_attachments</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
        <span class=n>mentions_everyone</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mentions_reply</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>role_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>flags</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>MessageFlag</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Edit an existing message in a given channel.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            If the message was not sent by your user, the only parameter</span>
<span class=sd>            you may provide to this call is the `flags` parameter. Anything</span>
<span class=sd>            else will result in a `hikari.errors.ForbiddenError` being raised.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        Mentioning everyone, roles, or users in message edits currently</span>
<span class=sd>        will not send a push notification showing a new mention to people</span>
<span class=sd>        on Discord. It will still highlight in their chat as if they</span>
<span class=sd>        were mentioned, however.</span>

<span class=sd>        Also important to note that if you specify a text `content`, `mentions_everyone`,</span>
<span class=sd>        `mentions_reply`, `user_mentions`, and `role_mentions` will default</span>
<span class=sd>        to `False` as the message will be re-parsed for mentions. This will</span>
<span class=sd>        also occur if only one of the four are specified</span>

<span class=sd>        This is a limitation of Discord's design. If in doubt, specify all</span>
<span class=sd>        four of them each time.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to create the message in. This may be</span>
<span class=sd>            the object or the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to edit. This may be the object or the ID</span>
<span class=sd>            of an existing message.</span>
<span class=sd>        content : hikari.undefined.UndefinedOr[typing.Any]</span>
<span class=sd>            If provided, the message content to update with. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then the content will not</span>
<span class=sd>            be changed. If `None`, then the content will be removed.</span>

<span class=sd>            Any other value will be cast to a `str` before sending.</span>

<span class=sd>            If this is a `hikari.embeds.Embed` and neither the `embed` or</span>
<span class=sd>            `embeds` kwargs are provided or if this is a</span>
<span class=sd>            `hikari.files.Resourceish` and neither the</span>
<span class=sd>            `attachment` or `attachments` kwargs are provided, the values will</span>
<span class=sd>            be overwritten. This allows for simpler syntax when sending an</span>
<span class=sd>            embed or an attachment alone.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the attachment to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous attachment, if</span>
<span class=sd>            present, is not changed. If this is `None`, then the</span>
<span class=sd>            attachment is removed, if present. Otherwise, the new attachment</span>
<span class=sd>            that was provided will be attached.</span>
<span class=sd>        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]]</span>
<span class=sd>            If provided, the attachments to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous attachments, if</span>
<span class=sd>            present, are not changed. If this is `None`, then the</span>
<span class=sd>            attachments is removed, if present. Otherwise, the new attachments</span>
<span class=sd>            that were provided will be attached.</span>
<span class=sd>        component : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder]</span>
<span class=sd>            If provided, builder object of the component to set for this message.</span>
<span class=sd>            This component will replace any previously set components and passing</span>
<span class=sd>            `None` will remove all components.</span>
<span class=sd>        components : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]</span>
<span class=sd>            If provided, a sequence of the component builder objects set for</span>
<span class=sd>            this message. These components will replace any previously set</span>
<span class=sd>            components and passing `None` or an empty sequence will</span>
<span class=sd>            remove all components.</span>
<span class=sd>        embed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed]</span>
<span class=sd>            If provided, the embed to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.</span>
<span class=sd>            If this is `None` then any present embeds are removed.</span>
<span class=sd>            Otherwise, the new embed that was provided will be used as the</span>
<span class=sd>            replacement.</span>
<span class=sd>        embeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed]]</span>
<span class=sd>            If provided, the embeds to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.</span>
<span class=sd>            If this is `None` then any present embeds are removed.</span>
<span class=sd>            Otherwise, the new embeds that were provided will be used as the</span>
<span class=sd>            replacement.</span>
<span class=sd>        replace_attachments: bool</span>
<span class=sd>            Whether to replace the attachments with the provided ones. Defaults</span>
<span class=sd>            to `False`.</span>

<span class=sd>            Note this will also overwrite the embed attachments.</span>
<span class=sd>        mentions_everyone : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, sanitation for `@everyone` mentions. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then the previous setting is</span>
<span class=sd>            not changed. If `True`, then `@everyone`/`@here` mentions</span>
<span class=sd>            in the message content will show up as mentioning everyone that can</span>
<span class=sd>            view the chat.</span>
<span class=sd>        mentions_reply : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to mention the author of the message</span>
<span class=sd>            that is being replied to.</span>

<span class=sd>            This will not do anything if `message` is not a reply message.</span>
<span class=sd>        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], bool]]</span>
<span class=sd>            If provided, sanitation for user mentions. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then the previous setting is</span>
<span class=sd>            not changed. If `True`, all valid user mentions will behave</span>
<span class=sd>            as mentions. If `False`, all valid user mentions will not</span>
<span class=sd>            behave as mentions.</span>

<span class=sd>            You may alternatively pass a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake` user IDs, or</span>
<span class=sd>            `hikari.users.PartialUser`-derived objects.</span>
<span class=sd>        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], bool]]</span>
<span class=sd>            If provided, sanitation for role mentions. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then the previous setting is</span>
<span class=sd>            not changed. If `True`, all valid role mentions will behave</span>
<span class=sd>            as mentions. If `False`, all valid role mentions will not</span>
<span class=sd>            behave as mentions.</span>

<span class=sd>            You may alternatively pass a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake` role IDs, or</span>
<span class=sd>            `hikari.guilds.PartialRole`-derived objects.</span>
<span class=sd>        flags : hikari.undefined.UndefinedOr[hikari.messages.MessageFlag]</span>
<span class=sd>            If provided, optional flags to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then nothing is changed.</span>

<span class=sd>            Note that some flags may not be able to be set. Currently the only</span>
<span class=sd>            flags that can be set are `NONE` and `SUPPRESS_EMBEDS`. If you</span>
<span class=sd>            have `MANAGE_MESSAGES` permissions, you can use this call to</span>
<span class=sd>            suppress embeds on another user's message.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The edited message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        ValueError</span>
<span class=sd>            If both `attachment` and `attachments`, `component` and `components`</span>
<span class=sd>            or `embed` and `embeds` are specified.</span>
<span class=sd>        TypeError</span>
<span class=sd>            If `attachments`, `components` or `embeds` is passed but is not a</span>
<span class=sd>            sequence.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            This may be raised in several discrete situations, such as messages</span>
<span class=sd>            being empty with no embeds; messages with more than 2000 characters</span>
<span class=sd>            in them, embeds that exceed one of the many embed</span>
<span class=sd>            limits; invalid image URLs in embeds.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `SEND_MESSAGES` in the channel; if you try to</span>
<span class=sd>            change the contents of another user's message; or if you try to edit</span>
<span class=sd>            the flags on another user's message without the `MANAGE_MESSAGES`</span>
<span class=sd>            permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a given message in a given channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to delete the message in. This may be</span>
<span class=sd>            the object or the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete. This may be the object or the ID of</span>
<span class=sd>            an existing message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_MESSAGES`, and the message is</span>
<span class=sd>            not sent by you.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_messages</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>messages</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishIterable</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
        <span class=p>],</span>
        <span class=o>/</span><span class=p>,</span>
        <span class=o>*</span><span class=n>other_messages</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Bulk-delete messages from the channel.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This API endpoint will only be able to delete 100 messages</span>
<span class=sd>            at a time. For anything more than this, multiple requests will</span>
<span class=sd>            be executed one-after-the-other, since the rate limits for this</span>
<span class=sd>            endpoint do not favour more than one request per bucket.</span>

<span class=sd>            If one message is left over from chunking per 100 messages, or</span>
<span class=sd>            only one message is passed to this coroutine function, then the</span>
<span class=sd>            logic is expected to defer to `delete_message`. The implication</span>
<span class=sd>            of this is that the `delete_message` endpoint is rate limited</span>
<span class=sd>            by a different bucket with different usage rates.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            This endpoint is not atomic. If an error occurs midway through</span>
<span class=sd>            a bulk delete, you will **not** be able to revert any changes made</span>
<span class=sd>            up to this point.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            Specifying any messages more than 14 days old will cause the call</span>
<span class=sd>            to fail, potentially with partial completion.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to bulk delete the messages in. This may be</span>
<span class=sd>            the object or the ID of an existing channel.</span>
<span class=sd>        messages : typing.Union[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage], hikari.snowflakes.SnowflakeishIterable[hikari.messages.PartialMessage]]</span>
<span class=sd>            Either the object/ID of an existing message to delete or an iterable</span>
<span class=sd>            of the objects and/or IDs of existing messages to delete.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        *other_messages : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The objects and/or IDs of other existing messages to delete.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BulkDeleteError</span>
<span class=sd>            An error containing the messages successfully deleted, and the</span>
<span class=sd>            messages that were not removed. The</span>
<span class=sd>            `BaseException.__cause__` of the exception will be the</span>
<span class=sd>            original error that terminated this process.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>add_reaction</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>emojis</span><span class=o>.</span><span class=n>Emoji</span><span class=p>],</span>
        <span class=n>emoji_id</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Add a reaction emoji to a message in a given channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel where the message to add the reaction to is. This</span>
<span class=sd>            may be a `hikari.channels.TextableChannel` or the ID of an existing</span>
<span class=sd>            channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to add a reaction to. This may be the</span>
<span class=sd>            object or the ID of an existing message.</span>
<span class=sd>        emoji : typing.Union[str, hikari.emojis.Emoji]</span>
<span class=sd>            Object or name of the emoji to react with.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]]</span>
<span class=sd>            ID of the custom emoji to react with.</span>
<span class=sd>            This should only be provided when a custom emoji's name is passed</span>
<span class=sd>            for `emoji`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid unicode emoji is given, or if the given custom emoji</span>
<span class=sd>            does not exist.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `ADD_REACTIONS` (this is only necessary if you</span>
<span class=sd>            are the first person to add the reaction).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_my_reaction</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>emojis</span><span class=o>.</span><span class=n>Emoji</span><span class=p>],</span>
        <span class=n>emoji_id</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a reaction that your application user created.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel where the message to delete the reaction from is.</span>
<span class=sd>            This may be the object or the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete a reaction from. This may be the</span>
<span class=sd>            object or the ID of an existing message.</span>
<span class=sd>        emoji : typing.Union[str, hikari.emojis.Emoji]</span>
<span class=sd>            Object or name of the emoji to remove your reaction for.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]]</span>
<span class=sd>            ID of the custom emoji to remove your reaction for.</span>
<span class=sd>            This should only be provided when a custom emoji's name is passed</span>
<span class=sd>            for `emoji`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid unicode emoji is given, or if the given custom emoji</span>
<span class=sd>            does not exist.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_all_reactions_for_emoji</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>emojis</span><span class=o>.</span><span class=n>Emoji</span><span class=p>],</span>
        <span class=n>emoji_id</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete all reactions for a single emoji on a given message.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel where the message to delete the reactions from is.</span>
<span class=sd>            This may be the object or the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete a reactions from. This may be the</span>
<span class=sd>            object or the ID of an existing message.</span>
<span class=sd>        emoji : typing.Union[str, hikari.emojis.Emoji]</span>
<span class=sd>            Object or name of the emoji to remove all the reactions for.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]]</span>
<span class=sd>            ID of the custom emoji to remove all the reactions for.</span>
<span class=sd>            This should only be provided when a custom emoji's name is passed</span>
<span class=sd>            for `emoji`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid unicode emoji is given, or if the given custom emoji</span>
<span class=sd>            does not exist.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_MESSAGES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_reaction</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>emojis</span><span class=o>.</span><span class=n>Emoji</span><span class=p>],</span>
        <span class=n>emoji_id</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a reaction from a message.</span>

<span class=sd>        If you are looking to delete your own applications reaction, use</span>
<span class=sd>        `delete_my_reaction`.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel where the message to delete the reaction from is.</span>
<span class=sd>            This may be the object or the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete a reaction from. This may be the</span>
<span class=sd>            object or the ID of an existing message.</span>
<span class=sd>        user: hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            Object or ID of the user to remove the reaction of.</span>
<span class=sd>        emoji : typing.Union[str, hikari.emojis.Emoji]</span>
<span class=sd>            Object or name of the emoji to react with.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]]</span>
<span class=sd>            ID of the custom emoji to react with.</span>
<span class=sd>            This should only be provided when a custom emoji's name is passed</span>
<span class=sd>            for `emoji`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid unicode emoji is given, or if the given custom emoji</span>
<span class=sd>            does not exist.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_MESSAGES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_all_reactions</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete all reactions from a message.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel where the message to delete all reactions from is.</span>
<span class=sd>            This may be the object or the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete all reaction from. This may be the</span>
<span class=sd>            object or the ID of an existing message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid unicode emoji is given, or if the given custom emoji</span>
<span class=sd>            does not exist.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_MESSAGES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>fetch_reactions_for_emoji</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>emojis</span><span class=o>.</span><span class=n>Emoji</span><span class=p>],</span>
        <span class=n>emoji_id</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>iterators</span><span class=o>.</span><span class=n>LazyIterator</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>User</span><span class=p>]:</span>
        <span class=sd>"""Fetch reactions for an emoji from a message.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        This call is not a coroutine function, it returns a special type of</span>
<span class=sd>        lazy iterator that will perform API calls as you iterate across it,</span>
<span class=sd>        thus any errors documented below will happen then.</span>

<span class=sd>        See `hikari.iterators` for the full API for this iterator type.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel where the message to delete all reactions from is.</span>
<span class=sd>            This may be the object or the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete all reaction from. This may be the</span>
<span class=sd>            object or the ID of an existing message.</span>
<span class=sd>        emoji : typing.Union[str, hikari.emojis.Emoji]</span>
<span class=sd>            Object or name of the emoji to get the reactions for.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]]</span>
<span class=sd>            ID of the custom emoji to get the reactions for.</span>
<span class=sd>            This should only be provided when a custom emoji's name is passed</span>
<span class=sd>            for `emoji`.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.iterators.LazyIterator[hikari.users.User]</span>
<span class=sd>            An iterator to fetch the users.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid unicode emoji is given, or if the given custom emoji</span>
<span class=sd>            does not exist.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_webhook</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>WebhookChannelT</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>avatar</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>webhooks</span><span class=o>.</span><span class=n>IncomingWebhook</span><span class=p>:</span>
        <span class=sd>"""Create webhook in a channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT]</span>
<span class=sd>            The channel where the webhook will be created. This may be</span>
<span class=sd>            the object or the ID of an existing channel.</span>
<span class=sd>        name : str</span>
<span class=sd>            The name for the webhook. This cannot be `clyde`.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        avatar : typing.Optional[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the avatar for the webhook.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.webhooks.IncomingWebhook</span>
<span class=sd>            The created webhook.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If `name` doesn't follow the restrictions enforced by discord.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_WEBHOOKS` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_webhook</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>webhook</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>PartialWebhook</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>token</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>webhooks</span><span class=o>.</span><span class=n>PartialWebhook</span><span class=p>:</span>
        <span class=sd>"""Fetch an existing webhook.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.PartialWebhook]</span>
<span class=sd>            The webhook to fetch. This may be the object or the ID</span>
<span class=sd>            of an existing webhook.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        token : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the webhoook token that will be used to fetch</span>
<span class=sd>            the webhook instead of the token the client was initialized with.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.webhooks.PartialWebhook</span>
<span class=sd>            The requested webhook.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_WEBHOOKS` permission when not</span>
<span class=sd>            using a token.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the webhook is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_channel_webhooks</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>WebhookChannelT</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>PartialWebhook</span><span class=p>]:</span>
        <span class=sd>"""Fetch all channel webhooks.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT]</span>
<span class=sd>            The channel to fetch the webhooks for. This may be an instance of any</span>
<span class=sd>            of the classes which are valid for `hikari.channels.WebhookChannelT`</span>
<span class=sd>            or the ID of an existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.webhooks.PartialWebhook]</span>
<span class=sd>            The fetched webhooks.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_WEBHOOKS` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_webhooks</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>PartialWebhook</span><span class=p>]:</span>
        <span class=sd>"""Fetch all guild webhooks.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the webhooks for. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.webhooks.PartialWebhook]</span>
<span class=sd>            The fetched webhooks.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_WEBHOOKS` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_webhook</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>webhook</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>PartialWebhook</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>token</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>avatar</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>WebhookChannelT</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>webhooks</span><span class=o>.</span><span class=n>PartialWebhook</span><span class=p>:</span>
        <span class=sd>"""Edit a webhook.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.PartialWebhook]</span>
<span class=sd>            The webhook to edit. This may be the object or the</span>
<span class=sd>            ID of an existing webhook.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        token : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the webhoook token that will be used to edit</span>
<span class=sd>            the webhook instead of the token the client was initialized with.</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new webhook name.</span>
<span class=sd>        avatar : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the new webhook avatar. If `None`, will</span>
<span class=sd>            remove the webhook avatar.</span>
<span class=sd>        channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT]]</span>
<span class=sd>            If provided, the text channel to move the webhook to.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.webhooks.PartialWebhook</span>
<span class=sd>            The edited webhook.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_WEBHOOKS` permission when not</span>
<span class=sd>            using a token.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the webhook is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_webhook</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>webhook</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>PartialWebhook</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>token</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a webhook.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.PartialWebhook]</span>
<span class=sd>            The webhook to delete. This may be the object or the</span>
<span class=sd>            ID of an existing webhook.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        token : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the webhoook token that will be used to delete</span>
<span class=sd>            the webhook instead of the token the client was initialized with.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_WEBHOOKS` permission when not</span>
<span class=sd>            using a token.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the webhoook is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>execute_webhook</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=c1># MyPy might not say this but SnowflakeishOr[ExecutableWebhook] isn't valid as ExecutableWebhook isn't Unique</span>
        <span class=n>webhook</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>ExecutableWebhook</span><span class=p>,</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>Snowflakeish</span><span class=p>],</span>
        <span class=n>token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>content</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Any</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>username</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>avatar_url</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedType</span><span class=p>,</span> <span class=nb>str</span><span class=p>,</span> <span class=n>files</span><span class=o>.</span><span class=n>URL</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachment</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachments</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>component</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>components</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embed</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embeds</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>tts</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mentions_everyone</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>role_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>flags</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedType</span><span class=p>,</span> <span class=nb>int</span><span class=p>,</span> <span class=n>messages_</span><span class=o>.</span><span class=n>MessageFlag</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Execute a webhook.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            As of writing, `username` and `avatar_url` are ignored for</span>
<span class=sd>            interaction webhooks.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        webhook : typing.Union[hikari.snowflakes.Snowflakeish, hikari.webhooks.ExecutableWebhook]</span>
<span class=sd>            The webhook to execute. This may be the object</span>
<span class=sd>            or the ID of an existing webhook.</span>
<span class=sd>        token: str</span>
<span class=sd>            The webhook token.</span>
<span class=sd>        content : hikari.undefined.UndefinedOr[typing.Any]</span>
<span class=sd>            If provided, the message contents. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then nothing will be sent</span>
<span class=sd>            in the content. Any other value here will be cast to a</span>
<span class=sd>            `str`.</span>

<span class=sd>            If this is a `hikari.embeds.Embed` and no `embed` nor</span>
<span class=sd>            no `embeds` kwarg is provided, then this will instead</span>
<span class=sd>            update the embed. This allows for simpler syntax when</span>
<span class=sd>            sending an embed alone.</span>

<span class=sd>            Likewise, if this is a `hikari.files.Resource`, then the</span>
<span class=sd>            content is instead treated as an attachment if no `attachment` and</span>
<span class=sd>            no `attachments` kwargs are provided.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        username : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the username to override the webhook's username</span>
<span class=sd>            for this request.</span>
<span class=sd>        avatar_url : typing.Union[hikari.undefined.UndefinedType, hikari.files.URL, str]</span>
<span class=sd>            If provided, the url of an image to override the webhook's</span>
<span class=sd>            avatar with for this request.</span>
<span class=sd>        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish],</span>
<span class=sd>            If provided, the message attachment. This can be a resource,</span>
<span class=sd>            or string of a path on your computer or a URL.</span>

<span class=sd>            Attachments can be passed as many different things, to aid in</span>
<span class=sd>            convenience.</span>

<span class=sd>            - If a `pathlib.PurePath` or `str` to a valid URL, the</span>
<span class=sd>                resource at the given URL will be streamed to Discord when</span>
<span class=sd>                sending the message. Subclasses of</span>
<span class=sd>                `hikari.files.WebResource` such as</span>
<span class=sd>                `hikari.files.URL`,</span>
<span class=sd>                `hikari.messages.Attachment`,</span>
<span class=sd>                `hikari.emojis.Emoji`,</span>
<span class=sd>                `EmbedResource`, etc will also be uploaded this way.</span>
<span class=sd>                This will use bit-inception, so only a small percentage of the</span>
<span class=sd>                resource will remain in memory at any one time, thus aiding in</span>
<span class=sd>                scalability.</span>
<span class=sd>            - If a `hikari.files.Bytes` is passed, or a `str`</span>
<span class=sd>                that contains a valid data URI is passed, then this is uploaded</span>
<span class=sd>                with a randomized file name if not provided.</span>
<span class=sd>            - If a `hikari.files.File`, `pathlib.PurePath` or</span>
<span class=sd>                `str` that is an absolute or relative path to a file</span>
<span class=sd>                on your file system is passed, then this resource is uploaded</span>
<span class=sd>                as an attachment using non-blocking code internally and streamed</span>
<span class=sd>                using bit-inception where possible. This depends on the</span>
<span class=sd>                type of `concurrent.futures.Executor` that is being used for</span>
<span class=sd>                the application (default is a thread pool which supports this</span>
<span class=sd>                behaviour).</span>
<span class=sd>        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]],</span>
<span class=sd>            If provided, the message attachments. These can be resources, or</span>
<span class=sd>            strings consisting of paths on your computer or URLs.</span>
<span class=sd>        component : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder]</span>
<span class=sd>            If provided, builder object of the component to include in this message.</span>
<span class=sd>        components : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]</span>
<span class=sd>            If provided, a sequence of the component builder objects to include</span>
<span class=sd>            in this message.</span>
<span class=sd>        embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed]</span>
<span class=sd>            If provided, the message embed.</span>
<span class=sd>        embeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed]]</span>
<span class=sd>            If provided, the message embeds.</span>
<span class=sd>        tts : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the message will be read out by a screen</span>
<span class=sd>            reader using Discord's TTS (text-to-speech) system.</span>
<span class=sd>        mentions_everyone : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the message should parse @everyone/@here</span>
<span class=sd>            mentions.</span>
<span class=sd>        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], bool]]</span>
<span class=sd>            If provided, and `True`, all user mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all user mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.users.PartialUser` derivatives to enforce mentioning</span>
<span class=sd>            specific users.</span>
<span class=sd>        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], bool]]</span>
<span class=sd>            If provided, and `True`, all role mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all role mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.guilds.PartialRole` derivatives to enforce mentioning</span>
<span class=sd>            specific roles.</span>
<span class=sd>        flags : typing.Union[hikari.undefined.UndefinedType, int, hikari.messages.MessageFlag]</span>
<span class=sd>            The flags to set for this webhook message.</span>

<span class=sd>            .. warning::</span>
<span class=sd>                As of writing this can only be set for interaction webhooks</span>
<span class=sd>                and the only settable flag is EPHEMERAL; this field is just</span>
<span class=sd>                ignored for non-interaction webhooks.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The created message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        ValueError</span>
<span class=sd>            If more than 100 unique objects/entities are passed for</span>
<span class=sd>            `role_mentions` or `user_mentions` or if both `attachment` and</span>
<span class=sd>            `attachments` or `embed` and `embeds` are specified.</span>
<span class=sd>        TypeError</span>
<span class=sd>            If `attachments`, or `embeds` is passed but is not a sequence.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            This may be raised in several discrete situations, such as messages</span>
<span class=sd>            being empty with no attachments or embeds; messages with more than</span>
<span class=sd>            2000 characters in them, embeds that exceed one of the many embed</span>
<span class=sd>            limits; too many attachments; attachments that are too large;</span>
<span class=sd>            invalid image URLs in embeds; too many components.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the webhook is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_webhook_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=c1># MyPy might not say this but SnowflakeishOr[ExecutableWebhook] isn't valid as ExecutableWebhook isn't Unique</span>
        <span class=n>webhook</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>ExecutableWebhook</span><span class=p>,</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>Snowflakeish</span><span class=p>],</span>
        <span class=n>token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Fetch an old message sent by the webhook.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        webhook : typing.Union[hikari.snowflakes.Snowflakeish, hikari.webhooks.ExecutableWebhook]</span>
<span class=sd>            The webhook to execute. This may be the object</span>
<span class=sd>            or the ID of an existing webhook.</span>
<span class=sd>        token: str</span>
<span class=sd>            The webhook token.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to fetch. This may be the object or the ID of an</span>
<span class=sd>            existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The requested message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the webhook is not found or the webhook's message wasn't found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_webhook_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=c1># MyPy might not say this but SnowflakeishOr[ExecutableWebhook] isn't valid as ExecutableWebhook isn't Unique</span>
        <span class=n>webhook</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>ExecutableWebhook</span><span class=p>,</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>Snowflakeish</span><span class=p>],</span>
        <span class=n>token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>],</span>
        <span class=n>content</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Any</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>attachment</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachments</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>component</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>components</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embed</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embeds</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>replace_attachments</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
        <span class=n>mentions_everyone</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>role_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Edit a message sent by a webhook.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        Mentioning everyone, roles, or users in message edits currently</span>
<span class=sd>        will not send a push notification showing a new mention to people</span>
<span class=sd>        on Discord. It will still highlight in their chat as if they</span>
<span class=sd>        were mentioned, however.</span>

<span class=sd>        Also important to note that if you specify a text `content`, `mentions_everyone`,</span>
<span class=sd>        `mentions_reply`, `user_mentions`, and `role_mentions` will default</span>
<span class=sd>        to `False` as the message will be re-parsed for mentions. This will</span>
<span class=sd>        also occur if only one of the four are specified</span>

<span class=sd>        This is a limitation of Discord's design. If in doubt, specify all</span>
<span class=sd>        four of them each time.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        webhook : typing.Union[hikari.snowflakes.Snowflakeish, hikari.webhooks.ExecutableWebhook]</span>
<span class=sd>            The webhook to execute. This may be the object</span>
<span class=sd>            or the ID of an existing webhook.</span>
<span class=sd>        token: str</span>
<span class=sd>            The webhook token.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete. This may be the object or the ID of</span>
<span class=sd>            an existing message.</span>
<span class=sd>        content : hikari.undefined.UndefinedOr[typing.Any]</span>
<span class=sd>            If provided, the message content to update with. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then the content will not</span>
<span class=sd>            be changed. If `None`, then the content will be removed.</span>

<span class=sd>            Any other value will be cast to a `str` before sending.</span>

<span class=sd>            If this is a `hikari.embeds.Embed` and neither the</span>
<span class=sd>            `embed` or `embeds` kwargs are provided or if this is a</span>
<span class=sd>            `hikari.files.Resourceish` and neither the `attachment` or</span>
<span class=sd>            `attachments` kwargs are provided, the values will be overwritten.</span>
<span class=sd>            This allows for simpler syntax when sending an embed or an</span>
<span class=sd>            attachment alone.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the attachment to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous attachment, if</span>
<span class=sd>            present, is not changed. If this is `None`, then the</span>
<span class=sd>            attachment is removed, if present. Otherwise, the new attachment</span>
<span class=sd>            that was provided will be attached.</span>
<span class=sd>        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]]</span>
<span class=sd>            If provided, the attachments to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous attachments, if</span>
<span class=sd>            present, are not changed. If this is `None`, then the</span>
<span class=sd>            attachments is removed, if present. Otherwise, the new attachments</span>
<span class=sd>            that were provided will be attached.</span>
<span class=sd>        component : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder]</span>
<span class=sd>            If provided, builder object of the component to set for this message.</span>
<span class=sd>            This component will replace any previously set components and passing</span>
<span class=sd>            `None` will remove all components.</span>
<span class=sd>        components : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]</span>
<span class=sd>            If provided, a sequence of the component builder objects set for</span>
<span class=sd>            this message. These components will replace any previously set</span>
<span class=sd>            components and passing `None` or an empty sequence will</span>
<span class=sd>            remove all components.</span>
<span class=sd>        embed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed]</span>
<span class=sd>            If provided, the embed to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.</span>
<span class=sd>            If this is `None` then any present embeds are removed.</span>
<span class=sd>            Otherwise, the new embed that was provided will be used as the</span>
<span class=sd>            replacement.</span>
<span class=sd>        embeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed]]</span>
<span class=sd>            If provided, the embeds to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.</span>
<span class=sd>            If this is `None` then any present embeds are removed.</span>
<span class=sd>            Otherwise, the new embeds that were provided will be used as the</span>
<span class=sd>            replacement.</span>
<span class=sd>        replace_attachments: bool</span>
<span class=sd>            Whether to replace the attachments with the provided ones. Defaults</span>
<span class=sd>            to `False`.</span>

<span class=sd>            Note this will also overwrite the embed attachments.</span>
<span class=sd>        mentions_everyone : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, sanitation for `@everyone` mentions. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then the previous setting is</span>
<span class=sd>            not changed. If `True`, then `@everyone`/`@here` mentions</span>
<span class=sd>            in the message content will show up as mentioning everyone that can</span>
<span class=sd>            view the chat.</span>
<span class=sd>        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], bool]]</span>
<span class=sd>            If provided, and `True`, all user mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all user mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.users.PartialUser` derivatives to enforce mentioning</span>
<span class=sd>            specific users.</span>
<span class=sd>        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], bool]]</span>
<span class=sd>            If provided, and `True`, all role mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all role mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.guilds.PartialRole` derivatives to enforce mentioning</span>
<span class=sd>            specific roles.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The edited message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        ValueError</span>
<span class=sd>            If both `attachment` and `attachments`, `component` and `components`</span>
<span class=sd>            or `embed` and `embeds` are specified.</span>
<span class=sd>        TypeError</span>
<span class=sd>            If `attachments`, `components` or `embeds` is passed but is not a</span>
<span class=sd>            sequence.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            This may be raised in several discrete situations, such as messages</span>
<span class=sd>            being empty with no attachments or embeds; messages with more than</span>
<span class=sd>            2000 characters in them, embeds that exceed one of the many embed</span>
<span class=sd>            limits; too many attachments; attachments that are too large;</span>
<span class=sd>            invalid image URLs in embeds; too many components.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the webhook or the message are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_webhook_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=c1># MyPy might not say this but SnowflakeishOr[ExecutableWebhook] isn't valid as ExecutableWebhook isn't Unique</span>
        <span class=n>webhook</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>ExecutableWebhook</span><span class=p>,</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>Snowflakeish</span><span class=p>],</span>
        <span class=n>token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a given message in a given channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        webhook : typing.Union[hikari.snowflakes.Snowflakeish, hikari.webhooks.ExecutableWebhook]</span>
<span class=sd>            The webhook to execute. This may be the object</span>
<span class=sd>            or the ID of an existing webhook.</span>
<span class=sd>        token: str</span>
<span class=sd>            The webhook token.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete. This may be the object or the ID of</span>
<span class=sd>            an existing message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the webhook or the message are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_gateway_url</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>
        <span class=sd>"""Fetch the gateway url.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This endpoint does not require any valid authorization.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_gateway_bot_info</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>sessions</span><span class=o>.</span><span class=n>GatewayBotInfo</span><span class=p>:</span>
        <span class=sd>"""Fetch the gateway gateway info for the bot.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.sessions.GatewayBotInfo</span>
<span class=sd>            The gateway bot information.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_invite</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>invite</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>invites</span><span class=o>.</span><span class=n>InviteCode</span><span class=p>,</span> <span class=nb>str</span><span class=p>])</span> <span class=o>-></span> <span class=n>invites</span><span class=o>.</span><span class=n>Invite</span><span class=p>:</span>
        <span class=sd>"""Fetch an existing invite.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        invite : typing.Union[hikari.invites.InviteCode, str]</span>
<span class=sd>            The invite to fetch. This may be an invite object or</span>
<span class=sd>            the code of an existing invite.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.invites.Invite</span>
<span class=sd>            The requested invite.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the invite is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_invite</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>invite</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>invites</span><span class=o>.</span><span class=n>InviteCode</span><span class=p>,</span> <span class=nb>str</span><span class=p>])</span> <span class=o>-></span> <span class=n>invites</span><span class=o>.</span><span class=n>Invite</span><span class=p>:</span>
        <span class=sd>"""Delete an existing invite.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        invite : typing.Union[hikari.invites.InviteCode, str]</span>
<span class=sd>            The invite to delete. This may be an invite object or</span>
<span class=sd>            the code of an existing invite.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.invites.Invite</span>
<span class=sd>            Object of the invite that was deleted.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_GUILD` permission in the guild</span>
<span class=sd>            the invite is from or if you are missing the `MANAGE_CHANNELS`</span>
<span class=sd>            permission in the channel the invite is from.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the invite is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_my_user</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>users</span><span class=o>.</span><span class=n>OwnUser</span><span class=p>:</span>
        <span class=sd>"""Fetch the token's associated user.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.users.OwnUser</span>
<span class=sd>            The token's associated user.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_my_user</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>username</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>avatar</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>users</span><span class=o>.</span><span class=n>OwnUser</span><span class=p>:</span>
        <span class=sd>"""Edit the token's associated user.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        username : undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new username.</span>
<span class=sd>        avatar : undefined.UndefinedNoneOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the new avatar. If `None`,</span>
<span class=sd>            the avatar will be removed.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.users.OwnUser</span>
<span class=sd>            The edited token's associated user.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>

<span class=sd>            Discord also returns this on a rate limit:</span>
<span class=sd>            &LThttps://github.com/discord/discord-api-docs/issues/1462></span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_my_connections</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>applications</span><span class=o>.</span><span class=n>OwnConnection</span><span class=p>]:</span>
        <span class=sd>"""Fetch the token's associated connections.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.applications.OwnConnection</span>
<span class=sd>            The token's associated connections.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>fetch_my_guilds</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>newest_first</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
        <span class=n>start_at</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SearchableSnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>iterators</span><span class=o>.</span><span class=n>LazyIterator</span><span class=p>[</span><span class=n>applications</span><span class=o>.</span><span class=n>OwnGuild</span><span class=p>]:</span>
        <span class=sd>"""Fetch the token's associated guilds.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        This call is not a coroutine function, it returns a special type of</span>
<span class=sd>        lazy iterator that will perform API calls as you iterate across it,</span>
<span class=sd>        thus any errors documented below will happen then.</span>

<span class=sd>        See `hikari.iterators` for the full API for this iterator type.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        newest_first : bool</span>
<span class=sd>            Whether to fetch the newest first or the olders first.</span>
<span class=sd>            Defaults to `False`.</span>
<span class=sd>        start_at : hikari.undefined.UndefinedOr[hikari.snowflakes.SearchableSnowflakeishOr[hikari.guilds.PartialGuild]]</span>
<span class=sd>            If provided, will start at this snowflake. If you provide</span>
<span class=sd>            a datetime object, it will be transformed into a snowflake. This</span>
<span class=sd>            may also be a guild object. In this case, the</span>
<span class=sd>            date the object was first created will be used.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.iterators.LazyIterator[hikari.applications.OwnGuild]</span>
<span class=sd>            The token's associated guilds.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>leave_guild</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span> <span class=o>/</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Leave a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to leave. This may be the object or</span>
<span class=sd>            the ID of an existing guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found or you own the guild.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_dm_channel</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span> <span class=o>/</span><span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>DMChannel</span><span class=p>:</span>
        <span class=sd>"""Create a DM channel with a user.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to create the DM channel with. This may be the</span>
<span class=sd>            object or the ID of an existing user.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.DMChannel</span>
<span class=sd>            The created DM channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If the user is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=c1># THIS IS AN OAUTH2 FLOW BUT CAN BE USED BY BOTS ALSO</span>
    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_application</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>applications</span><span class=o>.</span><span class=n>Application</span><span class=p>:</span>
        <span class=sd>"""Fetch the token's associated application.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            This endpoint can only be used with a Bot token. Using this with a</span>
<span class=sd>            Bearer token will result in a `hikari.errors.UnauthorizedError`.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.applications.Application</span>
<span class=sd>            The token's associated application.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=c1># THIS IS AN OAUTH2 FLOW ONLY</span>
    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_authorization</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>applications</span><span class=o>.</span><span class=n>AuthorizationInformation</span><span class=p>:</span>
        <span class=sd>"""Fetch the token's authorization information.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            This endpoint can only be used with a Bearer token. Using this</span>
<span class=sd>            with a Bot token will result in a `hikari.errors.UnauthorizedError`.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.applications.AuthorizationInformation</span>
<span class=sd>            The token's authorization information.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>authorize_client_credentials_token</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>client</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>client_secret</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=c1># While according to the spec scopes are optional here, Discord requires that "valid" scopes are passed.</span>
        <span class=n>scopes</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>applications</span><span class=o>.</span><span class=n>OAuth2Scope</span><span class=p>,</span> <span class=nb>str</span><span class=p>]],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>applications</span><span class=o>.</span><span class=n>PartialOAuth2Token</span><span class=p>:</span>
        <span class=sd>"""Authorize a client credentials token for an application.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        client : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to authorize as.</span>
<span class=sd>        client_secret : str</span>
<span class=sd>            Secret of the application to authorize as.</span>
<span class=sd>        scopes : typing.Sequence[typing.Union[hikari.applications.OAuth2Scope, str]]</span>
<span class=sd>            The scopes to authorize for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.applications.PartialOAuth2Token</span>
<span class=sd>            Object of the authorized partial OAuth2 token.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If invalid any invalid or malformed scopes are passed.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            When an client or client secret is passed.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>authorize_access_token</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>client</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>client_secret</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>code</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>redirect_uri</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>applications</span><span class=o>.</span><span class=n>OAuth2AuthorizationToken</span><span class=p>:</span>
        <span class=sd>"""Authorize an OAuth2 token using the authorize code grant type.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        client : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to authorize with.</span>
<span class=sd>        client_secret : str</span>
<span class=sd>            Secret of the application to authorize with.</span>
<span class=sd>        code : str</span>
<span class=sd>            The authorization code to exchange for an OAuth2 access token.</span>
<span class=sd>        redirect_uri : str</span>
<span class=sd>            The redirect uri that was included in the authorization request.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.applications.OAuth2AuthorizationToken</span>
<span class=sd>            Object of the authorized OAuth2 token.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid redirect uri or code is passed.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            When an client or client secret is passed.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>refresh_access_token</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>client</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>client_secret</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>refresh_token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>scopes</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>applications</span><span class=o>.</span><span class=n>OAuth2Scope</span><span class=p>,</span> <span class=nb>str</span><span class=p>]]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>applications</span><span class=o>.</span><span class=n>OAuth2AuthorizationToken</span><span class=p>:</span>
        <span class=sd>"""Refresh an access token.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            As of writing this Discord currently ignores any passed scopes,</span>
<span class=sd>            therefore you should use</span>
<span class=sd>            `hikari.applications.OAuth2AuthorizationToken.scopes` to validate</span>
<span class=sd>            that the expected scopes were actually authorized here.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        client : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to authorize with.</span>
<span class=sd>        client_secret : str</span>
<span class=sd>            Secret of the application to authorize with.</span>
<span class=sd>        refresh_token : str</span>
<span class=sd>            The refresh token to use.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        scopes : typing.Sequence[typing.Union[hikari.applications.OAuth2Scope, str]]</span>
<span class=sd>            The scope of the access request.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.applications.OAuth2AuthorizationToken</span>
<span class=sd>            Object of the authorized OAuth2 token.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid redirect uri or refresh_token is passed.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            When an client or client secret is passed.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>revoke_access_token</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>client</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>client_secret</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>token</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>applications</span><span class=o>.</span><span class=n>PartialOAuth2Token</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Revoke an OAuth2 token.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        client : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to authorize with.</span>
<span class=sd>        client_secret : str</span>
<span class=sd>            Secret of the application to authorize with.</span>
<span class=sd>        token : typing.Union[str, hikari.applications.PartialOAuth2Token]</span>
<span class=sd>            Object or string of the access token to revoke.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            When an client or client secret is passed.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=c1># THIS IS AN OAUTH2 FLOW ONLY</span>
    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>add_user_to_guild</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>access_token</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>applications</span><span class=o>.</span><span class=n>PartialOAuth2Token</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>nick</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>roles</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mute</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>deaf</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>Member</span><span class=p>]:</span>
        <span class=sd>"""Add a user to a guild.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This requires the `access_token` to have the</span>
<span class=sd>            `hikari.applications.OAuth2Scope.GUILDS_JOIN` scope enabled along</span>
<span class=sd>            with the authorization of a Bot which has `MANAGE_INVITES`</span>
<span class=sd>            permission within the target guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        access_token : typing.Union[str, hikari.applications.PartialOAuth2Token]</span>
<span class=sd>            Object or string of the access token to use for this request.</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to add the user to. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to add to the guild. This may be the object</span>
<span class=sd>            or the ID of an existing user.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        nick : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the nick to add to the user when he joins the guild.</span>

<span class=sd>            Requires the `MANAGE_NICKNAMES` permission on the guild.</span>
<span class=sd>        roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole]]</span>
<span class=sd>            If provided, the roles to add to the user when he joins the guild.</span>
<span class=sd>            This may be a collection objects or IDs of existing roles.</span>

<span class=sd>            Requires the `MANAGE_ROLES` permission on the guild.</span>
<span class=sd>        mute : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, the mute state to add the user when he joins the guild.</span>

<span class=sd>            Requires the `MUTE_MEMBERS` permission on the guild.</span>
<span class=sd>        deaf : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, the deaf state to add the user when he joins the guild.</span>

<span class=sd>            Requires the `DEAFEN_MEMBERS` permission on the guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Optional[hikari.guilds.Member]</span>
<span class=sd>            `None` if the user was already part of the guild, else</span>
<span class=sd>            `hikari.guilds.Member`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild you want to add the user to,</span>
<span class=sd>            if you are missing permissions to do one of the things you specified,</span>
<span class=sd>            if you are using an access token for another user, if the token is</span>
<span class=sd>            bound to another bot or if the access token doesn't have the</span>
<span class=sd>            `hikari.applications.OAuth2Scope.GUILDS_JOIN` scope enabled.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If you own the guild or the user is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_voice_regions</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>voices</span><span class=o>.</span><span class=n>VoiceRegion</span><span class=p>]:</span>
        <span class=sd>"""Fetch available voice regions.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This endpoint doesn't return VIP voice regions.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.voices.VoiceRegion]</span>
<span class=sd>            The available voice regions.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_user</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>])</span> <span class=o>-></span> <span class=n>users</span><span class=o>.</span><span class=n>User</span><span class=p>:</span>
        <span class=sd>"""Fetch a user.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to fetch. This can be the object</span>
<span class=sd>            or the ID of an existing user.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.users.User</span>
<span class=sd>            The requested user</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the user is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>fetch_audit_log</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>before</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SearchableSnowflakeishOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>Unique</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>event_type</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>audit_logs</span><span class=o>.</span><span class=n>AuditLogEventType</span><span class=p>,</span> <span class=nb>int</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>iterators</span><span class=o>.</span><span class=n>LazyIterator</span><span class=p>[</span><span class=n>audit_logs</span><span class=o>.</span><span class=n>AuditLog</span><span class=p>]:</span>
        <span class=sd>"""Fetch the guild's audit log.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        This call is not a coroutine function, it returns a special type of</span>
<span class=sd>        lazy iterator that will perform API calls as you iterate across it,</span>
<span class=sd>        thus any errors documented below will happen then.</span>

<span class=sd>        See `hikari.iterators` for the full API for this iterator type.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the audit logs from. This can be a</span>
<span class=sd>            guild object or the ID of an existing guild.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        before : hikari.undefined.UndefinedOr[hikari.snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]</span>
<span class=sd>            If provided, filter to only actions before this snowflake. If you provide</span>
<span class=sd>            a datetime object, it will be transformed into a snowflake. This</span>
<span class=sd>            may be any other Discord entity that has an ID. In this case, the</span>
<span class=sd>            date the object was first created will be used.</span>
<span class=sd>        user : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]]</span>
<span class=sd>            If provided, the user to filter for.</span>
<span class=sd>        event_type : hikari.undefined.UndefinedOr[typing.Union[hikari.audit_logs.AuditLogEventType, int]]</span>
<span class=sd>            If provided, the event type to filter for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.iterators.LazyIterator[hikari.audit_logs.AuditLog]</span>
<span class=sd>            The guild's audit log.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `VIEW_AUDIT_LOG` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_emoji</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>emojis</span><span class=o>.</span><span class=n>KnownCustomEmoji</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild emoji.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the emoji from. This can be a</span>
<span class=sd>            guild object or the ID of an existing guild.</span>
<span class=sd>        emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]</span>
<span class=sd>            The emoji to fetch. This can be a `hikari.emojis.CustomEmoji`</span>
<span class=sd>            or the ID of an existing emoji.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.emojis.KnownCustomEmoji</span>
<span class=sd>            The requested emoji.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the emoji are not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_emojis</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>KnownCustomEmoji</span><span class=p>]:</span>
        <span class=sd>"""Fetch the emojis of a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the emojis from. This can be a</span>
<span class=sd>            guild object or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.emojis.KnownCustomEmoji]</span>
<span class=sd>            The requested emojis.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_emoji</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>image</span><span class=p>:</span> <span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>roles</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>emojis</span><span class=o>.</span><span class=n>KnownCustomEmoji</span><span class=p>:</span>
        <span class=sd>"""Create an emoji in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the emoji on. This can be a</span>
<span class=sd>            guild object or the ID of an existing guild.</span>
<span class=sd>        name : str</span>
<span class=sd>            The name for the emoji.</span>
<span class=sd>        image : hikari.files.Resourceish</span>
<span class=sd>            The 128x128 image for the emoji. Maximum upload size is 256kb.</span>
<span class=sd>            This can be a still or an animated image.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole]]</span>
<span class=sd>            If provided, a collection of the roles that will be able to</span>
<span class=sd>            use this emoji. This can be a `hikari.guilds.PartialRole` or</span>
<span class=sd>            the ID of an existing role.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.emojis.KnownCustomEmoji</span>
<span class=sd>            The created emoji.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value or</span>
<span class=sd>            if there are no more spaces for the type of emoji in the guild.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing `MANAGE_EMOJIS_AND_STICKERS` in the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_emoji</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>roles</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>emojis</span><span class=o>.</span><span class=n>KnownCustomEmoji</span><span class=p>:</span>
        <span class=sd>"""Edit an emoji in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit the emoji on. This can be a</span>
<span class=sd>            guild object or the ID of an existing guild.</span>
<span class=sd>        emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]</span>
<span class=sd>            The emoji to edit. This can be a `hikari.emojis.CustomEmoji`</span>
<span class=sd>            or the ID of an existing emoji.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new name for the emoji.</span>
<span class=sd>        roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole]]</span>
<span class=sd>            If provided, the new collection of roles that will be able to</span>
<span class=sd>            use this emoji. This can be a `hikari.guilds.PartialRole` or</span>
<span class=sd>            the ID of an existing role.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.emojis.KnownCustomEmoji</span>
<span class=sd>            The edited emoji.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing `MANAGE_EMOJIS_AND_STICKERS` in the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the emoji are not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_emoji</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete an emoji in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to delete the emoji on. This can be a guild object or the</span>
<span class=sd>            ID of an existing guild.</span>
<span class=sd>        emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]</span>
<span class=sd>            The emoji to delete. This can be a `hikari.emojis.CustomEmoji`</span>
<span class=sd>            or the ID of an existing emoji.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing `MANAGE_EMOJIS_AND_STICKERS` in the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the emoji are not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_available_sticker_packs</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>stickers</span><span class=o>.</span><span class=n>StickerPack</span><span class=p>]:</span>
        <span class=sd>"""Fetch the available sticker packs.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.stickers.StickerPack]</span>
<span class=sd>            The available sticker packs.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_sticker</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>sticker</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>stickers</span><span class=o>.</span><span class=n>PartialSticker</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>stickers</span><span class=o>.</span><span class=n>GuildSticker</span><span class=p>,</span> <span class=n>stickers</span><span class=o>.</span><span class=n>StandardSticker</span><span class=p>]:</span>
        <span class=sd>"""Fetch a sticker.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        sticker : snowflakes.SnowflakeishOr[stickers.PartialSticker]</span>
<span class=sd>            The sticker to fetch. This can be a sticker object or the</span>
<span class=sd>            ID of an existing sticker.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Union[hikari.stickers.GuildSticker, hikari.stickers.StandardSticker]</span>
<span class=sd>            The requested sticker.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the sticker is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_stickers</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>stickers</span><span class=o>.</span><span class=n>GuildSticker</span><span class=p>]:</span>
        <span class=sd>"""Fetch a standard sticker.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : snowflakes.SnowflakeishOr[stickers.PartialGuild]</span>
<span class=sd>            The guild to request stickers for. This can be a guild object or the</span>
<span class=sd>            ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.stickers.GuildSticker]</span>
<span class=sd>            The requested stickers.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_sticker</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>sticker</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>stickers</span><span class=o>.</span><span class=n>PartialSticker</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>stickers</span><span class=o>.</span><span class=n>GuildSticker</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild sticker.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : snowflakes.SnowflakeishOr[stickers.PartialGuild]</span>
<span class=sd>            The guild the sticker is in. This can be a guild object or the</span>
<span class=sd>            ID of an existing guild.</span>
<span class=sd>        sticker : snowflakes.SnowflakeishOr[stickers.PartialSticker]</span>
<span class=sd>            The sticker to fetch. This can be a sticker object or the</span>
<span class=sd>            ID of an existing sticker.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.stickers.GuildSticker</span>
<span class=sd>            The requested sticker.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the sticker are not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_sticker</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>tag</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>image</span><span class=p>:</span> <span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>stickers</span><span class=o>.</span><span class=n>GuildSticker</span><span class=p>:</span>
        <span class=sd>"""Create a sticker in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the sticker on. This can be a guild object or the</span>
<span class=sd>            ID of an existing guild.</span>
<span class=sd>        name : str</span>
<span class=sd>            The name for the sticker.</span>
<span class=sd>        tag : str</span>
<span class=sd>            The tag for the sticker.</span>
<span class=sd>        image : hikari.files.Resourceish</span>
<span class=sd>            The 320x320 image for the sticker. Maximum upload size is 500kb.</span>
<span class=sd>            This can be a still or an animated PNG or a Lottie.</span>

<span class=sd>            .. note::</span>
<span class=sd>                Lottie support is only available for verified and partnered</span>
<span class=sd>                servers.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        description: hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the description of the sticker.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.stickers.GuildSticker</span>
<span class=sd>            The created sticker.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value or</span>
<span class=sd>            if there are no more spaces for the sticker in the guild.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing `MANAGE_EMOJIS_AND_STICKERS` in the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_sticker</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>sticker</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>stickers</span><span class=o>.</span><span class=n>PartialSticker</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>tag</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>stickers</span><span class=o>.</span><span class=n>GuildSticker</span><span class=p>:</span>
        <span class=sd>"""Edit a sticker in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit the sticker on. This can be a guild object or the</span>
<span class=sd>            ID of an existing guild.</span>
<span class=sd>        sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker]</span>
<span class=sd>            The sticker to edit. This can be a sticker object or the ID of an</span>
<span class=sd>            existing sticker.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new name for the sticker.</span>
<span class=sd>        description : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new description for the sticker.</span>
<span class=sd>        tag : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new sticker tag.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.stickers.GuildSticker</span>
<span class=sd>            The edited sticker.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing `MANAGE_EMOJIS_AND_STICKERS` in the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the sticker are not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_sticker</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>sticker</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>stickers</span><span class=o>.</span><span class=n>PartialSticker</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a sticker in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to delete the sticker on. This can be a guild object or</span>
<span class=sd>            the ID of an existing guild.</span>
<span class=sd>        sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker]</span>
<span class=sd>            The sticker to delete. This can be a sticker object or the ID</span>
<span class=sd>            of an existing sticker.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing `MANAGE_EMOJIS_AND_STICKERS` in the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the sticker are not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>guild_builder</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=o>/</span><span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>GuildBuilder</span><span class=p>:</span>
        <span class=sd>"""Make a guild builder to create a guild with.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This endpoint can only be used by bots in less than 10 guilds.</span>

<span class=sd>        .. note::</span>
<span class=sd>            The exceptions on this endpoint will only be raised once</span>
<span class=sd>            `hikari.api.special_endpoints.GuildBuilder.create` is called.</span>
<span class=sd>            Invoking this function itself will not raise any of</span>
<span class=sd>            the above types.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        name : str</span>
<span class=sd>            The new guilds name.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.GuildBuilder</span>
<span class=sd>            The guild builder to use. This will allow to create a guild</span>
<span class=sd>            later with `hikari.api.special_endpoints.GuildBuilder.create`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value or if you</span>
<span class=sd>            call this as a bot that's in more than 10 guilds.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>

<span class=sd>        See Also</span>
<span class=sd>        --------</span>
<span class=sd>        `hikari.api.special_endpoints.GuildBuilder`</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>])</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>RESTGuild</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch. This can be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.RESTGuild</span>
<span class=sd>            The requested guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_preview</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>])</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>GuildPreview</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild preview.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This will only work for guilds you are a part of or are public.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the preview of. This can be a</span>
<span class=sd>            guild object or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.GuildPreview</span>
<span class=sd>            The requested guild preview.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found or you are not part of the guild.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_guild</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>verification_level</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>GuildVerificationLevel</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>default_message_notifications</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>guilds</span><span class=o>.</span><span class=n>GuildMessageNotificationsLevel</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>explicit_content_filter_level</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>guilds</span><span class=o>.</span><span class=n>GuildExplicitContentFilterLevel</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>afk_channel</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildVoiceChannel</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>afk_timeout</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>time</span><span class=o>.</span><span class=n>Intervalish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>icon</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>owner</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>splash</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>banner</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>system_channel</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildTextChannel</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>rules_channel</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildTextChannel</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>public_updates_channel</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildTextChannel</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>preferred_locale</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>RESTGuild</span><span class=p>:</span>
        <span class=sd>"""Edit a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new name for the guild.</span>
<span class=sd>        verification_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildVerificationLevel]</span>
<span class=sd>            If provided, the new verification level.</span>
<span class=sd>        default_message_notifications : hikari.undefined.UndefinedOr[hikari.guilds.GuildMessageNotificationsLevel]</span>
<span class=sd>            If provided, the new default message notifications level.</span>
<span class=sd>        explicit_content_filter_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildExplicitContentFilterLevel]</span>
<span class=sd>            If provided, the new explicit content filter level.</span>
<span class=sd>        afk_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel]]</span>
<span class=sd>            If provided, the new afk channel. Requires `afk_timeout` to</span>
<span class=sd>            be set to work.</span>
<span class=sd>        afk_timeout : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]</span>
<span class=sd>            If provided, the new afk timeout.</span>
<span class=sd>        icon : hikari.undefined.UndefinedOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the new guild icon. Must be a 1024x1024 image or can be</span>
<span class=sd>            an animated gif when the guild has the `ANIMATED_ICON` feature.</span>
<span class=sd>        owner : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]]]</span>
<span class=sd>            If provided, the new guild owner.</span>

<span class=sd>            .. warning::</span>
<span class=sd>                You need to be the owner of the server to use this.</span>
<span class=sd>        splash : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the new guild splash. Must be a 16:9 image and the</span>
<span class=sd>            guild must have the `INVITE_SPLASH` feature.</span>
<span class=sd>        banner : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the new guild banner. Must be a 16:9 image and the</span>
<span class=sd>            guild must have the `BANNER` feature.</span>
<span class=sd>        system_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel]]</span>
<span class=sd>            If provided, the new system channel.</span>
<span class=sd>        rules_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel]]</span>
<span class=sd>            If provided, the new rules channel.</span>
<span class=sd>        public_updates_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel]]</span>
<span class=sd>            If provided, the new public updates channel.</span>
<span class=sd>        preferred_locale : hikari.undefined.UndefinedNoneOr[str]</span>
<span class=sd>            If provided, the new preferred locale.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.RESTGuild</span>
<span class=sd>            The edited guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value. Or</span>
<span class=sd>            you are missing the</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_GUILD` permission or if you tried to</span>
<span class=sd>            pass ownership without being the server owner.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_guild</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>])</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to delete. This may be the object or</span>
<span class=sd>            the ID of an existing guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not the owner of the guild.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If you own the guild or if you are not in it.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_channels</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>]:</span>
        <span class=sd>"""Fetch the channels in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the channels from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.channels.GuildChannel]</span>
<span class=sd>            The requested channels.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_guild_text_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>position</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>topic</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>nsfw</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>rate_limit_per_user</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>time</span><span class=o>.</span><span class=n>Intervalish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permission_overwrites</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>category</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildCategory</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>GuildTextChannel</span><span class=p>:</span>
        <span class=sd>"""Create a text channel in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the channel in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        name : str</span>
<span class=sd>            The channels name. Must be between 2 and 1000 characters.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        position : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the position of the channel (relative to the</span>
<span class=sd>            category, if any).</span>
<span class=sd>        topic : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the channels topic. Maximum 1024 characters.</span>
<span class=sd>        nsfw : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to mark the channel as NSFW.</span>
<span class=sd>        rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]</span>
<span class=sd>            If provided, the amount of seconds a user has to wait</span>
<span class=sd>            before being able to send another message in the channel.</span>
<span class=sd>            Maximum 21600 seconds.</span>
<span class=sd>        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]</span>
<span class=sd>            If provided, the permission overwrites for the channel.</span>
<span class=sd>        category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]</span>
<span class=sd>            The category to create the channel under. This may be the</span>
<span class=sd>            object or the ID of an existing category.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.GuildTextChannel</span>
<span class=sd>            The created channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_guild_news_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>position</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>topic</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>nsfw</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>rate_limit_per_user</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>time</span><span class=o>.</span><span class=n>Intervalish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permission_overwrites</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>category</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildCategory</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>GuildNewsChannel</span><span class=p>:</span>
        <span class=sd>"""Create a news channel in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the channel in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        name : str</span>
<span class=sd>            The channels name. Must be between 2 and 1000 characters.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        position : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the position of the channel (relative to the</span>
<span class=sd>            category, if any).</span>
<span class=sd>        topic : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the channels topic. Maximum 1024 characters.</span>
<span class=sd>        nsfw : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to mark the channel as NSFW.</span>
<span class=sd>        rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]</span>
<span class=sd>            If provided, the amount of seconds a user has to wait</span>
<span class=sd>            before being able to send another message in the channel.</span>
<span class=sd>            Maximum 21600 seconds.</span>
<span class=sd>        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]</span>
<span class=sd>            If provided, the permission overwrites for the channel.</span>
<span class=sd>        category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]</span>
<span class=sd>            The category to create the channel under. This may be the</span>
<span class=sd>            object or the ID of an existing category.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.GuildNewsChannel</span>
<span class=sd>            The created channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_guild_voice_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>position</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_limit</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>bitrate</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>video_quality_mode</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>VideoQualityMode</span><span class=p>,</span> <span class=nb>int</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permission_overwrites</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>region</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>voices</span><span class=o>.</span><span class=n>VoiceRegion</span><span class=p>,</span> <span class=nb>str</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>category</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildCategory</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>GuildVoiceChannel</span><span class=p>:</span>
        <span class=sd>"""Create a voice channel in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the channel in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        name : str</span>
<span class=sd>            The channels name. Must be between 2 and 1000 characters.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        position : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the position of the channel (relative to the</span>
<span class=sd>            category, if any).</span>
<span class=sd>        user_limit : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the maximum users in the channel at once.</span>
<span class=sd>            Must be between 0 and 99 with 0 meaning no limit.</span>
<span class=sd>        bitrate : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the bitrate for the channel. Must be</span>
<span class=sd>            between 8000 and 96000 or 8000 and 128000 for VIP</span>
<span class=sd>            servers.</span>
<span class=sd>        video_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, int]]</span>
<span class=sd>            If provided, the new video quality mode for the channel.</span>
<span class=sd>        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]</span>
<span class=sd>            If provided, the permission overwrites for the channel.</span>
<span class=sd>        region : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, str]]</span>
<span class=sd>            If provided, the voice region to for this channel. Passing</span>
<span class=sd>            `None` here will set it to "auto" mode where the used</span>
<span class=sd>            region will be decided based on the first person who connects to it</span>
<span class=sd>            when it's empty.</span>
<span class=sd>        category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]</span>
<span class=sd>            The category to create the channel under. This may be the</span>
<span class=sd>            object or the ID of an existing category.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.GuildVoiceChannel</span>
<span class=sd>            The created channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_guild_stage_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>position</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_limit</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>bitrate</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permission_overwrites</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>region</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>voices</span><span class=o>.</span><span class=n>VoiceRegion</span><span class=p>,</span> <span class=nb>str</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>category</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildCategory</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>GuildStageChannel</span><span class=p>:</span>
        <span class=sd>"""Create a stage channel in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the channel in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        name : str</span>
<span class=sd>            The channel's name. Must be between 2 and 1000 characters.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        position : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the position of the channel (relative to the</span>
<span class=sd>            category, if any).</span>
<span class=sd>        user_limit : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the maximum users in the channel at once.</span>
<span class=sd>            Must be between 0 and 99 with 0 meaning no limit.</span>
<span class=sd>        bitrate : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the bitrate for the channel. Must be</span>
<span class=sd>            between 8000 and 96000 or 8000 and 128000 for VIP</span>
<span class=sd>            servers.</span>
<span class=sd>        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]</span>
<span class=sd>            If provided, the permission overwrites for the channel.</span>
<span class=sd>        region : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, str]]</span>
<span class=sd>            If provided, the voice region to for this channel. Passing</span>
<span class=sd>            `None` here will set it to "auto" mode where the used</span>
<span class=sd>            region will be decided based on the first person who connects to it</span>
<span class=sd>            when it's empty.</span>
<span class=sd>        category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]</span>
<span class=sd>            The category to create the channel under. This may be the</span>
<span class=sd>            object or the ID of an existing category.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.GuildStageChannel</span>
<span class=sd>            The created channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_guild_category</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>position</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permission_overwrites</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>GuildCategory</span><span class=p>:</span>
        <span class=sd>"""Create a category in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the channel in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        name : str</span>
<span class=sd>            The channels name. Must be between 2 and 1000 characters.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        position : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the position of the category.</span>
<span class=sd>        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]</span>
<span class=sd>            If provided, the permission overwrites for the category.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.GuildCategory</span>
<span class=sd>            The created category.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>reposition_channels</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>positions</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Mapping</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>]],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Reposition the channels in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to reposition the channels in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        positions : typing.Mapping[int, hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]]</span>
<span class=sd>            A mapping of of the object or the ID of an existing channel to</span>
<span class=sd>            the new position, relative to their parent category, if any.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>Member</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild member.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to get the member from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to get the member for. This may be the</span>
<span class=sd>            object or the ID of an existing user.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.Member</span>
<span class=sd>            The requested member.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the user are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>fetch_members</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>iterators</span><span class=o>.</span><span class=n>LazyIterator</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>Member</span><span class=p>]:</span>
        <span class=sd>"""Fetch the members from a guild.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            This endpoint requires the `GUILD_MEMBERS` intent to be enabled in</span>
<span class=sd>            the dashboard, not necessarily authenticated with it if using the</span>
<span class=sd>            gateway. If you don't have the intents you can use `search_members`</span>
<span class=sd>            which doesn't require any intents.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        This call is not a coroutine function, it returns a special type of</span>
<span class=sd>        lazy iterator that will perform API calls as you iterate across it,</span>
<span class=sd>        thus any errors documented below will happen then.</span>

<span class=sd>        See `hikari.iterators` for the full API for this iterator type.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the members of. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.iterators.LazyIterator[hikari.guilds.Member]</span>
<span class=sd>            An iterator to fetch the members.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_my_member</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>])</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>Member</span><span class=p>:</span>
        <span class=sd>"""Fetch the Oauth token's associated member in a guild.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            This endpoint can only be used with a Bearer token. Using this</span>
<span class=sd>            with a Bot token will result in a `hikari.errors.UnauthorizedError`.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.Member</span>
<span class=sd>            The associated guild member.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>search_members</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>Member</span><span class=p>]:</span>
        <span class=sd>"""Search the members in a guild by nickname and username.</span>

<span class=sd>        .. note::</span>
<span class=sd>            Unlike `RESTClient.fetch_members` this endpoint isn't paginated and</span>
<span class=sd>            therefore will return all the members in one go rather than needing</span>
<span class=sd>            to be asynchronously iterated over.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The object or ID of the guild to search members in.</span>
<span class=sd>        name : str</span>
<span class=sd>            The query to match username(s) and nickname(s) against.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.guilds.Member]</span>
<span class=sd>            A sequence of the members who matched the provided `name`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>nick</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>roles</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mute</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>deaf</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>voice_channel</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildVoiceChannel</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>communication_disabled_until</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>datetime</span><span class=o>.</span><span class=n>datetime</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>Member</span><span class=p>:</span>
        <span class=sd>"""Edit a guild member.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to edit. This may be the object</span>
<span class=sd>            or the ID of an existing user.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        nick : hikari.undefined.UndefinedNoneOr[str]</span>
<span class=sd>            If provided, the new nick for the member. If `None`,</span>
<span class=sd>            will remove the members nick.</span>

<span class=sd>            Requires the `MANAGE_NICKNAMES` permission.</span>
<span class=sd>        roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole]]</span>
<span class=sd>            If provided, the new roles for the member.</span>

<span class=sd>            Requires the `MANAGE_ROLES` permission.</span>
<span class=sd>        mute : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, the new server mute state for the member.</span>

<span class=sd>            Requires the `MUTE_MEMBERS` permission.</span>
<span class=sd>        deaf : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, the new server deaf state for the member.</span>

<span class=sd>            Requires the `DEAFEN_MEMBERS` permission.</span>
<span class=sd>        voice_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel]]]</span>
<span class=sd>            If provided, `None` or the object or the ID of</span>
<span class=sd>            an existing voice channel to move the member to.</span>
<span class=sd>            If `None`, will disconnect the member from voice.</span>

<span class=sd>            Requires the `MOVE_MEMBERS` permission and the `CONNECT`</span>
<span class=sd>            permission in the original voice channel and the target</span>
<span class=sd>            voice channel.</span>

<span class=sd>            .. note::</span>
<span class=sd>                If the member is not in a voice channel, this will</span>
<span class=sd>                take no effect.</span>
<span class=sd>        communication_disabled_until : hikari.undefined.UndefinedNoneOr[datetime.datetime]</span>
<span class=sd>            If provided, the datetime when the timeout (disable communication)</span>
<span class=sd>            of the member expires, up to 28 days in the future, or `None`</span>
<span class=sd>            to remove the timeout from the member.</span>

<span class=sd>            Requires the `MODERATE_MEMBERS` permission.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.Member</span>
<span class=sd>            Object of the member that was updated.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing a permission to do an action.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the user are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_my_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>nickname</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>Member</span><span class=p>:</span>
        <span class=sd>"""Edit the current user's member in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit the member in. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        nickname : hikari.undefined.UndefinedNoneOr[str]</span>
<span class=sd>            If provided, the new nickname for the member. If</span>
<span class=sd>            `None`, will remove the members nickname.</span>

<span class=sd>            Requires the `CHANGE_NICKNAME` permission.</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.Member</span>
<span class=sd>            Object of the member that was updated.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing a permission to do an action.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@deprecation</span><span class=o>.</span><span class=n>deprecated</span><span class=p>(</span><span class=s2>"2.0.0.dev104"</span><span class=p>,</span> <span class=s2>"Use `edit_my_member`'s `nick` argument instead."</span><span class=p>)</span>
    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_my_nick</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>Guild</span><span class=p>],</span>
        <span class=n>nick</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=nb>str</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Edit the associated token's member nick.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>
<span class=sd>        nick : typing.Optional[str]</span>
<span class=sd>            The new nick. If `None`,</span>
<span class=sd>            will remove the nick.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `CHANGE_NICKNAME` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>add_role_to_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=n>role</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Add a role to a member.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild where the member is in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to add the role to. This may be the</span>
<span class=sd>            object or the ID of an existing user.</span>
<span class=sd>        role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]</span>
<span class=sd>            The role to add. This may be the object or the</span>
<span class=sd>            ID of an existing role.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_ROLES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild, user or role are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>remove_role_from_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=n>role</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Remove a role from a member.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild where the member is in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to remove the role from. This may be the</span>
<span class=sd>            object or the ID of an existing user.</span>
<span class=sd>        role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]</span>
<span class=sd>            The role to remove. This may be the object or the</span>
<span class=sd>            ID of an existing role.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_ROLES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild, user or role are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>kick_user</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Kick a member from a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to kick the member from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to kick. This may be the object</span>
<span class=sd>            or the ID of an existing user.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `KICK_MEMBERS` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or user are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>kick_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Alias of `hikari.impl.rest.RESTClient.kick_user`."""</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>ban_user</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>delete_message_days</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Ban a member from a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to ban the member from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to kick. This may be the object</span>
<span class=sd>            or the ID of an existing user.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        delete_message_days : hikari.undefined.UndefinedNoneOr[int]</span>
<span class=sd>            If provided, the number of days to delete messages for.</span>
<span class=sd>            This must be between 0 and 7.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `BAN_MEMBERS` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or user are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>ban_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>delete_message_days</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Alias of `hikari.impl.rest.RESTClient.ban_user`."""</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>unban_user</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Unban a member from a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to unban the member from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to unban. This may be the object</span>
<span class=sd>            or the ID of an existing user.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `BAN_MEMBERS` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or user are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>unban_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Alias of `hikari.impl.rest.RESTClient.unban_user`."""</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_ban</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>GuildBan</span><span class=p>:</span>
        <span class=sd>"""Fetch the guild's ban info for a user.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the ban from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to fetch the ban of. This may be the</span>
<span class=sd>            object or the ID of an existing user.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.GuildBan</span>
<span class=sd>            The requested ban info.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `BAN_MEMBERS` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or user are not found or if the user</span>
<span class=sd>            is not banned.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_bans</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>GuildBan</span><span class=p>]:</span>
        <span class=sd>"""Fetch the bans of a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the bans from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.guilds.GuildBan]</span>
<span class=sd>            The requested bans.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `BAN_MEMBERS` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_roles</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>Role</span><span class=p>]:</span>
        <span class=sd>"""Fetch the roles of a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the roles from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.guilds.Role]</span>
<span class=sd>            The requested roles.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_role</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permissions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>permissions_</span><span class=o>.</span><span class=n>Permissions</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>color</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>colors</span><span class=o>.</span><span class=n>Colorish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>colour</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>colors</span><span class=o>.</span><span class=n>Colorish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>hoist</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>icon</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>unicode_emoji</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mentionable</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>Role</span><span class=p>:</span>
        <span class=sd>"""Create a role.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the role in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the name for the role.</span>
<span class=sd>        permissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]</span>
<span class=sd>            The permissions to give the role. This will default to setting</span>
<span class=sd>            NO roles if left to the default value. This is in contrast to</span>
<span class=sd>            default behaviour on Discord where some random permissions will</span>
<span class=sd>            be set by default.</span>
<span class=sd>        color : hikari.undefined.UndefinedOr[hikari.colors.Colorish]</span>
<span class=sd>            If provided, the role's color.</span>
<span class=sd>        colour : hikari.undefined.UndefinedOr[hikari.colors.Colorish]</span>
<span class=sd>            An alias for `color`.</span>
<span class=sd>        hoist : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to hoist the role.</span>
<span class=sd>        icon : hikari.undefined.UndefinedOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the role icon. Must be a 64x64 image under 256kb.</span>
<span class=sd>        unicode_emoji : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the standard emoji to set as the role icon.</span>
<span class=sd>        mentionable : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to make the role mentionable.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.Role</span>
<span class=sd>            The created role.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        TypeError</span>
<span class=sd>            If both `color` and `colour` are specified or if both `icon` and</span>
<span class=sd>            `unicode_emoji` are specified.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_ROLES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>reposition_roles</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>positions</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Mapping</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>]],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Reposition the roles in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to reposition the roles in. This may be</span>
<span class=sd>            the object or the ID of an existing guild.</span>
<span class=sd>        positions : typing.Mapping[int, hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]</span>
<span class=sd>            A mapping of the position to the role.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_ROLES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_role</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>role</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permissions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>permissions_</span><span class=o>.</span><span class=n>Permissions</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>color</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>colors</span><span class=o>.</span><span class=n>Colorish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>colour</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>colors</span><span class=o>.</span><span class=n>Colorish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>hoist</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>icon</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>unicode_emoji</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mentionable</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>Role</span><span class=p>:</span>
        <span class=sd>"""Edit a role.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit the role in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]</span>
<span class=sd>            The role to edit. This may be the object or the</span>
<span class=sd>            ID of an existing role.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new name for the role.</span>
<span class=sd>        permissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]</span>
<span class=sd>            If provided, the new permissions for the role.</span>
<span class=sd>        color : hikari.undefined.UndefinedOr[hikari.colors.Colorish]</span>
<span class=sd>            If provided, the new color for the role.</span>
<span class=sd>        colour : hikari.undefined.UndefinedOr[hikari.colors.Colorish]</span>
<span class=sd>            An alias for `color`.</span>
<span class=sd>        hoist : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to hoist the role.</span>
<span class=sd>        icon : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the new role icon. Must be a 64x64 image</span>
<span class=sd>            under 256kb.</span>
<span class=sd>        unicode_emoji : hikari.undefined.UndefinedNoneOr[str]</span>
<span class=sd>            If provided, the new unicode emoji to set as the role icon.</span>
<span class=sd>        mentionable : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to make the role mentionable.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.Role</span>
<span class=sd>            The edited role.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        TypeError</span>
<span class=sd>            If both `color` and `colour` are specified or if both `icon` and</span>
<span class=sd>            `unicode_emoji` are specified.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_ROLES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or role are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_role</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>role</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a role.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to delete the role in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]</span>
<span class=sd>            The role to delete. This may be the object or the</span>
<span class=sd>            ID of an existing role.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_ROLES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or role are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>estimate_guild_prune_count</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>days</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>include_roles</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=nb>int</span><span class=p>:</span>
        <span class=sd>"""Estimate the guild prune count.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to estimate the guild prune count for. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        days : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, number of days to count prune for.</span>
<span class=sd>        include_roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole]]]</span>
<span class=sd>            If provided, the role(s) to include. By default, this endpoint will</span>
<span class=sd>            not count users with roles. Providing roles using this attribute</span>
<span class=sd>            will make members with the specified roles also get included into</span>
<span class=sd>            the count.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        int</span>
<span class=sd>            The estimated guild prune count.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `KICK_MEMBERS` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>begin_guild_prune</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>days</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>compute_prune_count</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>include_roles</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=nb>int</span><span class=p>]:</span>
        <span class=sd>"""Begin the guild prune.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to begin the guild prune in. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        days : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, number of days to count prune for.</span>
<span class=sd>        compute_prune_count: hikari.snowflakes.SnowflakeishOr[bool]</span>
<span class=sd>            If provided, whether to return the prune count. This is discouraged</span>
<span class=sd>            for large guilds.</span>
<span class=sd>        include_roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole]]</span>
<span class=sd>            If provided, the role(s) to include. By default, this endpoint will</span>
<span class=sd>            not count users with roles. Providing roles using this attribute</span>
<span class=sd>            will make members with the specified roles also get included into</span>
<span class=sd>            the count.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Optional[int]</span>
<span class=sd>            If `compute_prune_count` is not provided or `True`, the</span>
<span class=sd>            number of members pruned. Else `None`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `KICK_MEMBERS` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_voice_regions</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>voices</span><span class=o>.</span><span class=n>VoiceRegion</span><span class=p>]:</span>
        <span class=sd>"""Fetch the available voice regions for a guild.</span>

<span class=sd>        .. note::</span>
<span class=sd>            Unlike `RESTClient.fetch_voice_regions`, this will</span>
<span class=sd>            return the VIP regions if the guild has access to them.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the voice regions for. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.voices.VoiceRegion]</span>
<span class=sd>            The available voice regions for the guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_invites</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>invites</span><span class=o>.</span><span class=n>InviteWithMetadata</span><span class=p>]:</span>
        <span class=sd>"""Fetch the guild's invites.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the invites for. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.invites.InviteWithMetadata]</span>
<span class=sd>            The invites for the guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_GUILD` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_integrations</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>Integration</span><span class=p>]:</span>
        <span class=sd>"""Fetch the guild's integrations.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the integrations for. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.guilds.Integration]</span>
<span class=sd>            The integrations for the guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_GUILD` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_widget</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>])</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>GuildWidget</span><span class=p>:</span>
        <span class=sd>"""Fetch a guilds's widget.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the widget from. This can be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.GuildWidget</span>
<span class=sd>            The requested guild widget.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_GUILD` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_widget</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>enabled</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>GuildWidget</span><span class=p>:</span>
        <span class=sd>"""Fetch a guilds's widget.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit the widget in. This can be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]]</span>
<span class=sd>            If provided, the channel to set the widget to. If `None`,</span>
<span class=sd>            will not set to any.</span>
<span class=sd>        enabled : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to enable the widget.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.GuildWidget</span>
<span class=sd>            The edited guild widget.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_GUILD` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_welcome_screen</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>])</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>WelcomeScreen</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild's welcome screen.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or ID of the guild to fetch the welcome screen for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.WelcomeScreen</span>
<span class=sd>            The requested welcome screen.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found or the welcome screen has never been set</span>
<span class=sd>            for this guild (if the welcome screen has been set for a guild</span>
<span class=sd>            before and then disabled you should still be able to fetch it).</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_welcome_screen</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>enabled</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>channels</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>WelcomeChannel</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>WelcomeScreen</span><span class=p>:</span>
        <span class=sd>"""Edit the welcome screen of a community guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            ID or object of the guild to edit the welcome screen for.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        description : undefined.UndefinedNoneOr[str]</span>
<span class=sd>            If provided, the description to set for the guild's welcome screen.</span>
<span class=sd>            This may be `None` to unset the description.</span>
<span class=sd>        enabled : undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, Whether the guild's welcome screen should be enabled.</span>
<span class=sd>        channels : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.guilds.WelcomeChannel]]</span>
<span class=sd>            If provided, a sequence of up to 5 public channels to set in this</span>
<span class=sd>            guild's welcome screen. This may be passed as `None` to</span>
<span class=sd>            remove all welcome channels</span>

<span class=sd>            .. note::</span>
<span class=sd>                Custom emojis may only be included in a guild's welcome channels</span>
<span class=sd>                if it's boost status is tier 2 or above.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.WelcomeScreen</span>
<span class=sd>            The edited guild welcome screen.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If more than 5 welcome channels are provided or if a custom emoji</span>
<span class=sd>            is included on a welcome channel in a guild that doesn't have tier</span>
<span class=sd>            2 of above boost status or if a private channel is included as a</span>
<span class=sd>            welcome channel.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_GUILD` permission, are not part of</span>
<span class=sd>            the guild or the guild doesn't have access to the community welcome</span>
<span class=sd>            screen feature.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_vanity_url</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>])</span> <span class=o>-></span> <span class=n>invites</span><span class=o>.</span><span class=n>VanityURL</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild's vanity url.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the vanity url from. This can</span>
<span class=sd>            be the object or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.invites.VanityURL</span>
<span class=sd>            The requested invite.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_template</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>:</span>
        <span class=sd>"""Create a guild template.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create a template from.</span>
<span class=sd>        name : str</span>
<span class=sd>            The name to use for the created template.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        description : hikari.undefined.UndefinedNoneOr[str]</span>
<span class=sd>            The description to set for the template.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.templates.Template</span>
<span class=sd>            The object of the created template.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found or you are missing the `MANAGE_GUILD`</span>
<span class=sd>            permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_guild_from_template</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>template</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>icon</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>RESTGuild</span><span class=p>:</span>
        <span class=sd>"""Make a guild from a template.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This endpoint can only be used by bots in less than 10 guilds.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        template : typing.Union[str, hikari.templates.Template]</span>
<span class=sd>            The object or string code of the template to create a guild based on.</span>
<span class=sd>        name : str</span>
<span class=sd>            The new guilds name.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        icon : hikari.undefined.UndefinedOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the guild icon to set. Must be a 1024x1024 image or can</span>
<span class=sd>            be an animated gif when the guild has the `ANIMATED_ICON` feature.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.RESTGuild</span>
<span class=sd>            Object of the created guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value or if you</span>
<span class=sd>            call this as a bot that's in more than 10 guilds.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_template</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>template</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>:</span>
        <span class=sd>"""Delete a guild template.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to delete a template in.</span>
<span class=sd>        template : typing.Union[str, hikari.templates.Template]</span>
<span class=sd>            Object or string code of the template to delete.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.templates.Template</span>
<span class=sd>            The deleted template's object.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found or you are missing the `MANAGE_GUILD`</span>
<span class=sd>            permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_template</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>template</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>,</span> <span class=nb>str</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>:</span>
        <span class=sd>"""Modify a guild template.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit a template in.</span>
<span class=sd>        template : typing.Union[str, hikari.templates.Template]</span>
<span class=sd>            Object or string code of the template to modify.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            The name to set for this template.</span>
<span class=sd>        description : hikari.undefined.UndefinedNoneOr[str]</span>
<span class=sd>            The description to set for the template.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.templates.Template</span>
<span class=sd>            The object of the edited template.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found or you are missing the `MANAGE_GUILD`</span>
<span class=sd>            permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_template</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>template</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>])</span> <span class=o>-></span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild template.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        template : typing.Union[str, hikari.templates.Template]</span>
<span class=sd>            The object or string code of the template to fetch.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.templates.Template</span>
<span class=sd>            The object of the found template.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the template was not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_templates</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>]:</span>
        <span class=sd>"""Fetch the templates for a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The object or ID of the guild to get the templates for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.templates.Template]</span>
<span class=sd>            A sequence of the found template objects.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found or are missing the `MANAGE_GUILD`</span>
<span class=sd>            permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>sync_guild_template</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>template</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>:</span>
        <span class=sd>"""Create a guild template.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to sync a template in.</span>
<span class=sd>        template : typing.Union[str, hikari.templates.Template]</span>
<span class=sd>            Object or code of the template to sync.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.templates.Template</span>
<span class=sd>            The object of the synced template.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild or are missing the `MANAGE_GUILD`</span>
<span class=sd>            permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or template is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>command_builder</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>description</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>SlashCommandBuilder</span><span class=p>:</span>
        <span class=sa>r</span><span class=sd>"""Create a slash command builder for use in `RESTClient.set_application_commands`.</span>

<span class=sd>        .. deprecated:: 2.0.0.dev106</span>
<span class=sd>            Use `RESTClient.slash_command_builder` instead.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        name : str</span>
<span class=sd>            The command's name. This should match the regex `^[\w-]{1,32}$` in</span>
<span class=sd>            Unicode mode and be lowercase.</span>
<span class=sd>        description : str</span>
<span class=sd>            The description to set for the command.</span>
<span class=sd>            This should be inclusively between 1-100 characters in length.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.SlashCommandBuilder</span>
<span class=sd>            The created command builder object.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>slash_command_builder</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>SlashCommandBuilder</span><span class=p>:</span>
        <span class=sa>r</span><span class=sd>"""Create a command builder for use in `RESTClient.set_application_commands`.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        name : str</span>
<span class=sd>            The command's name. This should match the regex `^[\w-]{1,32}$` in</span>
<span class=sd>            Unicode mode and be lowercase.</span>
<span class=sd>        description : str</span>
<span class=sd>            The description to set for the command if this is a slash command.</span>
<span class=sd>            This should be inclusively between 1-100 characters in length.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.SlashCommandBuilder</span>
<span class=sd>            The created command builder object.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>context_menu_command_builder</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=nb>type</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandType</span><span class=p>,</span> <span class=nb>int</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>ContextMenuCommandBuilder</span><span class=p>:</span>
        <span class=sa>r</span><span class=sd>"""Create a command builder for use in `RESTClient.set_application_commands`.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        type : commands.CommandType</span>
<span class=sd>            The commands's type.</span>
<span class=sd>        name : str</span>
<span class=sd>            The command's name.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.ContextMenuCommandBuilder</span>
<span class=sd>            The created command builder object.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_application_command</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>command</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>:</span>
        <span class=sd>"""Fetch a command set for an application.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to fetch a command for.</span>
<span class=sd>        command: hikari.snowflakes.SnowflakeishOr[hikari.commands.PartialCommand]</span>
<span class=sd>            Object or ID of the command to fetch.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or ID of the guild to fetch the command for. If left as</span>
<span class=sd>            `hikari.undefined.UNDEFINED` then this will return a global command,</span>
<span class=sd>            otherwise this will return a command made for the specified guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.commands.PartialCommand</span>
<span class=sd>            Object of the fetched command.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the target command.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the command isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_application_commands</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>]:</span>
        <span class=sd>"""Fetch the commands set for an application.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to fetch the commands for.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or ID of the guild to fetch the commands for. If left as</span>
<span class=sd>            `hikari.undefined.UNDEFINED` then this will only return the global</span>
<span class=sd>            commands, otherwise this will only return the commands set exclusively</span>
<span class=sd>            for the specific guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.commands.PartialCommand]</span>
<span class=sd>            A sequence of the commands declared for the provided application.</span>
<span class=sd>            This will exclusively either contain the commands set for a specific</span>
<span class=sd>            guild if `guild` is provided or the global commands if not.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the target guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_application_command</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>options</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandOption</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>default_permission</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>commands</span><span class=o>.</span><span class=n>SlashCommand</span><span class=p>:</span>
        <span class=sa>r</span><span class=sd>"""Create an application slash command.</span>

<span class=sd>        .. deprecated:: 2.0.0.dev106</span>
<span class=sd>            Use `RESTClient.create_slash_command` instead.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to create a command for.</span>
<span class=sd>        name : str</span>
<span class=sd>            The command's name. This should match the regex `^[\w-]{1,32}$` in</span>
<span class=sd>            Unicode mode and be lowercase.</span>
<span class=sd>        description : str</span>
<span class=sd>            The description to set for the command.</span>
<span class=sd>            This should be inclusively between 1-100 characters in length.</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or ID of the specific guild this should be made for.</span>
<span class=sd>            If left as `hikari.undefined.UNDEFINED` then this call will create</span>
<span class=sd>            a global command rather than a guild specific one.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        options : hikari.undefined.UndefinedOr[typing.Sequence[hikari.commands.CommandOption]]</span>
<span class=sd>            A sequence of up to 10 options for this command.</span>
<span class=sd>        default_permission : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            Whether this command should be enabled by default (without any</span>
<span class=sd>            permissions) when added to a guild.</span>

<span class=sd>            Defaults to `True`.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.commands.SlashCommand</span>
<span class=sd>            Object of the created command.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application isn't found.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_slash_command</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>options</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandOption</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>default_permission</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>commands</span><span class=o>.</span><span class=n>SlashCommand</span><span class=p>:</span>
        <span class=sa>r</span><span class=sd>"""Create an application command.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to create a command for.</span>
<span class=sd>        name : str</span>
<span class=sd>            The command's name. This should match the regex `^[\w-]{1,32}$` in</span>
<span class=sd>            Unicode mode and be lowercase.</span>
<span class=sd>        description : str</span>
<span class=sd>            The description to set for the command.</span>
<span class=sd>            This should be inclusively between 1-100 characters in length.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or ID of the specific guild this should be made for.</span>
<span class=sd>            If left as `hikari.undefined.UNDEFINED` then this call will create</span>
<span class=sd>            a global command rather than a guild specific one.</span>
<span class=sd>        options : hikari.undefined.UndefinedOr[typing.Sequence[hikari.commands.CommandOption]]</span>
<span class=sd>            A sequence of up to 10 options for this command.</span>
<span class=sd>        default_permission : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            Whether this command should be enabled by default (without any</span>
<span class=sd>            permissions) when added to a guild.</span>

<span class=sd>            Defaults to `True`.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.commands.SlashCommand</span>
<span class=sd>            Object of the created command.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application isn't found.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_context_menu_command</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=nb>type</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Literal</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandType</span><span class=o>.</span><span class=n>USER</span><span class=p>,</span> <span class=n>commands</span><span class=o>.</span><span class=n>CommandType</span><span class=o>.</span><span class=n>MESSAGE</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>default_permission</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>commands</span><span class=o>.</span><span class=n>ContextMenuCommand</span><span class=p>:</span>
        <span class=sa>r</span><span class=sd>"""Create an application command.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to create a command for.</span>
<span class=sd>        name : str</span>
<span class=sd>            The command's name. This should match the regex `^[\w-]{1,32}$` in</span>
<span class=sd>            Unicode mode and be lowercase.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or ID of the specific guild this should be made for.</span>
<span class=sd>            If left as `hikari.undefined.UNDEFINED` then this call will create</span>
<span class=sd>            a global command rather than a guild specific one.</span>
<span class=sd>        default_permission : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            Whether this command should be enabled by default (without any</span>
<span class=sd>            permissions) when added to a guild.</span>

<span class=sd>            Defaults to `True`.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.commands.ContextMenuCommand</span>
<span class=sd>            Object of the created command.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application isn't found.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>set_application_commands</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>commands</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>CommandBuilder</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>]:</span>
        <span class=sd>"""Set the commands for an application.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            Any existing commands not included in the provided commands array</span>
<span class=sd>            will be deleted.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to create a command for.</span>
<span class=sd>        commands: typing.Sequence[hikari.api.special_endpoints.CommandBuilder]</span>
<span class=sd>            A sequence of up to 100 initialised command builder objects of the</span>
<span class=sd>            commands to set for this the application.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or ID of the specific guild to set the commands for.</span>
<span class=sd>            If left as `hikari.undefined.UNDEFINED` then this set the global</span>
<span class=sd>            commands rather than guild specific commands.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.commands.PartialCommand]</span>
<span class=sd>            A sequence of the set command objects.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application isn't found.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_application_command</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>command</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>options</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandOption</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>:</span>
        <span class=sd>"""Edit a registered application command.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to edit a command for.</span>
<span class=sd>        command : hikari.snowflakes.SnowflakeishOr[hikari.commands.PartialCommand]</span>
<span class=sd>            Object or ID of the command to modify.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]]</span>
<span class=sd>            Object or ID of the guild to edit a command for if this is a guild</span>
<span class=sd>            specific command. Leave this as `hikari.undefined.UNDEFINED` to delete</span>
<span class=sd>            a global command.</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            The name to set for the command. Leave as `hikari.undefined.UNDEFINED`</span>
<span class=sd>            to not change.</span>
<span class=sd>        description : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            The description to set for the command. Leave as `hikari.undefined.UNDEFINED`</span>
<span class=sd>            to not change.</span>
<span class=sd>        options : hikari.undefined.UndefinedOr[typing.Sequence[hikari.commands.CommandOption]]</span>
<span class=sd>            A sequence of up to 10 options to set for this command. Leave this as</span>
<span class=sd>            `hikari.undefined.UNDEFINED` to not change.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.commands.PartialCommand</span>
<span class=sd>            The edited command object.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application or command isn't found.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_application_command</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>command</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a registered application command.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to delete a command for.</span>
<span class=sd>        command : hikari.snowflakes.SnowflakeishOr[hikari.commands.PartialCommand]</span>
<span class=sd>            Object or ID of the command to delete.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]]</span>
<span class=sd>            Object or ID of the guild to delete a command for if this is a guild</span>
<span class=sd>            specific command. Leave this as `hikari.undefined.UNDEFINED` to</span>
<span class=sd>            delete a global command.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application or command isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_application_guild_commands_permissions</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>GuildCommandPermissions</span><span class=p>]:</span>
        <span class=sd>"""Fetch the command permissions registered in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to fetch the command permissions for.</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]]</span>
<span class=sd>            Object or ID of the guild to fetch the command permissions for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.commands.GuildCommandPermissions]</span>
<span class=sd>            Sequence of the guild command permissions set for the specified guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands or guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_application_command_permissions</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>command</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>commands</span><span class=o>.</span><span class=n>GuildCommandPermissions</span><span class=p>:</span>
        <span class=sd>"""Fetch the permissions registered for a specific command in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to fetch the command permissions for.</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]]</span>
<span class=sd>            Object or ID of the guild to fetch the command permissions for.</span>
<span class=sd>        command: hikari.snowflakes.SnowflakeishOr[hikari.commands.PartialCommand]</span>
<span class=sd>            Objecr or ID of the command to fetch the command permissions for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.commands.GuildCommandPermissions</span>
<span class=sd>            Object of the command permissions set for the specified command.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands or guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application or command isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>set_application_guild_commands_permissions</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>permissions</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Mapping</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>],</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandPermission</span><span class=p>]</span>
        <span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>GuildCommandPermissions</span><span class=p>]:</span>
        <span class=sd>"""Set permissions in a guild for multiple commands.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This overwrites any previously set permissions for the specified</span>
<span class=sd>            commands.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to set the command permissions for.</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]]</span>
<span class=sd>            Object or ID of the guild to set the command permissions for.</span>
<span class=sd>        permissions : typing.Mapping[hikari.snowflakes.SnowflakeishOr[hikari.commands.PartialCommand], typing.Sequence[hikari.commands.CommandPermission]]</span>
<span class=sd>            Mapping of objects and/or IDs of commands to sequences of the commands</span>
<span class=sd>            to set for the specified guild.</span>

<span class=sd>            .. warning::</span>
<span class=sd>                Only a maximum of up to 10 permissions can be set per command.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.commands.GuildCommandPermissions]</span>
<span class=sd>            Sequence of the set guild command permissions.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands or guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application or command isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>set_application_command_permissions</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>command</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>],</span>
        <span class=n>permissions</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandPermission</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>commands</span><span class=o>.</span><span class=n>GuildCommandPermissions</span><span class=p>:</span>
        <span class=sd>"""Set permissions for a specific command.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This overwrites any previously set permissions.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to set the command permissions for.</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]]</span>
<span class=sd>            Object or ID of the guild to set the command permissions for.</span>
<span class=sd>        command : hikari.snowflakes.SnowflakeishOr[hikari.commands.PartialCommand]</span>
<span class=sd>            Object or ID of the command to set the permissions for.</span>
<span class=sd>        permissions : typing.Sequence[hikari.commands.CommandPermission]</span>
<span class=sd>            Sequence of up to 10 of the permission objects to set.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.commands.GuildCommandPermissions</span>
<span class=sd>            Object of the set permissions.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands or guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application or command isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>interaction_deferred_builder</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=nb>type</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>base_interactions</span><span class=o>.</span><span class=n>ResponseType</span><span class=p>,</span> <span class=nb>int</span><span class=p>],</span> <span class=o>/</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>InteractionDeferredBuilder</span><span class=p>:</span>
        <span class=sd>"""Create a builder for a deferred message interaction response.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        type: typing.Union[hikari.interactions.base_interactions.ResponseType, int]</span>
<span class=sd>            The type of deferred message response this builder is for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.InteractionDeferredBuilder</span>
<span class=sd>            The deferred message interaction response builder object.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>interaction_autocomplete_builder</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>choices</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandChoice</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>InteractionAutocompleteBuilder</span><span class=p>:</span>
        <span class=sd>"""Create a builder for an autocomplete interaction response.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.InteractionAutocompleteBuilder</span>
<span class=sd>            The autocomplete interaction response builder object.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>interaction_message_builder</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=nb>type</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>base_interactions</span><span class=o>.</span><span class=n>ResponseType</span><span class=p>,</span> <span class=nb>int</span><span class=p>],</span> <span class=o>/</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>InteractionMessageBuilder</span><span class=p>:</span>
        <span class=sd>"""Create a builder for a message interaction response.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        type : typing.Union[hikari.interactions.base_interactions.ResponseType, int]</span>
<span class=sd>            The type of message response this builder is for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.InteractionMessageBuilder</span>
<span class=sd>            The interaction message response builder object.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_interaction_response</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span> <span class=n>token</span><span class=p>:</span> <span class=nb>str</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Fetch the initial response for an interaction.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to fetch a command for.</span>
<span class=sd>        token: str</span>
<span class=sd>            Token of the interaction to get the initial response for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            Message object of the initial response.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the target interaction.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the initial response isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_interaction_response</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>interaction</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>base_interactions</span><span class=o>.</span><span class=n>PartialInteraction</span><span class=p>],</span>
        <span class=n>token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>response_type</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=n>base_interactions</span><span class=o>.</span><span class=n>ResponseType</span><span class=p>],</span>
        <span class=n>content</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Any</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>flags</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=n>messages_</span><span class=o>.</span><span class=n>MessageFlag</span><span class=p>,</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedType</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>tts</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachment</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachments</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>component</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>components</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embed</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embeds</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mentions_everyone</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>role_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Create the initial response for a interaction.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            Calling this with an interaction which already has an initial</span>
<span class=sd>            response will result in this raising a `hikari.errors.NotFoundError`.</span>
<span class=sd>            This includes if the REST interaction server has already responded</span>
<span class=sd>            to the request.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        interaction : hikari.snowflakes.SnowflakeishOr[hikari.interactions.base_interactions.PartialInteraction]</span>
<span class=sd>            Object or ID of the interaction this response is for.</span>
<span class=sd>        token : str</span>
<span class=sd>            The command interaction's token.</span>
<span class=sd>        response_type : typing.Union[int, hikari.interactions.base_interactions.ResponseType]</span>
<span class=sd>            The type of interaction response this is.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        content : hikari.undefined.UndefinedOr[typing.Any]</span>
<span class=sd>            If provided, the message contents. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then nothing will be sent</span>
<span class=sd>            in the content. Any other value here will be cast to a</span>
<span class=sd>            `str`.</span>

<span class=sd>            If this is a `hikari.embeds.Embed` and no `embed` nor</span>
<span class=sd>            no `embeds` kwarg is provided, then this will instead</span>
<span class=sd>            update the embed. This allows for simpler syntax when</span>
<span class=sd>            sending an embed alone.</span>
<span class=sd>        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish],</span>
<span class=sd>            If provided, the message attachment. This can be a resource,</span>
<span class=sd>            or string of a path on your computer or a URL.</span>
<span class=sd>        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]],</span>
<span class=sd>            If provided, the message attachments. These can be resources, or</span>
<span class=sd>            strings consisting of paths on your computer or URLs.</span>
<span class=sd>        component : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder]</span>
<span class=sd>            If provided, builder object of the component to include in this message.</span>
<span class=sd>        components : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]</span>
<span class=sd>            If provided, a sequence of the component builder objects to include</span>
<span class=sd>            in this message.</span>
<span class=sd>        embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed]</span>
<span class=sd>            If provided, the message embed.</span>
<span class=sd>        embeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed]]</span>
<span class=sd>            If provided, the message embeds.</span>
<span class=sd>        flags : typing.Union[int, hikari.messages.MessageFlag, hikari.undefined.UndefinedType]</span>
<span class=sd>            If provided, the message flags this response should have.</span>

<span class=sd>            As of writing the only message flag which can be set here is</span>
<span class=sd>            `hikari.messages.MessageFlag.EPHEMERAL`.</span>
<span class=sd>        tts : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the message will be read out by a screen</span>
<span class=sd>            reader using Discord's TTS (text-to-speech) system.</span>
<span class=sd>        mentions_everyone : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the message should parse @everyone/@here</span>
<span class=sd>            mentions.</span>
<span class=sd>        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], bool]]</span>
<span class=sd>            If provided, and `True`, all user mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all user mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.users.PartialUser` derivatives to enforce mentioning</span>
<span class=sd>            specific users.</span>
<span class=sd>        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], bool]]</span>
<span class=sd>            If provided, and `True`, all role mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all role mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.guilds.PartialRole` derivatives to enforce mentioning</span>
<span class=sd>            specific roles.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        ValueError</span>
<span class=sd>            If more than 100 unique objects/entities are passed for</span>
<span class=sd>            `role_mentions` or `user_mentions`.</span>
<span class=sd>        TypeError</span>
<span class=sd>            If both `embed` and `embeds` are specified.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            This may be raised in several discrete situations, such as messages</span>
<span class=sd>            being empty with no embeds; messages with more than 2000 characters</span>
<span class=sd>            in them, embeds that exceed one of the many embed limits</span>
<span class=sd>            invalid image URLs in embeds.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the interaction is not found or if the interaction's initial</span>
<span class=sd>            response has already been created.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_interaction_response</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>content</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Any</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>attachment</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachments</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>component</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>components</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embed</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embeds</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>replace_attachments</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
        <span class=n>mentions_everyone</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>role_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Edit the initial response to a command interaction.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        Mentioning everyone, roles, or users in message edits currently</span>
<span class=sd>        will not send a push notification showing a new mention to people</span>
<span class=sd>        on Discord. It will still highlight in their chat as if they</span>
<span class=sd>        were mentioned, however.</span>

<span class=sd>        Also important to note that if you specify a text `content`, `mentions_everyone`,</span>
<span class=sd>        `mentions_reply`, `user_mentions`, and `role_mentions` will default</span>
<span class=sd>        to `False` as the message will be re-parsed for mentions. This will</span>
<span class=sd>        also occur if only one of the four are specified</span>

<span class=sd>        This is a limitation of Discord's design. If in doubt, specify all</span>
<span class=sd>        four of them each time.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to edit a command response for.</span>
<span class=sd>        token : str</span>
<span class=sd>            The interaction's token.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        content : hikari.undefined.UndefinedOr[typing.Any]</span>
<span class=sd>            If provided, the message content to update with. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then the content will not</span>
<span class=sd>            be changed. If `None`, then the content will be removed.</span>

<span class=sd>            Any other value will be cast to a `str` before sending.</span>

<span class=sd>            If this is a `hikari.embeds.Embed` and neither the</span>
<span class=sd>            `embed` or `embeds` kwargs are provided or if this is a</span>
<span class=sd>            `hikari.files.Resourceish` and neither the `attachment` or</span>
<span class=sd>            `attachments` kwargs are provided, the values will be overwritten.</span>
<span class=sd>            This allows for simpler syntax when sending an embed or an</span>
<span class=sd>            attachment alone.</span>
<span class=sd>        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the attachment to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous attachment, if</span>
<span class=sd>            present, is not changed. If this is `None`, then the</span>
<span class=sd>            attachment is removed, if present. Otherwise, the new attachment</span>
<span class=sd>            that was provided will be attached.</span>
<span class=sd>        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]]</span>
<span class=sd>            If provided, the attachments to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous attachments, if</span>
<span class=sd>            present, are not changed. If this is `None`, then the</span>
<span class=sd>            attachments is removed, if present. Otherwise, the new attachments</span>
<span class=sd>            that were provided will be attached.</span>
<span class=sd>        component : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder]</span>
<span class=sd>            If provided, builder object of the component to set for this message.</span>
<span class=sd>            This component will replace any previously set components and passing</span>
<span class=sd>            `None` will remove all components.</span>
<span class=sd>        components : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]</span>
<span class=sd>            If provided, a sequence of the component builder objects set for</span>
<span class=sd>            this message. These components will replace any previously set</span>
<span class=sd>            components and passing `None` or an empty sequence will</span>
<span class=sd>            remove all components.</span>
<span class=sd>        embed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed]</span>
<span class=sd>            If provided, the embed to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.</span>
<span class=sd>            If this is `None` then any present embeds are removed.</span>
<span class=sd>            Otherwise, the new embed that was provided will be used as the</span>
<span class=sd>            replacement.</span>
<span class=sd>        embeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed]]</span>
<span class=sd>            If provided, the embeds to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.</span>
<span class=sd>            If this is `None` then any present embeds are removed.</span>
<span class=sd>            Otherwise, the new embeds that were provided will be used as the</span>
<span class=sd>            replacement.</span>
<span class=sd>        replace_attachments: bool</span>
<span class=sd>            Whether to replace the attachments with the provided ones. Defaults</span>
<span class=sd>            to `False`.</span>

<span class=sd>            Note this will also overwrite the embed attachments.</span>
<span class=sd>        mentions_everyone : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the message should parse @everyone/@here</span>
<span class=sd>            mentions.</span>
<span class=sd>        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], bool]]</span>
<span class=sd>            If provided, and `True`, all user mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all user mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.users.PartialUser` derivatives to enforce mentioning</span>
<span class=sd>            specific users.</span>
<span class=sd>        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], bool]]</span>
<span class=sd>            If provided, and `True`, all role mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all role mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.guilds.PartialRole` derivatives to enforce mentioning</span>
<span class=sd>            specific roles.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The edited message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        ValueError</span>
<span class=sd>            If both `attachment` and `attachments`, `component` and `components`</span>
<span class=sd>            or `embed` and `embeds` are specified.</span>
<span class=sd>        TypeError</span>
<span class=sd>            If `attachments`, `components` or `embeds` is passed but is not a</span>
<span class=sd>            sequence.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            This may be raised in several discrete situations, such as messages</span>
<span class=sd>            being empty with no attachments or embeds; messages with more than</span>
<span class=sd>            2000 characters in them, embeds that exceed one of the many embed</span>
<span class=sd>            limits; too many attachments; attachments that are too large;</span>
<span class=sd>            invalid image URLs in embeds; too many components.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the interaction or the message are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_interaction_response</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span> <span class=n>token</span><span class=p>:</span> <span class=nb>str</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete the initial response of an interaction.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to delete a command response for.</span>
<span class=sd>        token : str</span>
<span class=sd>            The interaction's token.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the interaction or response is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_autocomplete_response</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>interaction</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>base_interactions</span><span class=o>.</span><span class=n>PartialInteraction</span><span class=p>],</span>
        <span class=n>token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>choices</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandChoice</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Create the initial response for an autocomplete interaction.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        interaction : hikari.snowflakes.SnowflakeishOr[hikari.interactions.base_interactions.PartialInteraction]</span>
<span class=sd>            Object or ID of the interaction this response is for.</span>
<span class=sd>        token : str</span>
<span class=sd>            The command interaction's token.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        choices : typing.Sequence[commands.CommandChoice]</span>
<span class=sd>            The autocomplete choices themselves.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the interaction is not found or if the interaction's initial</span>
<span class=sd>            response has already been created.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>build_action_row</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>ActionRowBuilder</span><span class=p>:</span>
        <span class=sd>"""Build an action row message component for use in message create and REST calls.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.ActionRowBuilder</span>
<span class=sd>            The initialised action row builder.</span>
<span class=sd>        """</span>
</pre></div></details></section><section id=RESTClient><div class="attr class"><a class=headerlink href=#RESTClient>#  </a><span class=def>class </span><span class=name>RESTClient</span><wbr>(<span class=base><a href=../traits.html#NetworkSettingsAware>hikari.traits.NetworkSettingsAware</a></span>, <span class=base>abc.ABC</span>):</div><details><summary>View Source</summary> <div class=codehilite><pre><span></span><span class=k>class</span> <span class=nc>RESTClient</span><span class=p>(</span><span class=n>traits</span><span class=o>.</span><span class=n>NetworkSettingsAware</span><span class=p>,</span> <span class=n>abc</span><span class=o>.</span><span class=n>ABC</span><span class=p>):</span>
    <span class=sd>"""Interface for functionality that a REST API implementation provides."""</span>

    <span class=vm>__slots__</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=p>()</span>

    <span class=nd>@property</span>
    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>is_alive</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=nb>bool</span><span class=p>:</span>
        <span class=sd>"""Whether this component is alive."""</span>

    <span class=nd>@property</span>
    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>entity_factory</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>entity_factory_</span><span class=o>.</span><span class=n>EntityFactory</span><span class=p>:</span>
        <span class=sd>"""Entity factory used by this REST client."""</span>

    <span class=nd>@property</span>
    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>token_type</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>applications</span><span class=o>.</span><span class=n>TokenType</span><span class=p>,</span> <span class=kc>None</span><span class=p>]:</span>
        <span class=sd>"""Type of token this client is using for most requests.</span>

<span class=sd>        If this is `None` then this client will likely only work</span>
<span class=sd>        for some endpoints such as public and webhook ones.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>close</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Close the client session."""</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PartialChannel</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>PartialChannel</span><span class=p>:</span>
        <span class=sd>"""Fetch a channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel]</span>
<span class=sd>            The channel to fetch. This may be the object or the ID of an</span>
<span class=sd>            existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.PartialChannel</span>
<span class=sd>            The channel. This will be a _derivative_ of</span>
<span class=sd>            `hikari.channels.PartialChannel`, depending on the type of</span>
<span class=sd>            channel you request for.</span>

<span class=sd>            This means that you may get one of</span>
<span class=sd>            `hikari.channels.DMChannel`,</span>
<span class=sd>            `hikari.channels.GroupDMChannel`,</span>
<span class=sd>            `hikari.channels.GuildTextChannel`,</span>
<span class=sd>            `hikari.channels.GuildVoiceChannel`,</span>
<span class=sd>            `hikari.channels.GuildStoreChannel`,</span>
<span class=sd>            `hikari.channels.GuildNewsChannel`.</span>

<span class=sd>            Likewise, the `hikari.channels.GuildChannel` can be used to</span>
<span class=sd>            determine if a channel is guild-bound, and</span>
<span class=sd>            `hikari.channels.TextableChannel` can be used to determine</span>
<span class=sd>            if the channel provides textual functionality to the application.</span>

<span class=sd>            You can check for these using the `isinstance`</span>
<span class=sd>            builtin function.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `READ_MESSAGES` permission in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>],</span>
        <span class=o>/</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>position</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>topic</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>nsfw</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>bitrate</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>video_quality_mode</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>VideoQualityMode</span><span class=p>,</span> <span class=nb>int</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_limit</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>rate_limit_per_user</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>time</span><span class=o>.</span><span class=n>Intervalish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>region</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>voices</span><span class=o>.</span><span class=n>VoiceRegion</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permission_overwrites</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>parent_category</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildCategory</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>PartialChannel</span><span class=p>:</span>
        <span class=sd>"""Edit a channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]</span>
<span class=sd>            The channel to edit. This may be the object or the ID of an</span>
<span class=sd>            existing channel.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[[str]</span>
<span class=sd>            If provided, the new name for the channel.</span>
<span class=sd>        position : hikari.undefined.UndefinedOr[[int]</span>
<span class=sd>            If provided, the new position for the channel.</span>
<span class=sd>        topic : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new topic for the channel.</span>
<span class=sd>        nsfw : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the channel should be marked as NSFW or not.</span>
<span class=sd>        bitrate : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the new bitrate for the channel.</span>
<span class=sd>        video_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, int]]</span>
<span class=sd>            If provided, the new video quality mode for the channel.</span>
<span class=sd>        user_limit : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the new user limit in the channel.</span>
<span class=sd>        rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]</span>
<span class=sd>            If provided, the new rate limit per user in the channel.</span>
<span class=sd>        region : hikari.undefined.UndefinedOr[typing.Union[str, hikari.voices.VoiceRegion]]</span>
<span class=sd>            If provided, the voice region to set for this channel. Passing</span>
<span class=sd>            `None` here will set it to "auto" mode where the used</span>
<span class=sd>            region will be decided based on the first person who connects to it</span>
<span class=sd>            when it's empty.</span>
<span class=sd>        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]</span>
<span class=sd>            If provided, the new permission overwrites for the channel.</span>
<span class=sd>        parent_category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]</span>
<span class=sd>            If provided, the new guild category for the channel.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.PartialChannel</span>
<span class=sd>            The edited channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing permissions to edit the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>follow_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>news_channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildNewsChannel</span><span class=p>],</span>
        <span class=n>target_channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>ChannelFollow</span><span class=p>:</span>
        <span class=sd>"""Follow a news channel to send messages to a target channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        news_channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildNewsChannel]</span>
<span class=sd>            The object or ID of the news channel to follow.</span>
<span class=sd>        target_channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]</span>
<span class=sd>            The object or ID of the channel to target.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.ChannelFollow</span>
<span class=sd>            Information about the new relationship that was made.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If you try to follow a channel that's not a news channel or if the</span>
<span class=sd>            target channel has reached it's webhook limit, which is 10 at the</span>
<span class=sd>            time of writing.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_WEBHOOKS` permission in the target</span>
<span class=sd>            channel or are missing the `VIEW_CHANNEL` permission in the origin</span>
<span class=sd>            channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the origin or target channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PartialChannel</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>PartialChannel</span><span class=p>:</span>
        <span class=sd>"""Delete a channel in a guild, or close a DM.</span>

<span class=sd>        .. note::</span>
<span class=sd>            For Public servers, the set 'Rules' or 'Guidelines' channels and the</span>
<span class=sd>            'Public Server Updates' channel cannot be deleted.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel]</span>
<span class=sd>            The channel to delete. This may be the object or the ID of an</span>
<span class=sd>            existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.PartialChannel</span>
<span class=sd>            Object of the channel that was deleted.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_my_voice_state</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildStageChannel</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>suppress</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>request_to_speak</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedType</span><span class=p>,</span> <span class=nb>bool</span><span class=p>,</span> <span class=n>datetime</span><span class=o>.</span><span class=n>datetime</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Edit the current user's voice state in a stage channel.</span>

<span class=sd>        .. note::</span>
<span class=sd>            The current user has to have already joined the target stage channel</span>
<span class=sd>            before any calls can be made to this endpoint.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or Id of the guild to edit a voice state in.</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildStageChannel]</span>
<span class=sd>            Object or Id of the channel to edit a voice state in.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        suppress : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If specified, whether the user should be allowed to become a speaker</span>
<span class=sd>            in the target stage channel with `builtin.True` suppressing them from</span>
<span class=sd>            becoming one.</span>
<span class=sd>        request_to_speak : typing.Union[hikari.undefined.UndefinedType, bool, datetime.datetime]</span>
<span class=sd>            Whether to request to speak. This may be one of the following:</span>

<span class=sd>            * `True` to indicate that the bot wants to speak.</span>
<span class=sd>            * `False` to remove any previously set request to speak.</span>
<span class=sd>            * `datetime.datetime` to specify when they want their request to</span>
<span class=sd>                speak timestamp to be set to. If a datetime from the past is</span>
<span class=sd>                passed then Discord will use the current time instead.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If you try to target a non-staging channel.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MUTE_MEMBERS` permission in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel, message or voice state is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_voice_state</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildStageChannel</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>suppress</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Edit an existing voice state in a stage channel.</span>

<span class=sd>        .. note::</span>
<span class=sd>            The target user must already be present in the stage channel before</span>
<span class=sd>            any calls are made to this endpoint.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or Id of the guild to edit a voice state in.</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildStageChannel]</span>
<span class=sd>            Object or Id of the channel to edit a voice state in.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            Object or Id of the user to to edit the voice state of.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        suppress : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If defined, whether the user should be allowed to become a speaker</span>
<span class=sd>            in the target stage channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If you try to target a non-staging channel.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MUTE_MEMBERS` permission in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel, message or voice state is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@typing</span><span class=o>.</span><span class=n>overload</span>
    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_permission_overwrites</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>],</span>
        <span class=n>target</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>,</span> <span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>,</span> <span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>allow</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>permissions_</span><span class=o>.</span><span class=n>Permissions</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>deny</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>permissions_</span><span class=o>.</span><span class=n>Permissions</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Edit permissions for a target entity."""</span>

    <span class=nd>@typing</span><span class=o>.</span><span class=n>overload</span>
    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_permission_overwrites</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>],</span>
        <span class=n>target</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>Snowflakeish</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>target_type</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwriteType</span><span class=p>,</span> <span class=nb>int</span><span class=p>],</span>
        <span class=n>allow</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>permissions_</span><span class=o>.</span><span class=n>Permissions</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>deny</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>permissions_</span><span class=o>.</span><span class=n>Permissions</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Edit permissions for a given entity ID and type."""</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_permission_overwrites</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>],</span>
        <span class=n>target</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>Snowflakeish</span><span class=p>,</span> <span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>,</span> <span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>,</span> <span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span>
        <span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>target_type</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwriteType</span><span class=p>,</span> <span class=nb>int</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>allow</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>permissions_</span><span class=o>.</span><span class=n>Permissions</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>deny</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>permissions_</span><span class=o>.</span><span class=n>Permissions</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Edit permissions for a specific entity in the given guild channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]</span>
<span class=sd>            The channel to edit a permission overwrite in. This may be the</span>
<span class=sd>            object, or the ID of an existing channel.</span>
<span class=sd>        target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish]</span>
<span class=sd>            The channel overwrite to edit. This may be the object or the ID of an</span>
<span class=sd>            existing overwrite.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        target_type : hikari.undefined.UndefinedOr[typing.Union[hikari.channels.PermissionOverwriteType, int]]</span>
<span class=sd>            If provided, the type of the target to update. If unset, will attempt to get</span>
<span class=sd>            the type from `target`.</span>
<span class=sd>        allow : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]</span>
<span class=sd>            If provided, the new vale of all allowed permissions.</span>
<span class=sd>        deny : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]</span>
<span class=sd>            If provided, the new vale of all disallowed permissions.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        TypeError</span>
<span class=sd>            If `target_type` is unset and we were unable to determine the type</span>
<span class=sd>            from `target`.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_PERMISSIONS` permission in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found or the target is not found if it is</span>
<span class=sd>            a role.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_permission_overwrite</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>],</span>
        <span class=n>target</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span>
            <span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>,</span> <span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>,</span> <span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>,</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>Snowflakeish</span>
        <span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a custom permission for an entity in a given guild channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]</span>
<span class=sd>            The channel to delete a permission overwrite in. This may be the</span>
<span class=sd>            object, or the ID of an existing channel.</span>
<span class=sd>        target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish]</span>
<span class=sd>            The channel overwrite to delete.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_PERMISSIONS` permission in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found or the target is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_channel_invites</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>invites</span><span class=o>.</span><span class=n>InviteWithMetadata</span><span class=p>]:</span>
        <span class=sd>"""Fetch all invites pointing to the given guild channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]</span>
<span class=sd>            The channel to fetch the invites from. This may be a channel</span>
<span class=sd>            object, or the ID of an existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.invites.InviteWithMetadata]</span>
<span class=sd>            The invites pointing to the given guild channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found in any guilds you are a member of.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_invite</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>max_age</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>time</span><span class=o>.</span><span class=n>Intervalish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>max_uses</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>temporary</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>unique</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>target_type</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>invites</span><span class=o>.</span><span class=n>TargetType</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>target_user</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>target_application</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>invites</span><span class=o>.</span><span class=n>InviteWithMetadata</span><span class=p>:</span>
        <span class=sd>"""Create an invite to the given guild channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]</span>
<span class=sd>            The channel to create a invite for. This may be the object</span>
<span class=sd>            or the ID of an existing channel.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        max_age : hikari.undefined.UndefinedOr[typing.Union[datetime.timedelta, float, int]]</span>
<span class=sd>            If provided, the duration of the invite before expiry.</span>
<span class=sd>        max_uses : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the max uses the invite can have.</span>
<span class=sd>        temporary : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the invite only grants temporary membership.</span>
<span class=sd>        unique : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the invite should be unique.</span>
<span class=sd>        target_type : hikari.undefined.UndefinedOr[hikari.invites.TargetType]</span>
<span class=sd>            If provided, the target type of this invite.</span>
<span class=sd>        target_user : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]]</span>
<span class=sd>            If provided, the target user id for this invite. This may be the</span>
<span class=sd>            object or the ID of an existing user.</span>

<span class=sd>            .. note::</span>
<span class=sd>                This is required if `target_type` is `STREAM` and the targeted</span>
<span class=sd>                user must be streaming into the channel.</span>
<span class=sd>        target_application : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]]</span>
<span class=sd>            If provided, the target application id for this invite. This may be</span>
<span class=sd>            the object or the ID of an existing application.</span>

<span class=sd>            .. note::</span>
<span class=sd>                This is required if `target_type` is `EMBEDDED_APPLICATION` and</span>
<span class=sd>                the targeted application must have the `EMBEDDED` flag.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.invites.InviteWithMetadata</span>
<span class=sd>            The invite to the given guild channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNELS` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found, or if the target user does not exist,</span>
<span class=sd>            if provided.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>trigger_typing</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>TypingIndicator</span><span class=p>:</span>
        <span class=sd>"""Trigger typing in a text channel.</span>

<span class=sd>        .. note::</span>
<span class=sd>            The result of this call can be awaited to trigger typing once, or</span>
<span class=sd>            can be used as an async context manager to continually type until the</span>
<span class=sd>            context manager is left. Any errors documented below will happen then.</span>

<span class=sd>        Examples</span>
<span class=sd>        --------</span>
<span class=sd>        ```py</span>
<span class=sd>        # Trigger typing just once.</span>
<span class=sd>        await rest.trigger_typing(channel)</span>

<span class=sd>        # Trigger typing repeatedly for 1 minute.</span>
<span class=sd>        async with rest.trigger_typing(channel):</span>
<span class=sd>            await asyncio.sleep(60)</span>
<span class=sd>        ```</span>

<span class=sd>        .. warning::</span>
<span class=sd>            Sending a message to the channel will cause the typing indicator</span>
<span class=sd>            to disappear until it is re-triggered.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to trigger typing in. This may be the object or</span>
<span class=sd>            the ID of an existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.TypingIndicator</span>
<span class=sd>            A typing indicator to use.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `SEND_MESSAGES` in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_pins</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>]:</span>
        <span class=sd>"""Fetch the pinned messages in this text channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to fetch pins from. This may be the object or</span>
<span class=sd>            the ID of an existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.messages.Message]</span>
<span class=sd>            The pinned messages in this text channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `READ_MESSAGES` in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>pin_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Pin an existing message in the given text channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to pin a message in. This may be the object or</span>
<span class=sd>            the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to pin. This may be the object or the ID</span>
<span class=sd>            of an existing message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_MESSAGES` in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found, or if the message does not exist in</span>
<span class=sd>            the given channel.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>unpin_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Unpin a given message from a given text channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to unpin a message in. This may be the object or</span>
<span class=sd>            the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to unpin. This may be the object or the ID of an</span>
<span class=sd>            existing message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_MESSAGES` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found or the message is not a pinned message</span>
<span class=sd>            in the given channel.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>fetch_messages</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>before</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SearchableSnowflakeishOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>Unique</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>after</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SearchableSnowflakeishOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>Unique</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>around</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SearchableSnowflakeishOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>Unique</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>iterators</span><span class=o>.</span><span class=n>LazyIterator</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>]:</span>
        <span class=sd>"""Browse the message history for a given text channel.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        This call is not a coroutine function, it returns a special type of</span>
<span class=sd>        lazy iterator that will perform API calls as you iterate across it,</span>
<span class=sd>        thus any errors documented below will happen then.</span>

<span class=sd>        See `hikari.iterators` for the full API for this iterator type.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to fetch messages in. This may be the object or</span>
<span class=sd>            the ID of an existing channel.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]</span>
<span class=sd>            If provided, fetch messages before this snowflake. If you provide</span>
<span class=sd>            a datetime object, it will be transformed into a snowflake. This</span>
<span class=sd>            may be any other Discord entity that has an ID. In this case, the</span>
<span class=sd>            date the object was first created will be used.</span>
<span class=sd>        after : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]</span>
<span class=sd>            If provided, fetch messages after this snowflake. If you provide</span>
<span class=sd>            a datetime object, it will be transformed into a snowflake. This</span>
<span class=sd>            may be any other Discord entity that has an ID. In this case, the</span>
<span class=sd>            date the object was first created will be used.</span>
<span class=sd>        around : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]</span>
<span class=sd>            If provided, fetch messages around this snowflake. If you provide</span>
<span class=sd>            a datetime object, it will be transformed into a snowflake. This</span>
<span class=sd>            may be any other Discord entity that has an ID. In this case, the</span>
<span class=sd>            date the object was first created will be used.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.iterators.LazyIterator[hikari.messages.Message]</span>
<span class=sd>            An iterator to fetch the messages.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        TypeError</span>
<span class=sd>            If you specify more than one of `before`, `after`, `about`.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `READ_MESSAGE_HISTORY` in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Fetch a specific message in the given text channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to fetch messages in. This may be the object or</span>
<span class=sd>            the ID of an existing message.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to fetch. This may be the object or the ID of an</span>
<span class=sd>            existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The requested message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `READ_MESSAGE_HISTORY` in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found or the message is not found in the</span>
<span class=sd>            given text channel.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>content</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Any</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>attachment</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachments</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>component</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>components</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embed</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embeds</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>tts</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>nonce</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reply</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mentions_everyone</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mentions_reply</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>role_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Create a message in the given channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to create the message in.</span>
<span class=sd>        content : hikari.undefined.UndefinedOr[typing.Any]</span>
<span class=sd>            If provided, the message contents. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then nothing will be sent</span>
<span class=sd>            in the content. Any other value here will be cast to a</span>
<span class=sd>            `str`.</span>

<span class=sd>            If this is a `hikari.embeds.Embed` and no `embed` nor `embeds` kwarg</span>
<span class=sd>            is provided, then this will instead update the embed. This allows</span>
<span class=sd>            for simpler syntax when sending an embed alone.</span>

<span class=sd>            Likewise, if this is a `hikari.files.Resource`, then the</span>
<span class=sd>            content is instead treated as an attachment if no `attachment` and</span>
<span class=sd>            no `attachments` kwargs are provided.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish],</span>
<span class=sd>            If provided, the message attachment. This can be a resource,</span>
<span class=sd>            or string of a path on your computer or a URL.</span>

<span class=sd>            Attachments can be passed as many different things, to aid in</span>
<span class=sd>            convenience.</span>

<span class=sd>            - If a `pathlib.PurePath` or `str` to a valid URL, the</span>
<span class=sd>                resource at the given URL will be streamed to Discord when</span>
<span class=sd>                sending the message. Subclasses of</span>
<span class=sd>                `hikari.files.WebResource` such as</span>
<span class=sd>                `hikari.files.URL`,</span>
<span class=sd>                `hikari.messages.Attachment`,</span>
<span class=sd>                `hikari.emojis.Emoji`,</span>
<span class=sd>                `EmbedResource`, etc will also be uploaded this way.</span>
<span class=sd>                This will use bit-inception, so only a small percentage of the</span>
<span class=sd>                resource will remain in memory at any one time, thus aiding in</span>
<span class=sd>                scalability.</span>
<span class=sd>            - If a `hikari.files.Bytes` is passed, or a `str`</span>
<span class=sd>                that contains a valid data URI is passed, then this is uploaded</span>
<span class=sd>                with a randomized file name if not provided.</span>
<span class=sd>            - If a `hikari.files.File`, `pathlib.PurePath` or</span>
<span class=sd>                `str` that is an absolute or relative path to a file</span>
<span class=sd>                on your file system is passed, then this resource is uploaded</span>
<span class=sd>                as an attachment using non-blocking code internally and streamed</span>
<span class=sd>                using bit-inception where possible. This depends on the</span>
<span class=sd>                type of `concurrent.futures.Executor` that is being used for</span>
<span class=sd>                the application (default is a thread pool which supports this</span>
<span class=sd>                behaviour).</span>
<span class=sd>        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]],</span>
<span class=sd>            If provided, the message attachments. These can be resources, or</span>
<span class=sd>            strings consisting of paths on your computer or URLs.</span>
<span class=sd>        component : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder]</span>
<span class=sd>            If provided, builder object of the component to include in this message.</span>
<span class=sd>        components : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]</span>
<span class=sd>            If provided, a sequence of the component builder objects to include</span>
<span class=sd>            in this message.</span>
<span class=sd>        embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed]</span>
<span class=sd>            If provided, the message embed.</span>
<span class=sd>        embeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed]]</span>
<span class=sd>            If provided, the message embeds.</span>
<span class=sd>        tts : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the message will be read out by a screen</span>
<span class=sd>            reader using Discord's TTS (text-to-speech) system.</span>
<span class=sd>        nonce : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            An arbitrary identifier to associate with the message. This</span>
<span class=sd>            can be used to identify it later in received events. If provided,</span>
<span class=sd>            this must be less than 32 bytes. If not provided, then</span>
<span class=sd>            a null value is placed on the message instead. All users can</span>
<span class=sd>            see this value.</span>
<span class=sd>        reply : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]]</span>
<span class=sd>            If provided, the message to reply to.</span>
<span class=sd>        mentions_everyone : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the message should parse @everyone/@here</span>
<span class=sd>            mentions.</span>
<span class=sd>        mentions_reply : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to mention the author of the message</span>
<span class=sd>            that is being replied to.</span>

<span class=sd>            This will not do anything if not being used with `reply`.</span>
<span class=sd>        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], bool]]</span>
<span class=sd>            If provided, and `True`, all user mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all user mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.users.PartialUser` derivatives to enforce mentioning</span>
<span class=sd>            specific users.</span>
<span class=sd>        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], bool]]</span>
<span class=sd>            If provided, and `True`, all role mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all role mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.guilds.PartialRole` derivatives to enforce mentioning</span>
<span class=sd>            specific roles.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The created message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        ValueError</span>
<span class=sd>            If more than 100 unique objects/entities are passed for</span>
<span class=sd>            `role_mentions` or `user_mentions` or if both `attachment` and</span>
<span class=sd>            `attachments`, `component` and `components` or `embed` and `embeds`</span>
<span class=sd>            are specified.</span>
<span class=sd>        TypeError</span>
<span class=sd>            If `attachments`, `components` or `embeds` is passed but is not a</span>
<span class=sd>            sequence.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            This may be raised in several discrete situations, such as messages</span>
<span class=sd>            being empty with no attachments or embeds; messages with more than</span>
<span class=sd>            2000 characters in them, embeds that exceed one of the many embed</span>
<span class=sd>            limits; too many attachments; attachments that are too large;</span>
<span class=sd>            invalid image URLs in embeds; if `reply` is not found or not in the</span>
<span class=sd>            same channel as `channel`; too many components.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `SEND_MESSAGES` in the channel or the</span>
<span class=sd>            person you are trying to message has the DM's disabled.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>crosspost_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildNewsChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Broadcast an announcement message.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildNewsChannel]</span>
<span class=sd>            The object or ID of the news channel to crosspost a message in.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The object or ID of the message to crosspost.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The message object that was crossposted.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If you tried to crosspost a message that has already been broadcast.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you try to crosspost a message by the current user without the</span>
<span class=sd>            `SEND_MESSAGES` permission for the target news channel or try to</span>
<span class=sd>            crosspost a message by another user without both the `SEND_MESSAGES`</span>
<span class=sd>            and `MANAGE_MESSAGES` permissions for the target channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
        <span class=n>content</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Any</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>attachment</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachments</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>component</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>components</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embed</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embeds</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>replace_attachments</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
        <span class=n>mentions_everyone</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mentions_reply</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>role_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>flags</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>MessageFlag</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Edit an existing message in a given channel.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            If the message was not sent by your user, the only parameter</span>
<span class=sd>            you may provide to this call is the `flags` parameter. Anything</span>
<span class=sd>            else will result in a `hikari.errors.ForbiddenError` being raised.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        Mentioning everyone, roles, or users in message edits currently</span>
<span class=sd>        will not send a push notification showing a new mention to people</span>
<span class=sd>        on Discord. It will still highlight in their chat as if they</span>
<span class=sd>        were mentioned, however.</span>

<span class=sd>        Also important to note that if you specify a text `content`, `mentions_everyone`,</span>
<span class=sd>        `mentions_reply`, `user_mentions`, and `role_mentions` will default</span>
<span class=sd>        to `False` as the message will be re-parsed for mentions. This will</span>
<span class=sd>        also occur if only one of the four are specified</span>

<span class=sd>        This is a limitation of Discord's design. If in doubt, specify all</span>
<span class=sd>        four of them each time.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to create the message in. This may be</span>
<span class=sd>            the object or the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to edit. This may be the object or the ID</span>
<span class=sd>            of an existing message.</span>
<span class=sd>        content : hikari.undefined.UndefinedOr[typing.Any]</span>
<span class=sd>            If provided, the message content to update with. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then the content will not</span>
<span class=sd>            be changed. If `None`, then the content will be removed.</span>

<span class=sd>            Any other value will be cast to a `str` before sending.</span>

<span class=sd>            If this is a `hikari.embeds.Embed` and neither the `embed` or</span>
<span class=sd>            `embeds` kwargs are provided or if this is a</span>
<span class=sd>            `hikari.files.Resourceish` and neither the</span>
<span class=sd>            `attachment` or `attachments` kwargs are provided, the values will</span>
<span class=sd>            be overwritten. This allows for simpler syntax when sending an</span>
<span class=sd>            embed or an attachment alone.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the attachment to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous attachment, if</span>
<span class=sd>            present, is not changed. If this is `None`, then the</span>
<span class=sd>            attachment is removed, if present. Otherwise, the new attachment</span>
<span class=sd>            that was provided will be attached.</span>
<span class=sd>        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]]</span>
<span class=sd>            If provided, the attachments to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous attachments, if</span>
<span class=sd>            present, are not changed. If this is `None`, then the</span>
<span class=sd>            attachments is removed, if present. Otherwise, the new attachments</span>
<span class=sd>            that were provided will be attached.</span>
<span class=sd>        component : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder]</span>
<span class=sd>            If provided, builder object of the component to set for this message.</span>
<span class=sd>            This component will replace any previously set components and passing</span>
<span class=sd>            `None` will remove all components.</span>
<span class=sd>        components : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]</span>
<span class=sd>            If provided, a sequence of the component builder objects set for</span>
<span class=sd>            this message. These components will replace any previously set</span>
<span class=sd>            components and passing `None` or an empty sequence will</span>
<span class=sd>            remove all components.</span>
<span class=sd>        embed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed]</span>
<span class=sd>            If provided, the embed to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.</span>
<span class=sd>            If this is `None` then any present embeds are removed.</span>
<span class=sd>            Otherwise, the new embed that was provided will be used as the</span>
<span class=sd>            replacement.</span>
<span class=sd>        embeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed]]</span>
<span class=sd>            If provided, the embeds to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.</span>
<span class=sd>            If this is `None` then any present embeds are removed.</span>
<span class=sd>            Otherwise, the new embeds that were provided will be used as the</span>
<span class=sd>            replacement.</span>
<span class=sd>        replace_attachments: bool</span>
<span class=sd>            Whether to replace the attachments with the provided ones. Defaults</span>
<span class=sd>            to `False`.</span>

<span class=sd>            Note this will also overwrite the embed attachments.</span>
<span class=sd>        mentions_everyone : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, sanitation for `@everyone` mentions. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then the previous setting is</span>
<span class=sd>            not changed. If `True`, then `@everyone`/`@here` mentions</span>
<span class=sd>            in the message content will show up as mentioning everyone that can</span>
<span class=sd>            view the chat.</span>
<span class=sd>        mentions_reply : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to mention the author of the message</span>
<span class=sd>            that is being replied to.</span>

<span class=sd>            This will not do anything if `message` is not a reply message.</span>
<span class=sd>        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], bool]]</span>
<span class=sd>            If provided, sanitation for user mentions. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then the previous setting is</span>
<span class=sd>            not changed. If `True`, all valid user mentions will behave</span>
<span class=sd>            as mentions. If `False`, all valid user mentions will not</span>
<span class=sd>            behave as mentions.</span>

<span class=sd>            You may alternatively pass a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake` user IDs, or</span>
<span class=sd>            `hikari.users.PartialUser`-derived objects.</span>
<span class=sd>        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], bool]]</span>
<span class=sd>            If provided, sanitation for role mentions. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then the previous setting is</span>
<span class=sd>            not changed. If `True`, all valid role mentions will behave</span>
<span class=sd>            as mentions. If `False`, all valid role mentions will not</span>
<span class=sd>            behave as mentions.</span>

<span class=sd>            You may alternatively pass a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake` role IDs, or</span>
<span class=sd>            `hikari.guilds.PartialRole`-derived objects.</span>
<span class=sd>        flags : hikari.undefined.UndefinedOr[hikari.messages.MessageFlag]</span>
<span class=sd>            If provided, optional flags to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then nothing is changed.</span>

<span class=sd>            Note that some flags may not be able to be set. Currently the only</span>
<span class=sd>            flags that can be set are `NONE` and `SUPPRESS_EMBEDS`. If you</span>
<span class=sd>            have `MANAGE_MESSAGES` permissions, you can use this call to</span>
<span class=sd>            suppress embeds on another user's message.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The edited message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        ValueError</span>
<span class=sd>            If both `attachment` and `attachments`, `component` and `components`</span>
<span class=sd>            or `embed` and `embeds` are specified.</span>
<span class=sd>        TypeError</span>
<span class=sd>            If `attachments`, `components` or `embeds` is passed but is not a</span>
<span class=sd>            sequence.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            This may be raised in several discrete situations, such as messages</span>
<span class=sd>            being empty with no embeds; messages with more than 2000 characters</span>
<span class=sd>            in them, embeds that exceed one of the many embed</span>
<span class=sd>            limits; invalid image URLs in embeds.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `SEND_MESSAGES` in the channel; if you try to</span>
<span class=sd>            change the contents of another user's message; or if you try to edit</span>
<span class=sd>            the flags on another user's message without the `MANAGE_MESSAGES`</span>
<span class=sd>            permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a given message in a given channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to delete the message in. This may be</span>
<span class=sd>            the object or the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete. This may be the object or the ID of</span>
<span class=sd>            an existing message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_MESSAGES`, and the message is</span>
<span class=sd>            not sent by you.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_messages</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>messages</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishIterable</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
        <span class=p>],</span>
        <span class=o>/</span><span class=p>,</span>
        <span class=o>*</span><span class=n>other_messages</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Bulk-delete messages from the channel.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This API endpoint will only be able to delete 100 messages</span>
<span class=sd>            at a time. For anything more than this, multiple requests will</span>
<span class=sd>            be executed one-after-the-other, since the rate limits for this</span>
<span class=sd>            endpoint do not favour more than one request per bucket.</span>

<span class=sd>            If one message is left over from chunking per 100 messages, or</span>
<span class=sd>            only one message is passed to this coroutine function, then the</span>
<span class=sd>            logic is expected to defer to `delete_message`. The implication</span>
<span class=sd>            of this is that the `delete_message` endpoint is rate limited</span>
<span class=sd>            by a different bucket with different usage rates.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            This endpoint is not atomic. If an error occurs midway through</span>
<span class=sd>            a bulk delete, you will **not** be able to revert any changes made</span>
<span class=sd>            up to this point.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            Specifying any messages more than 14 days old will cause the call</span>
<span class=sd>            to fail, potentially with partial completion.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to bulk delete the messages in. This may be</span>
<span class=sd>            the object or the ID of an existing channel.</span>
<span class=sd>        messages : typing.Union[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage], hikari.snowflakes.SnowflakeishIterable[hikari.messages.PartialMessage]]</span>
<span class=sd>            Either the object/ID of an existing message to delete or an iterable</span>
<span class=sd>            of the objects and/or IDs of existing messages to delete.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        *other_messages : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The objects and/or IDs of other existing messages to delete.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BulkDeleteError</span>
<span class=sd>            An error containing the messages successfully deleted, and the</span>
<span class=sd>            messages that were not removed. The</span>
<span class=sd>            `BaseException.__cause__` of the exception will be the</span>
<span class=sd>            original error that terminated this process.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>add_reaction</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>emojis</span><span class=o>.</span><span class=n>Emoji</span><span class=p>],</span>
        <span class=n>emoji_id</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Add a reaction emoji to a message in a given channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel where the message to add the reaction to is. This</span>
<span class=sd>            may be a `hikari.channels.TextableChannel` or the ID of an existing</span>
<span class=sd>            channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to add a reaction to. This may be the</span>
<span class=sd>            object or the ID of an existing message.</span>
<span class=sd>        emoji : typing.Union[str, hikari.emojis.Emoji]</span>
<span class=sd>            Object or name of the emoji to react with.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]]</span>
<span class=sd>            ID of the custom emoji to react with.</span>
<span class=sd>            This should only be provided when a custom emoji's name is passed</span>
<span class=sd>            for `emoji`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid unicode emoji is given, or if the given custom emoji</span>
<span class=sd>            does not exist.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `ADD_REACTIONS` (this is only necessary if you</span>
<span class=sd>            are the first person to add the reaction).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_my_reaction</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>emojis</span><span class=o>.</span><span class=n>Emoji</span><span class=p>],</span>
        <span class=n>emoji_id</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a reaction that your application user created.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel where the message to delete the reaction from is.</span>
<span class=sd>            This may be the object or the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete a reaction from. This may be the</span>
<span class=sd>            object or the ID of an existing message.</span>
<span class=sd>        emoji : typing.Union[str, hikari.emojis.Emoji]</span>
<span class=sd>            Object or name of the emoji to remove your reaction for.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]]</span>
<span class=sd>            ID of the custom emoji to remove your reaction for.</span>
<span class=sd>            This should only be provided when a custom emoji's name is passed</span>
<span class=sd>            for `emoji`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid unicode emoji is given, or if the given custom emoji</span>
<span class=sd>            does not exist.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_all_reactions_for_emoji</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>emojis</span><span class=o>.</span><span class=n>Emoji</span><span class=p>],</span>
        <span class=n>emoji_id</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete all reactions for a single emoji on a given message.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel where the message to delete the reactions from is.</span>
<span class=sd>            This may be the object or the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete a reactions from. This may be the</span>
<span class=sd>            object or the ID of an existing message.</span>
<span class=sd>        emoji : typing.Union[str, hikari.emojis.Emoji]</span>
<span class=sd>            Object or name of the emoji to remove all the reactions for.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]]</span>
<span class=sd>            ID of the custom emoji to remove all the reactions for.</span>
<span class=sd>            This should only be provided when a custom emoji's name is passed</span>
<span class=sd>            for `emoji`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid unicode emoji is given, or if the given custom emoji</span>
<span class=sd>            does not exist.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_MESSAGES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_reaction</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>emojis</span><span class=o>.</span><span class=n>Emoji</span><span class=p>],</span>
        <span class=n>emoji_id</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a reaction from a message.</span>

<span class=sd>        If you are looking to delete your own applications reaction, use</span>
<span class=sd>        `delete_my_reaction`.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel where the message to delete the reaction from is.</span>
<span class=sd>            This may be the object or the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete a reaction from. This may be the</span>
<span class=sd>            object or the ID of an existing message.</span>
<span class=sd>        user: hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            Object or ID of the user to remove the reaction of.</span>
<span class=sd>        emoji : typing.Union[str, hikari.emojis.Emoji]</span>
<span class=sd>            Object or name of the emoji to react with.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]]</span>
<span class=sd>            ID of the custom emoji to react with.</span>
<span class=sd>            This should only be provided when a custom emoji's name is passed</span>
<span class=sd>            for `emoji`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid unicode emoji is given, or if the given custom emoji</span>
<span class=sd>            does not exist.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_MESSAGES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_all_reactions</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete all reactions from a message.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel where the message to delete all reactions from is.</span>
<span class=sd>            This may be the object or the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete all reaction from. This may be the</span>
<span class=sd>            object or the ID of an existing message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid unicode emoji is given, or if the given custom emoji</span>
<span class=sd>            does not exist.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_MESSAGES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>fetch_reactions_for_emoji</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>emojis</span><span class=o>.</span><span class=n>Emoji</span><span class=p>],</span>
        <span class=n>emoji_id</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>iterators</span><span class=o>.</span><span class=n>LazyIterator</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>User</span><span class=p>]:</span>
        <span class=sd>"""Fetch reactions for an emoji from a message.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        This call is not a coroutine function, it returns a special type of</span>
<span class=sd>        lazy iterator that will perform API calls as you iterate across it,</span>
<span class=sd>        thus any errors documented below will happen then.</span>

<span class=sd>        See `hikari.iterators` for the full API for this iterator type.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel where the message to delete all reactions from is.</span>
<span class=sd>            This may be the object or the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete all reaction from. This may be the</span>
<span class=sd>            object or the ID of an existing message.</span>
<span class=sd>        emoji : typing.Union[str, hikari.emojis.Emoji]</span>
<span class=sd>            Object or name of the emoji to get the reactions for.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]]</span>
<span class=sd>            ID of the custom emoji to get the reactions for.</span>
<span class=sd>            This should only be provided when a custom emoji's name is passed</span>
<span class=sd>            for `emoji`.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.iterators.LazyIterator[hikari.users.User]</span>
<span class=sd>            An iterator to fetch the users.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid unicode emoji is given, or if the given custom emoji</span>
<span class=sd>            does not exist.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_webhook</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>WebhookChannelT</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>avatar</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>webhooks</span><span class=o>.</span><span class=n>IncomingWebhook</span><span class=p>:</span>
        <span class=sd>"""Create webhook in a channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT]</span>
<span class=sd>            The channel where the webhook will be created. This may be</span>
<span class=sd>            the object or the ID of an existing channel.</span>
<span class=sd>        name : str</span>
<span class=sd>            The name for the webhook. This cannot be `clyde`.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        avatar : typing.Optional[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the avatar for the webhook.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.webhooks.IncomingWebhook</span>
<span class=sd>            The created webhook.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If `name` doesn't follow the restrictions enforced by discord.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_WEBHOOKS` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_webhook</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>webhook</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>PartialWebhook</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>token</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>webhooks</span><span class=o>.</span><span class=n>PartialWebhook</span><span class=p>:</span>
        <span class=sd>"""Fetch an existing webhook.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.PartialWebhook]</span>
<span class=sd>            The webhook to fetch. This may be the object or the ID</span>
<span class=sd>            of an existing webhook.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        token : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the webhoook token that will be used to fetch</span>
<span class=sd>            the webhook instead of the token the client was initialized with.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.webhooks.PartialWebhook</span>
<span class=sd>            The requested webhook.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_WEBHOOKS` permission when not</span>
<span class=sd>            using a token.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the webhook is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_channel_webhooks</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>WebhookChannelT</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>PartialWebhook</span><span class=p>]:</span>
        <span class=sd>"""Fetch all channel webhooks.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT]</span>
<span class=sd>            The channel to fetch the webhooks for. This may be an instance of any</span>
<span class=sd>            of the classes which are valid for `hikari.channels.WebhookChannelT`</span>
<span class=sd>            or the ID of an existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.webhooks.PartialWebhook]</span>
<span class=sd>            The fetched webhooks.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_WEBHOOKS` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_webhooks</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>PartialWebhook</span><span class=p>]:</span>
        <span class=sd>"""Fetch all guild webhooks.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the webhooks for. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.webhooks.PartialWebhook]</span>
<span class=sd>            The fetched webhooks.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_WEBHOOKS` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_webhook</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>webhook</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>PartialWebhook</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>token</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>avatar</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>WebhookChannelT</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>webhooks</span><span class=o>.</span><span class=n>PartialWebhook</span><span class=p>:</span>
        <span class=sd>"""Edit a webhook.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.PartialWebhook]</span>
<span class=sd>            The webhook to edit. This may be the object or the</span>
<span class=sd>            ID of an existing webhook.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        token : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the webhoook token that will be used to edit</span>
<span class=sd>            the webhook instead of the token the client was initialized with.</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new webhook name.</span>
<span class=sd>        avatar : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the new webhook avatar. If `None`, will</span>
<span class=sd>            remove the webhook avatar.</span>
<span class=sd>        channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT]]</span>
<span class=sd>            If provided, the text channel to move the webhook to.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.webhooks.PartialWebhook</span>
<span class=sd>            The edited webhook.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_WEBHOOKS` permission when not</span>
<span class=sd>            using a token.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the webhook is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_webhook</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>webhook</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>PartialWebhook</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>token</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a webhook.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.PartialWebhook]</span>
<span class=sd>            The webhook to delete. This may be the object or the</span>
<span class=sd>            ID of an existing webhook.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        token : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the webhoook token that will be used to delete</span>
<span class=sd>            the webhook instead of the token the client was initialized with.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_WEBHOOKS` permission when not</span>
<span class=sd>            using a token.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the webhoook is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>execute_webhook</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=c1># MyPy might not say this but SnowflakeishOr[ExecutableWebhook] isn't valid as ExecutableWebhook isn't Unique</span>
        <span class=n>webhook</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>ExecutableWebhook</span><span class=p>,</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>Snowflakeish</span><span class=p>],</span>
        <span class=n>token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>content</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Any</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>username</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>avatar_url</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedType</span><span class=p>,</span> <span class=nb>str</span><span class=p>,</span> <span class=n>files</span><span class=o>.</span><span class=n>URL</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachment</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachments</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>component</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>components</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embed</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embeds</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>tts</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mentions_everyone</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>role_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>flags</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedType</span><span class=p>,</span> <span class=nb>int</span><span class=p>,</span> <span class=n>messages_</span><span class=o>.</span><span class=n>MessageFlag</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Execute a webhook.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            As of writing, `username` and `avatar_url` are ignored for</span>
<span class=sd>            interaction webhooks.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        webhook : typing.Union[hikari.snowflakes.Snowflakeish, hikari.webhooks.ExecutableWebhook]</span>
<span class=sd>            The webhook to execute. This may be the object</span>
<span class=sd>            or the ID of an existing webhook.</span>
<span class=sd>        token: str</span>
<span class=sd>            The webhook token.</span>
<span class=sd>        content : hikari.undefined.UndefinedOr[typing.Any]</span>
<span class=sd>            If provided, the message contents. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then nothing will be sent</span>
<span class=sd>            in the content. Any other value here will be cast to a</span>
<span class=sd>            `str`.</span>

<span class=sd>            If this is a `hikari.embeds.Embed` and no `embed` nor</span>
<span class=sd>            no `embeds` kwarg is provided, then this will instead</span>
<span class=sd>            update the embed. This allows for simpler syntax when</span>
<span class=sd>            sending an embed alone.</span>

<span class=sd>            Likewise, if this is a `hikari.files.Resource`, then the</span>
<span class=sd>            content is instead treated as an attachment if no `attachment` and</span>
<span class=sd>            no `attachments` kwargs are provided.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        username : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the username to override the webhook's username</span>
<span class=sd>            for this request.</span>
<span class=sd>        avatar_url : typing.Union[hikari.undefined.UndefinedType, hikari.files.URL, str]</span>
<span class=sd>            If provided, the url of an image to override the webhook's</span>
<span class=sd>            avatar with for this request.</span>
<span class=sd>        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish],</span>
<span class=sd>            If provided, the message attachment. This can be a resource,</span>
<span class=sd>            or string of a path on your computer or a URL.</span>

<span class=sd>            Attachments can be passed as many different things, to aid in</span>
<span class=sd>            convenience.</span>

<span class=sd>            - If a `pathlib.PurePath` or `str` to a valid URL, the</span>
<span class=sd>                resource at the given URL will be streamed to Discord when</span>
<span class=sd>                sending the message. Subclasses of</span>
<span class=sd>                `hikari.files.WebResource` such as</span>
<span class=sd>                `hikari.files.URL`,</span>
<span class=sd>                `hikari.messages.Attachment`,</span>
<span class=sd>                `hikari.emojis.Emoji`,</span>
<span class=sd>                `EmbedResource`, etc will also be uploaded this way.</span>
<span class=sd>                This will use bit-inception, so only a small percentage of the</span>
<span class=sd>                resource will remain in memory at any one time, thus aiding in</span>
<span class=sd>                scalability.</span>
<span class=sd>            - If a `hikari.files.Bytes` is passed, or a `str`</span>
<span class=sd>                that contains a valid data URI is passed, then this is uploaded</span>
<span class=sd>                with a randomized file name if not provided.</span>
<span class=sd>            - If a `hikari.files.File`, `pathlib.PurePath` or</span>
<span class=sd>                `str` that is an absolute or relative path to a file</span>
<span class=sd>                on your file system is passed, then this resource is uploaded</span>
<span class=sd>                as an attachment using non-blocking code internally and streamed</span>
<span class=sd>                using bit-inception where possible. This depends on the</span>
<span class=sd>                type of `concurrent.futures.Executor` that is being used for</span>
<span class=sd>                the application (default is a thread pool which supports this</span>
<span class=sd>                behaviour).</span>
<span class=sd>        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]],</span>
<span class=sd>            If provided, the message attachments. These can be resources, or</span>
<span class=sd>            strings consisting of paths on your computer or URLs.</span>
<span class=sd>        component : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder]</span>
<span class=sd>            If provided, builder object of the component to include in this message.</span>
<span class=sd>        components : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]</span>
<span class=sd>            If provided, a sequence of the component builder objects to include</span>
<span class=sd>            in this message.</span>
<span class=sd>        embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed]</span>
<span class=sd>            If provided, the message embed.</span>
<span class=sd>        embeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed]]</span>
<span class=sd>            If provided, the message embeds.</span>
<span class=sd>        tts : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the message will be read out by a screen</span>
<span class=sd>            reader using Discord's TTS (text-to-speech) system.</span>
<span class=sd>        mentions_everyone : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the message should parse @everyone/@here</span>
<span class=sd>            mentions.</span>
<span class=sd>        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], bool]]</span>
<span class=sd>            If provided, and `True`, all user mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all user mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.users.PartialUser` derivatives to enforce mentioning</span>
<span class=sd>            specific users.</span>
<span class=sd>        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], bool]]</span>
<span class=sd>            If provided, and `True`, all role mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all role mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.guilds.PartialRole` derivatives to enforce mentioning</span>
<span class=sd>            specific roles.</span>
<span class=sd>        flags : typing.Union[hikari.undefined.UndefinedType, int, hikari.messages.MessageFlag]</span>
<span class=sd>            The flags to set for this webhook message.</span>

<span class=sd>            .. warning::</span>
<span class=sd>                As of writing this can only be set for interaction webhooks</span>
<span class=sd>                and the only settable flag is EPHEMERAL; this field is just</span>
<span class=sd>                ignored for non-interaction webhooks.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The created message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        ValueError</span>
<span class=sd>            If more than 100 unique objects/entities are passed for</span>
<span class=sd>            `role_mentions` or `user_mentions` or if both `attachment` and</span>
<span class=sd>            `attachments` or `embed` and `embeds` are specified.</span>
<span class=sd>        TypeError</span>
<span class=sd>            If `attachments`, or `embeds` is passed but is not a sequence.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            This may be raised in several discrete situations, such as messages</span>
<span class=sd>            being empty with no attachments or embeds; messages with more than</span>
<span class=sd>            2000 characters in them, embeds that exceed one of the many embed</span>
<span class=sd>            limits; too many attachments; attachments that are too large;</span>
<span class=sd>            invalid image URLs in embeds; too many components.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the webhook is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_webhook_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=c1># MyPy might not say this but SnowflakeishOr[ExecutableWebhook] isn't valid as ExecutableWebhook isn't Unique</span>
        <span class=n>webhook</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>ExecutableWebhook</span><span class=p>,</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>Snowflakeish</span><span class=p>],</span>
        <span class=n>token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Fetch an old message sent by the webhook.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        webhook : typing.Union[hikari.snowflakes.Snowflakeish, hikari.webhooks.ExecutableWebhook]</span>
<span class=sd>            The webhook to execute. This may be the object</span>
<span class=sd>            or the ID of an existing webhook.</span>
<span class=sd>        token: str</span>
<span class=sd>            The webhook token.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to fetch. This may be the object or the ID of an</span>
<span class=sd>            existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The requested message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the webhook is not found or the webhook's message wasn't found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_webhook_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=c1># MyPy might not say this but SnowflakeishOr[ExecutableWebhook] isn't valid as ExecutableWebhook isn't Unique</span>
        <span class=n>webhook</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>ExecutableWebhook</span><span class=p>,</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>Snowflakeish</span><span class=p>],</span>
        <span class=n>token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>],</span>
        <span class=n>content</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Any</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>attachment</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachments</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>component</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>components</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embed</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embeds</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>replace_attachments</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
        <span class=n>mentions_everyone</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>role_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Edit a message sent by a webhook.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        Mentioning everyone, roles, or users in message edits currently</span>
<span class=sd>        will not send a push notification showing a new mention to people</span>
<span class=sd>        on Discord. It will still highlight in their chat as if they</span>
<span class=sd>        were mentioned, however.</span>

<span class=sd>        Also important to note that if you specify a text `content`, `mentions_everyone`,</span>
<span class=sd>        `mentions_reply`, `user_mentions`, and `role_mentions` will default</span>
<span class=sd>        to `False` as the message will be re-parsed for mentions. This will</span>
<span class=sd>        also occur if only one of the four are specified</span>

<span class=sd>        This is a limitation of Discord's design. If in doubt, specify all</span>
<span class=sd>        four of them each time.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        webhook : typing.Union[hikari.snowflakes.Snowflakeish, hikari.webhooks.ExecutableWebhook]</span>
<span class=sd>            The webhook to execute. This may be the object</span>
<span class=sd>            or the ID of an existing webhook.</span>
<span class=sd>        token: str</span>
<span class=sd>            The webhook token.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete. This may be the object or the ID of</span>
<span class=sd>            an existing message.</span>
<span class=sd>        content : hikari.undefined.UndefinedOr[typing.Any]</span>
<span class=sd>            If provided, the message content to update with. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then the content will not</span>
<span class=sd>            be changed. If `None`, then the content will be removed.</span>

<span class=sd>            Any other value will be cast to a `str` before sending.</span>

<span class=sd>            If this is a `hikari.embeds.Embed` and neither the</span>
<span class=sd>            `embed` or `embeds` kwargs are provided or if this is a</span>
<span class=sd>            `hikari.files.Resourceish` and neither the `attachment` or</span>
<span class=sd>            `attachments` kwargs are provided, the values will be overwritten.</span>
<span class=sd>            This allows for simpler syntax when sending an embed or an</span>
<span class=sd>            attachment alone.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the attachment to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous attachment, if</span>
<span class=sd>            present, is not changed. If this is `None`, then the</span>
<span class=sd>            attachment is removed, if present. Otherwise, the new attachment</span>
<span class=sd>            that was provided will be attached.</span>
<span class=sd>        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]]</span>
<span class=sd>            If provided, the attachments to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous attachments, if</span>
<span class=sd>            present, are not changed. If this is `None`, then the</span>
<span class=sd>            attachments is removed, if present. Otherwise, the new attachments</span>
<span class=sd>            that were provided will be attached.</span>
<span class=sd>        component : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder]</span>
<span class=sd>            If provided, builder object of the component to set for this message.</span>
<span class=sd>            This component will replace any previously set components and passing</span>
<span class=sd>            `None` will remove all components.</span>
<span class=sd>        components : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]</span>
<span class=sd>            If provided, a sequence of the component builder objects set for</span>
<span class=sd>            this message. These components will replace any previously set</span>
<span class=sd>            components and passing `None` or an empty sequence will</span>
<span class=sd>            remove all components.</span>
<span class=sd>        embed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed]</span>
<span class=sd>            If provided, the embed to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.</span>
<span class=sd>            If this is `None` then any present embeds are removed.</span>
<span class=sd>            Otherwise, the new embed that was provided will be used as the</span>
<span class=sd>            replacement.</span>
<span class=sd>        embeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed]]</span>
<span class=sd>            If provided, the embeds to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.</span>
<span class=sd>            If this is `None` then any present embeds are removed.</span>
<span class=sd>            Otherwise, the new embeds that were provided will be used as the</span>
<span class=sd>            replacement.</span>
<span class=sd>        replace_attachments: bool</span>
<span class=sd>            Whether to replace the attachments with the provided ones. Defaults</span>
<span class=sd>            to `False`.</span>

<span class=sd>            Note this will also overwrite the embed attachments.</span>
<span class=sd>        mentions_everyone : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, sanitation for `@everyone` mentions. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then the previous setting is</span>
<span class=sd>            not changed. If `True`, then `@everyone`/`@here` mentions</span>
<span class=sd>            in the message content will show up as mentioning everyone that can</span>
<span class=sd>            view the chat.</span>
<span class=sd>        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], bool]]</span>
<span class=sd>            If provided, and `True`, all user mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all user mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.users.PartialUser` derivatives to enforce mentioning</span>
<span class=sd>            specific users.</span>
<span class=sd>        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], bool]]</span>
<span class=sd>            If provided, and `True`, all role mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all role mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.guilds.PartialRole` derivatives to enforce mentioning</span>
<span class=sd>            specific roles.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The edited message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        ValueError</span>
<span class=sd>            If both `attachment` and `attachments`, `component` and `components`</span>
<span class=sd>            or `embed` and `embeds` are specified.</span>
<span class=sd>        TypeError</span>
<span class=sd>            If `attachments`, `components` or `embeds` is passed but is not a</span>
<span class=sd>            sequence.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            This may be raised in several discrete situations, such as messages</span>
<span class=sd>            being empty with no attachments or embeds; messages with more than</span>
<span class=sd>            2000 characters in them, embeds that exceed one of the many embed</span>
<span class=sd>            limits; too many attachments; attachments that are too large;</span>
<span class=sd>            invalid image URLs in embeds; too many components.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the webhook or the message are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_webhook_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=c1># MyPy might not say this but SnowflakeishOr[ExecutableWebhook] isn't valid as ExecutableWebhook isn't Unique</span>
        <span class=n>webhook</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>ExecutableWebhook</span><span class=p>,</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>Snowflakeish</span><span class=p>],</span>
        <span class=n>token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a given message in a given channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        webhook : typing.Union[hikari.snowflakes.Snowflakeish, hikari.webhooks.ExecutableWebhook]</span>
<span class=sd>            The webhook to execute. This may be the object</span>
<span class=sd>            or the ID of an existing webhook.</span>
<span class=sd>        token: str</span>
<span class=sd>            The webhook token.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete. This may be the object or the ID of</span>
<span class=sd>            an existing message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the webhook or the message are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_gateway_url</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>
        <span class=sd>"""Fetch the gateway url.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This endpoint does not require any valid authorization.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_gateway_bot_info</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>sessions</span><span class=o>.</span><span class=n>GatewayBotInfo</span><span class=p>:</span>
        <span class=sd>"""Fetch the gateway gateway info for the bot.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.sessions.GatewayBotInfo</span>
<span class=sd>            The gateway bot information.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_invite</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>invite</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>invites</span><span class=o>.</span><span class=n>InviteCode</span><span class=p>,</span> <span class=nb>str</span><span class=p>])</span> <span class=o>-></span> <span class=n>invites</span><span class=o>.</span><span class=n>Invite</span><span class=p>:</span>
        <span class=sd>"""Fetch an existing invite.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        invite : typing.Union[hikari.invites.InviteCode, str]</span>
<span class=sd>            The invite to fetch. This may be an invite object or</span>
<span class=sd>            the code of an existing invite.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.invites.Invite</span>
<span class=sd>            The requested invite.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the invite is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_invite</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>invite</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>invites</span><span class=o>.</span><span class=n>InviteCode</span><span class=p>,</span> <span class=nb>str</span><span class=p>])</span> <span class=o>-></span> <span class=n>invites</span><span class=o>.</span><span class=n>Invite</span><span class=p>:</span>
        <span class=sd>"""Delete an existing invite.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        invite : typing.Union[hikari.invites.InviteCode, str]</span>
<span class=sd>            The invite to delete. This may be an invite object or</span>
<span class=sd>            the code of an existing invite.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.invites.Invite</span>
<span class=sd>            Object of the invite that was deleted.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_GUILD` permission in the guild</span>
<span class=sd>            the invite is from or if you are missing the `MANAGE_CHANNELS`</span>
<span class=sd>            permission in the channel the invite is from.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the invite is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_my_user</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>users</span><span class=o>.</span><span class=n>OwnUser</span><span class=p>:</span>
        <span class=sd>"""Fetch the token's associated user.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.users.OwnUser</span>
<span class=sd>            The token's associated user.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_my_user</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>username</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>avatar</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>users</span><span class=o>.</span><span class=n>OwnUser</span><span class=p>:</span>
        <span class=sd>"""Edit the token's associated user.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        username : undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new username.</span>
<span class=sd>        avatar : undefined.UndefinedNoneOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the new avatar. If `None`,</span>
<span class=sd>            the avatar will be removed.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.users.OwnUser</span>
<span class=sd>            The edited token's associated user.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>

<span class=sd>            Discord also returns this on a rate limit:</span>
<span class=sd>            &LThttps://github.com/discord/discord-api-docs/issues/1462></span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_my_connections</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>applications</span><span class=o>.</span><span class=n>OwnConnection</span><span class=p>]:</span>
        <span class=sd>"""Fetch the token's associated connections.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.applications.OwnConnection</span>
<span class=sd>            The token's associated connections.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>fetch_my_guilds</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>newest_first</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
        <span class=n>start_at</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SearchableSnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>iterators</span><span class=o>.</span><span class=n>LazyIterator</span><span class=p>[</span><span class=n>applications</span><span class=o>.</span><span class=n>OwnGuild</span><span class=p>]:</span>
        <span class=sd>"""Fetch the token's associated guilds.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        This call is not a coroutine function, it returns a special type of</span>
<span class=sd>        lazy iterator that will perform API calls as you iterate across it,</span>
<span class=sd>        thus any errors documented below will happen then.</span>

<span class=sd>        See `hikari.iterators` for the full API for this iterator type.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        newest_first : bool</span>
<span class=sd>            Whether to fetch the newest first or the olders first.</span>
<span class=sd>            Defaults to `False`.</span>
<span class=sd>        start_at : hikari.undefined.UndefinedOr[hikari.snowflakes.SearchableSnowflakeishOr[hikari.guilds.PartialGuild]]</span>
<span class=sd>            If provided, will start at this snowflake. If you provide</span>
<span class=sd>            a datetime object, it will be transformed into a snowflake. This</span>
<span class=sd>            may also be a guild object. In this case, the</span>
<span class=sd>            date the object was first created will be used.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.iterators.LazyIterator[hikari.applications.OwnGuild]</span>
<span class=sd>            The token's associated guilds.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>leave_guild</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span> <span class=o>/</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Leave a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to leave. This may be the object or</span>
<span class=sd>            the ID of an existing guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found or you own the guild.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_dm_channel</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span> <span class=o>/</span><span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>DMChannel</span><span class=p>:</span>
        <span class=sd>"""Create a DM channel with a user.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to create the DM channel with. This may be the</span>
<span class=sd>            object or the ID of an existing user.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.DMChannel</span>
<span class=sd>            The created DM channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If the user is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=c1># THIS IS AN OAUTH2 FLOW BUT CAN BE USED BY BOTS ALSO</span>
    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_application</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>applications</span><span class=o>.</span><span class=n>Application</span><span class=p>:</span>
        <span class=sd>"""Fetch the token's associated application.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            This endpoint can only be used with a Bot token. Using this with a</span>
<span class=sd>            Bearer token will result in a `hikari.errors.UnauthorizedError`.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.applications.Application</span>
<span class=sd>            The token's associated application.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=c1># THIS IS AN OAUTH2 FLOW ONLY</span>
    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_authorization</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>applications</span><span class=o>.</span><span class=n>AuthorizationInformation</span><span class=p>:</span>
        <span class=sd>"""Fetch the token's authorization information.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            This endpoint can only be used with a Bearer token. Using this</span>
<span class=sd>            with a Bot token will result in a `hikari.errors.UnauthorizedError`.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.applications.AuthorizationInformation</span>
<span class=sd>            The token's authorization information.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>authorize_client_credentials_token</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>client</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>client_secret</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=c1># While according to the spec scopes are optional here, Discord requires that "valid" scopes are passed.</span>
        <span class=n>scopes</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>applications</span><span class=o>.</span><span class=n>OAuth2Scope</span><span class=p>,</span> <span class=nb>str</span><span class=p>]],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>applications</span><span class=o>.</span><span class=n>PartialOAuth2Token</span><span class=p>:</span>
        <span class=sd>"""Authorize a client credentials token for an application.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        client : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to authorize as.</span>
<span class=sd>        client_secret : str</span>
<span class=sd>            Secret of the application to authorize as.</span>
<span class=sd>        scopes : typing.Sequence[typing.Union[hikari.applications.OAuth2Scope, str]]</span>
<span class=sd>            The scopes to authorize for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.applications.PartialOAuth2Token</span>
<span class=sd>            Object of the authorized partial OAuth2 token.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If invalid any invalid or malformed scopes are passed.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            When an client or client secret is passed.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>authorize_access_token</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>client</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>client_secret</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>code</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>redirect_uri</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>applications</span><span class=o>.</span><span class=n>OAuth2AuthorizationToken</span><span class=p>:</span>
        <span class=sd>"""Authorize an OAuth2 token using the authorize code grant type.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        client : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to authorize with.</span>
<span class=sd>        client_secret : str</span>
<span class=sd>            Secret of the application to authorize with.</span>
<span class=sd>        code : str</span>
<span class=sd>            The authorization code to exchange for an OAuth2 access token.</span>
<span class=sd>        redirect_uri : str</span>
<span class=sd>            The redirect uri that was included in the authorization request.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.applications.OAuth2AuthorizationToken</span>
<span class=sd>            Object of the authorized OAuth2 token.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid redirect uri or code is passed.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            When an client or client secret is passed.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>refresh_access_token</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>client</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>client_secret</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>refresh_token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>scopes</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>applications</span><span class=o>.</span><span class=n>OAuth2Scope</span><span class=p>,</span> <span class=nb>str</span><span class=p>]]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>applications</span><span class=o>.</span><span class=n>OAuth2AuthorizationToken</span><span class=p>:</span>
        <span class=sd>"""Refresh an access token.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            As of writing this Discord currently ignores any passed scopes,</span>
<span class=sd>            therefore you should use</span>
<span class=sd>            `hikari.applications.OAuth2AuthorizationToken.scopes` to validate</span>
<span class=sd>            that the expected scopes were actually authorized here.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        client : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to authorize with.</span>
<span class=sd>        client_secret : str</span>
<span class=sd>            Secret of the application to authorize with.</span>
<span class=sd>        refresh_token : str</span>
<span class=sd>            The refresh token to use.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        scopes : typing.Sequence[typing.Union[hikari.applications.OAuth2Scope, str]]</span>
<span class=sd>            The scope of the access request.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.applications.OAuth2AuthorizationToken</span>
<span class=sd>            Object of the authorized OAuth2 token.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid redirect uri or refresh_token is passed.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            When an client or client secret is passed.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>revoke_access_token</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>client</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>client_secret</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>token</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>applications</span><span class=o>.</span><span class=n>PartialOAuth2Token</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Revoke an OAuth2 token.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        client : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to authorize with.</span>
<span class=sd>        client_secret : str</span>
<span class=sd>            Secret of the application to authorize with.</span>
<span class=sd>        token : typing.Union[str, hikari.applications.PartialOAuth2Token]</span>
<span class=sd>            Object or string of the access token to revoke.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            When an client or client secret is passed.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=c1># THIS IS AN OAUTH2 FLOW ONLY</span>
    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>add_user_to_guild</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>access_token</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>applications</span><span class=o>.</span><span class=n>PartialOAuth2Token</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>nick</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>roles</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mute</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>deaf</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>Member</span><span class=p>]:</span>
        <span class=sd>"""Add a user to a guild.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This requires the `access_token` to have the</span>
<span class=sd>            `hikari.applications.OAuth2Scope.GUILDS_JOIN` scope enabled along</span>
<span class=sd>            with the authorization of a Bot which has `MANAGE_INVITES`</span>
<span class=sd>            permission within the target guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        access_token : typing.Union[str, hikari.applications.PartialOAuth2Token]</span>
<span class=sd>            Object or string of the access token to use for this request.</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to add the user to. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to add to the guild. This may be the object</span>
<span class=sd>            or the ID of an existing user.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        nick : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the nick to add to the user when he joins the guild.</span>

<span class=sd>            Requires the `MANAGE_NICKNAMES` permission on the guild.</span>
<span class=sd>        roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole]]</span>
<span class=sd>            If provided, the roles to add to the user when he joins the guild.</span>
<span class=sd>            This may be a collection objects or IDs of existing roles.</span>

<span class=sd>            Requires the `MANAGE_ROLES` permission on the guild.</span>
<span class=sd>        mute : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, the mute state to add the user when he joins the guild.</span>

<span class=sd>            Requires the `MUTE_MEMBERS` permission on the guild.</span>
<span class=sd>        deaf : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, the deaf state to add the user when he joins the guild.</span>

<span class=sd>            Requires the `DEAFEN_MEMBERS` permission on the guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Optional[hikari.guilds.Member]</span>
<span class=sd>            `None` if the user was already part of the guild, else</span>
<span class=sd>            `hikari.guilds.Member`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild you want to add the user to,</span>
<span class=sd>            if you are missing permissions to do one of the things you specified,</span>
<span class=sd>            if you are using an access token for another user, if the token is</span>
<span class=sd>            bound to another bot or if the access token doesn't have the</span>
<span class=sd>            `hikari.applications.OAuth2Scope.GUILDS_JOIN` scope enabled.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If you own the guild or the user is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_voice_regions</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>voices</span><span class=o>.</span><span class=n>VoiceRegion</span><span class=p>]:</span>
        <span class=sd>"""Fetch available voice regions.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This endpoint doesn't return VIP voice regions.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.voices.VoiceRegion]</span>
<span class=sd>            The available voice regions.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_user</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>])</span> <span class=o>-></span> <span class=n>users</span><span class=o>.</span><span class=n>User</span><span class=p>:</span>
        <span class=sd>"""Fetch a user.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to fetch. This can be the object</span>
<span class=sd>            or the ID of an existing user.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.users.User</span>
<span class=sd>            The requested user</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the user is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>fetch_audit_log</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>before</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SearchableSnowflakeishOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>Unique</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>event_type</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>audit_logs</span><span class=o>.</span><span class=n>AuditLogEventType</span><span class=p>,</span> <span class=nb>int</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>iterators</span><span class=o>.</span><span class=n>LazyIterator</span><span class=p>[</span><span class=n>audit_logs</span><span class=o>.</span><span class=n>AuditLog</span><span class=p>]:</span>
        <span class=sd>"""Fetch the guild's audit log.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        This call is not a coroutine function, it returns a special type of</span>
<span class=sd>        lazy iterator that will perform API calls as you iterate across it,</span>
<span class=sd>        thus any errors documented below will happen then.</span>

<span class=sd>        See `hikari.iterators` for the full API for this iterator type.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the audit logs from. This can be a</span>
<span class=sd>            guild object or the ID of an existing guild.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        before : hikari.undefined.UndefinedOr[hikari.snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]</span>
<span class=sd>            If provided, filter to only actions before this snowflake. If you provide</span>
<span class=sd>            a datetime object, it will be transformed into a snowflake. This</span>
<span class=sd>            may be any other Discord entity that has an ID. In this case, the</span>
<span class=sd>            date the object was first created will be used.</span>
<span class=sd>        user : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]]</span>
<span class=sd>            If provided, the user to filter for.</span>
<span class=sd>        event_type : hikari.undefined.UndefinedOr[typing.Union[hikari.audit_logs.AuditLogEventType, int]]</span>
<span class=sd>            If provided, the event type to filter for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.iterators.LazyIterator[hikari.audit_logs.AuditLog]</span>
<span class=sd>            The guild's audit log.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `VIEW_AUDIT_LOG` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_emoji</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>emojis</span><span class=o>.</span><span class=n>KnownCustomEmoji</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild emoji.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the emoji from. This can be a</span>
<span class=sd>            guild object or the ID of an existing guild.</span>
<span class=sd>        emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]</span>
<span class=sd>            The emoji to fetch. This can be a `hikari.emojis.CustomEmoji`</span>
<span class=sd>            or the ID of an existing emoji.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.emojis.KnownCustomEmoji</span>
<span class=sd>            The requested emoji.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the emoji are not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_emojis</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>KnownCustomEmoji</span><span class=p>]:</span>
        <span class=sd>"""Fetch the emojis of a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the emojis from. This can be a</span>
<span class=sd>            guild object or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.emojis.KnownCustomEmoji]</span>
<span class=sd>            The requested emojis.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_emoji</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>image</span><span class=p>:</span> <span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>roles</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>emojis</span><span class=o>.</span><span class=n>KnownCustomEmoji</span><span class=p>:</span>
        <span class=sd>"""Create an emoji in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the emoji on. This can be a</span>
<span class=sd>            guild object or the ID of an existing guild.</span>
<span class=sd>        name : str</span>
<span class=sd>            The name for the emoji.</span>
<span class=sd>        image : hikari.files.Resourceish</span>
<span class=sd>            The 128x128 image for the emoji. Maximum upload size is 256kb.</span>
<span class=sd>            This can be a still or an animated image.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole]]</span>
<span class=sd>            If provided, a collection of the roles that will be able to</span>
<span class=sd>            use this emoji. This can be a `hikari.guilds.PartialRole` or</span>
<span class=sd>            the ID of an existing role.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.emojis.KnownCustomEmoji</span>
<span class=sd>            The created emoji.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value or</span>
<span class=sd>            if there are no more spaces for the type of emoji in the guild.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing `MANAGE_EMOJIS_AND_STICKERS` in the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_emoji</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>roles</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>emojis</span><span class=o>.</span><span class=n>KnownCustomEmoji</span><span class=p>:</span>
        <span class=sd>"""Edit an emoji in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit the emoji on. This can be a</span>
<span class=sd>            guild object or the ID of an existing guild.</span>
<span class=sd>        emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]</span>
<span class=sd>            The emoji to edit. This can be a `hikari.emojis.CustomEmoji`</span>
<span class=sd>            or the ID of an existing emoji.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new name for the emoji.</span>
<span class=sd>        roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole]]</span>
<span class=sd>            If provided, the new collection of roles that will be able to</span>
<span class=sd>            use this emoji. This can be a `hikari.guilds.PartialRole` or</span>
<span class=sd>            the ID of an existing role.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.emojis.KnownCustomEmoji</span>
<span class=sd>            The edited emoji.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing `MANAGE_EMOJIS_AND_STICKERS` in the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the emoji are not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_emoji</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete an emoji in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to delete the emoji on. This can be a guild object or the</span>
<span class=sd>            ID of an existing guild.</span>
<span class=sd>        emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]</span>
<span class=sd>            The emoji to delete. This can be a `hikari.emojis.CustomEmoji`</span>
<span class=sd>            or the ID of an existing emoji.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing `MANAGE_EMOJIS_AND_STICKERS` in the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the emoji are not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_available_sticker_packs</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>stickers</span><span class=o>.</span><span class=n>StickerPack</span><span class=p>]:</span>
        <span class=sd>"""Fetch the available sticker packs.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.stickers.StickerPack]</span>
<span class=sd>            The available sticker packs.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_sticker</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>sticker</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>stickers</span><span class=o>.</span><span class=n>PartialSticker</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>stickers</span><span class=o>.</span><span class=n>GuildSticker</span><span class=p>,</span> <span class=n>stickers</span><span class=o>.</span><span class=n>StandardSticker</span><span class=p>]:</span>
        <span class=sd>"""Fetch a sticker.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        sticker : snowflakes.SnowflakeishOr[stickers.PartialSticker]</span>
<span class=sd>            The sticker to fetch. This can be a sticker object or the</span>
<span class=sd>            ID of an existing sticker.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Union[hikari.stickers.GuildSticker, hikari.stickers.StandardSticker]</span>
<span class=sd>            The requested sticker.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the sticker is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_stickers</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>stickers</span><span class=o>.</span><span class=n>GuildSticker</span><span class=p>]:</span>
        <span class=sd>"""Fetch a standard sticker.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : snowflakes.SnowflakeishOr[stickers.PartialGuild]</span>
<span class=sd>            The guild to request stickers for. This can be a guild object or the</span>
<span class=sd>            ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.stickers.GuildSticker]</span>
<span class=sd>            The requested stickers.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_sticker</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>sticker</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>stickers</span><span class=o>.</span><span class=n>PartialSticker</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>stickers</span><span class=o>.</span><span class=n>GuildSticker</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild sticker.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : snowflakes.SnowflakeishOr[stickers.PartialGuild]</span>
<span class=sd>            The guild the sticker is in. This can be a guild object or the</span>
<span class=sd>            ID of an existing guild.</span>
<span class=sd>        sticker : snowflakes.SnowflakeishOr[stickers.PartialSticker]</span>
<span class=sd>            The sticker to fetch. This can be a sticker object or the</span>
<span class=sd>            ID of an existing sticker.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.stickers.GuildSticker</span>
<span class=sd>            The requested sticker.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the sticker are not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_sticker</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>tag</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>image</span><span class=p>:</span> <span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>stickers</span><span class=o>.</span><span class=n>GuildSticker</span><span class=p>:</span>
        <span class=sd>"""Create a sticker in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the sticker on. This can be a guild object or the</span>
<span class=sd>            ID of an existing guild.</span>
<span class=sd>        name : str</span>
<span class=sd>            The name for the sticker.</span>
<span class=sd>        tag : str</span>
<span class=sd>            The tag for the sticker.</span>
<span class=sd>        image : hikari.files.Resourceish</span>
<span class=sd>            The 320x320 image for the sticker. Maximum upload size is 500kb.</span>
<span class=sd>            This can be a still or an animated PNG or a Lottie.</span>

<span class=sd>            .. note::</span>
<span class=sd>                Lottie support is only available for verified and partnered</span>
<span class=sd>                servers.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        description: hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the description of the sticker.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.stickers.GuildSticker</span>
<span class=sd>            The created sticker.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value or</span>
<span class=sd>            if there are no more spaces for the sticker in the guild.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing `MANAGE_EMOJIS_AND_STICKERS` in the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_sticker</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>sticker</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>stickers</span><span class=o>.</span><span class=n>PartialSticker</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>tag</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>stickers</span><span class=o>.</span><span class=n>GuildSticker</span><span class=p>:</span>
        <span class=sd>"""Edit a sticker in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit the sticker on. This can be a guild object or the</span>
<span class=sd>            ID of an existing guild.</span>
<span class=sd>        sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker]</span>
<span class=sd>            The sticker to edit. This can be a sticker object or the ID of an</span>
<span class=sd>            existing sticker.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new name for the sticker.</span>
<span class=sd>        description : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new description for the sticker.</span>
<span class=sd>        tag : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new sticker tag.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.stickers.GuildSticker</span>
<span class=sd>            The edited sticker.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing `MANAGE_EMOJIS_AND_STICKERS` in the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the sticker are not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_sticker</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>sticker</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>stickers</span><span class=o>.</span><span class=n>PartialSticker</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a sticker in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to delete the sticker on. This can be a guild object or</span>
<span class=sd>            the ID of an existing guild.</span>
<span class=sd>        sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker]</span>
<span class=sd>            The sticker to delete. This can be a sticker object or the ID</span>
<span class=sd>            of an existing sticker.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing `MANAGE_EMOJIS_AND_STICKERS` in the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the sticker are not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>guild_builder</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=o>/</span><span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>GuildBuilder</span><span class=p>:</span>
        <span class=sd>"""Make a guild builder to create a guild with.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This endpoint can only be used by bots in less than 10 guilds.</span>

<span class=sd>        .. note::</span>
<span class=sd>            The exceptions on this endpoint will only be raised once</span>
<span class=sd>            `hikari.api.special_endpoints.GuildBuilder.create` is called.</span>
<span class=sd>            Invoking this function itself will not raise any of</span>
<span class=sd>            the above types.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        name : str</span>
<span class=sd>            The new guilds name.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.GuildBuilder</span>
<span class=sd>            The guild builder to use. This will allow to create a guild</span>
<span class=sd>            later with `hikari.api.special_endpoints.GuildBuilder.create`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value or if you</span>
<span class=sd>            call this as a bot that's in more than 10 guilds.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>

<span class=sd>        See Also</span>
<span class=sd>        --------</span>
<span class=sd>        `hikari.api.special_endpoints.GuildBuilder`</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>])</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>RESTGuild</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch. This can be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.RESTGuild</span>
<span class=sd>            The requested guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_preview</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>])</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>GuildPreview</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild preview.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This will only work for guilds you are a part of or are public.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the preview of. This can be a</span>
<span class=sd>            guild object or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.GuildPreview</span>
<span class=sd>            The requested guild preview.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found or you are not part of the guild.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_guild</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>verification_level</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>GuildVerificationLevel</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>default_message_notifications</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>guilds</span><span class=o>.</span><span class=n>GuildMessageNotificationsLevel</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>explicit_content_filter_level</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>guilds</span><span class=o>.</span><span class=n>GuildExplicitContentFilterLevel</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>afk_channel</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildVoiceChannel</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>afk_timeout</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>time</span><span class=o>.</span><span class=n>Intervalish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>icon</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>owner</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>splash</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>banner</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>system_channel</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildTextChannel</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>rules_channel</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildTextChannel</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>public_updates_channel</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildTextChannel</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>preferred_locale</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>RESTGuild</span><span class=p>:</span>
        <span class=sd>"""Edit a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new name for the guild.</span>
<span class=sd>        verification_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildVerificationLevel]</span>
<span class=sd>            If provided, the new verification level.</span>
<span class=sd>        default_message_notifications : hikari.undefined.UndefinedOr[hikari.guilds.GuildMessageNotificationsLevel]</span>
<span class=sd>            If provided, the new default message notifications level.</span>
<span class=sd>        explicit_content_filter_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildExplicitContentFilterLevel]</span>
<span class=sd>            If provided, the new explicit content filter level.</span>
<span class=sd>        afk_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel]]</span>
<span class=sd>            If provided, the new afk channel. Requires `afk_timeout` to</span>
<span class=sd>            be set to work.</span>
<span class=sd>        afk_timeout : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]</span>
<span class=sd>            If provided, the new afk timeout.</span>
<span class=sd>        icon : hikari.undefined.UndefinedOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the new guild icon. Must be a 1024x1024 image or can be</span>
<span class=sd>            an animated gif when the guild has the `ANIMATED_ICON` feature.</span>
<span class=sd>        owner : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]]]</span>
<span class=sd>            If provided, the new guild owner.</span>

<span class=sd>            .. warning::</span>
<span class=sd>                You need to be the owner of the server to use this.</span>
<span class=sd>        splash : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the new guild splash. Must be a 16:9 image and the</span>
<span class=sd>            guild must have the `INVITE_SPLASH` feature.</span>
<span class=sd>        banner : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the new guild banner. Must be a 16:9 image and the</span>
<span class=sd>            guild must have the `BANNER` feature.</span>
<span class=sd>        system_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel]]</span>
<span class=sd>            If provided, the new system channel.</span>
<span class=sd>        rules_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel]]</span>
<span class=sd>            If provided, the new rules channel.</span>
<span class=sd>        public_updates_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel]]</span>
<span class=sd>            If provided, the new public updates channel.</span>
<span class=sd>        preferred_locale : hikari.undefined.UndefinedNoneOr[str]</span>
<span class=sd>            If provided, the new preferred locale.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.RESTGuild</span>
<span class=sd>            The edited guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value. Or</span>
<span class=sd>            you are missing the</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_GUILD` permission or if you tried to</span>
<span class=sd>            pass ownership without being the server owner.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_guild</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>])</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to delete. This may be the object or</span>
<span class=sd>            the ID of an existing guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not the owner of the guild.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If you own the guild or if you are not in it.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_channels</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>]:</span>
        <span class=sd>"""Fetch the channels in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the channels from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.channels.GuildChannel]</span>
<span class=sd>            The requested channels.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_guild_text_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>position</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>topic</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>nsfw</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>rate_limit_per_user</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>time</span><span class=o>.</span><span class=n>Intervalish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permission_overwrites</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>category</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildCategory</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>GuildTextChannel</span><span class=p>:</span>
        <span class=sd>"""Create a text channel in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the channel in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        name : str</span>
<span class=sd>            The channels name. Must be between 2 and 1000 characters.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        position : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the position of the channel (relative to the</span>
<span class=sd>            category, if any).</span>
<span class=sd>        topic : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the channels topic. Maximum 1024 characters.</span>
<span class=sd>        nsfw : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to mark the channel as NSFW.</span>
<span class=sd>        rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]</span>
<span class=sd>            If provided, the amount of seconds a user has to wait</span>
<span class=sd>            before being able to send another message in the channel.</span>
<span class=sd>            Maximum 21600 seconds.</span>
<span class=sd>        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]</span>
<span class=sd>            If provided, the permission overwrites for the channel.</span>
<span class=sd>        category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]</span>
<span class=sd>            The category to create the channel under. This may be the</span>
<span class=sd>            object or the ID of an existing category.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.GuildTextChannel</span>
<span class=sd>            The created channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_guild_news_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>position</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>topic</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>nsfw</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>rate_limit_per_user</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>time</span><span class=o>.</span><span class=n>Intervalish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permission_overwrites</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>category</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildCategory</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>GuildNewsChannel</span><span class=p>:</span>
        <span class=sd>"""Create a news channel in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the channel in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        name : str</span>
<span class=sd>            The channels name. Must be between 2 and 1000 characters.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        position : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the position of the channel (relative to the</span>
<span class=sd>            category, if any).</span>
<span class=sd>        topic : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the channels topic. Maximum 1024 characters.</span>
<span class=sd>        nsfw : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to mark the channel as NSFW.</span>
<span class=sd>        rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]</span>
<span class=sd>            If provided, the amount of seconds a user has to wait</span>
<span class=sd>            before being able to send another message in the channel.</span>
<span class=sd>            Maximum 21600 seconds.</span>
<span class=sd>        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]</span>
<span class=sd>            If provided, the permission overwrites for the channel.</span>
<span class=sd>        category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]</span>
<span class=sd>            The category to create the channel under. This may be the</span>
<span class=sd>            object or the ID of an existing category.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.GuildNewsChannel</span>
<span class=sd>            The created channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_guild_voice_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>position</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_limit</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>bitrate</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>video_quality_mode</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>VideoQualityMode</span><span class=p>,</span> <span class=nb>int</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permission_overwrites</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>region</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>voices</span><span class=o>.</span><span class=n>VoiceRegion</span><span class=p>,</span> <span class=nb>str</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>category</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildCategory</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>GuildVoiceChannel</span><span class=p>:</span>
        <span class=sd>"""Create a voice channel in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the channel in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        name : str</span>
<span class=sd>            The channels name. Must be between 2 and 1000 characters.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        position : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the position of the channel (relative to the</span>
<span class=sd>            category, if any).</span>
<span class=sd>        user_limit : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the maximum users in the channel at once.</span>
<span class=sd>            Must be between 0 and 99 with 0 meaning no limit.</span>
<span class=sd>        bitrate : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the bitrate for the channel. Must be</span>
<span class=sd>            between 8000 and 96000 or 8000 and 128000 for VIP</span>
<span class=sd>            servers.</span>
<span class=sd>        video_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, int]]</span>
<span class=sd>            If provided, the new video quality mode for the channel.</span>
<span class=sd>        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]</span>
<span class=sd>            If provided, the permission overwrites for the channel.</span>
<span class=sd>        region : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, str]]</span>
<span class=sd>            If provided, the voice region to for this channel. Passing</span>
<span class=sd>            `None` here will set it to "auto" mode where the used</span>
<span class=sd>            region will be decided based on the first person who connects to it</span>
<span class=sd>            when it's empty.</span>
<span class=sd>        category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]</span>
<span class=sd>            The category to create the channel under. This may be the</span>
<span class=sd>            object or the ID of an existing category.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.GuildVoiceChannel</span>
<span class=sd>            The created channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_guild_stage_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>position</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_limit</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>bitrate</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permission_overwrites</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>region</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>voices</span><span class=o>.</span><span class=n>VoiceRegion</span><span class=p>,</span> <span class=nb>str</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>category</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildCategory</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>GuildStageChannel</span><span class=p>:</span>
        <span class=sd>"""Create a stage channel in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the channel in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        name : str</span>
<span class=sd>            The channel's name. Must be between 2 and 1000 characters.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        position : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the position of the channel (relative to the</span>
<span class=sd>            category, if any).</span>
<span class=sd>        user_limit : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the maximum users in the channel at once.</span>
<span class=sd>            Must be between 0 and 99 with 0 meaning no limit.</span>
<span class=sd>        bitrate : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the bitrate for the channel. Must be</span>
<span class=sd>            between 8000 and 96000 or 8000 and 128000 for VIP</span>
<span class=sd>            servers.</span>
<span class=sd>        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]</span>
<span class=sd>            If provided, the permission overwrites for the channel.</span>
<span class=sd>        region : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, str]]</span>
<span class=sd>            If provided, the voice region to for this channel. Passing</span>
<span class=sd>            `None` here will set it to "auto" mode where the used</span>
<span class=sd>            region will be decided based on the first person who connects to it</span>
<span class=sd>            when it's empty.</span>
<span class=sd>        category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]</span>
<span class=sd>            The category to create the channel under. This may be the</span>
<span class=sd>            object or the ID of an existing category.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.GuildStageChannel</span>
<span class=sd>            The created channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_guild_category</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>position</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permission_overwrites</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>GuildCategory</span><span class=p>:</span>
        <span class=sd>"""Create a category in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the channel in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        name : str</span>
<span class=sd>            The channels name. Must be between 2 and 1000 characters.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        position : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the position of the category.</span>
<span class=sd>        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]</span>
<span class=sd>            If provided, the permission overwrites for the category.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.GuildCategory</span>
<span class=sd>            The created category.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>reposition_channels</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>positions</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Mapping</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>]],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Reposition the channels in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to reposition the channels in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        positions : typing.Mapping[int, hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]]</span>
<span class=sd>            A mapping of of the object or the ID of an existing channel to</span>
<span class=sd>            the new position, relative to their parent category, if any.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>Member</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild member.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to get the member from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to get the member for. This may be the</span>
<span class=sd>            object or the ID of an existing user.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.Member</span>
<span class=sd>            The requested member.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the user are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>fetch_members</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>iterators</span><span class=o>.</span><span class=n>LazyIterator</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>Member</span><span class=p>]:</span>
        <span class=sd>"""Fetch the members from a guild.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            This endpoint requires the `GUILD_MEMBERS` intent to be enabled in</span>
<span class=sd>            the dashboard, not necessarily authenticated with it if using the</span>
<span class=sd>            gateway. If you don't have the intents you can use `search_members`</span>
<span class=sd>            which doesn't require any intents.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        This call is not a coroutine function, it returns a special type of</span>
<span class=sd>        lazy iterator that will perform API calls as you iterate across it,</span>
<span class=sd>        thus any errors documented below will happen then.</span>

<span class=sd>        See `hikari.iterators` for the full API for this iterator type.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the members of. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.iterators.LazyIterator[hikari.guilds.Member]</span>
<span class=sd>            An iterator to fetch the members.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_my_member</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>])</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>Member</span><span class=p>:</span>
        <span class=sd>"""Fetch the Oauth token's associated member in a guild.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            This endpoint can only be used with a Bearer token. Using this</span>
<span class=sd>            with a Bot token will result in a `hikari.errors.UnauthorizedError`.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.Member</span>
<span class=sd>            The associated guild member.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>search_members</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>Member</span><span class=p>]:</span>
        <span class=sd>"""Search the members in a guild by nickname and username.</span>

<span class=sd>        .. note::</span>
<span class=sd>            Unlike `RESTClient.fetch_members` this endpoint isn't paginated and</span>
<span class=sd>            therefore will return all the members in one go rather than needing</span>
<span class=sd>            to be asynchronously iterated over.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The object or ID of the guild to search members in.</span>
<span class=sd>        name : str</span>
<span class=sd>            The query to match username(s) and nickname(s) against.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.guilds.Member]</span>
<span class=sd>            A sequence of the members who matched the provided `name`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>nick</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>roles</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mute</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>deaf</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>voice_channel</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildVoiceChannel</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>communication_disabled_until</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>datetime</span><span class=o>.</span><span class=n>datetime</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>Member</span><span class=p>:</span>
        <span class=sd>"""Edit a guild member.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to edit. This may be the object</span>
<span class=sd>            or the ID of an existing user.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        nick : hikari.undefined.UndefinedNoneOr[str]</span>
<span class=sd>            If provided, the new nick for the member. If `None`,</span>
<span class=sd>            will remove the members nick.</span>

<span class=sd>            Requires the `MANAGE_NICKNAMES` permission.</span>
<span class=sd>        roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole]]</span>
<span class=sd>            If provided, the new roles for the member.</span>

<span class=sd>            Requires the `MANAGE_ROLES` permission.</span>
<span class=sd>        mute : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, the new server mute state for the member.</span>

<span class=sd>            Requires the `MUTE_MEMBERS` permission.</span>
<span class=sd>        deaf : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, the new server deaf state for the member.</span>

<span class=sd>            Requires the `DEAFEN_MEMBERS` permission.</span>
<span class=sd>        voice_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel]]]</span>
<span class=sd>            If provided, `None` or the object or the ID of</span>
<span class=sd>            an existing voice channel to move the member to.</span>
<span class=sd>            If `None`, will disconnect the member from voice.</span>

<span class=sd>            Requires the `MOVE_MEMBERS` permission and the `CONNECT`</span>
<span class=sd>            permission in the original voice channel and the target</span>
<span class=sd>            voice channel.</span>

<span class=sd>            .. note::</span>
<span class=sd>                If the member is not in a voice channel, this will</span>
<span class=sd>                take no effect.</span>
<span class=sd>        communication_disabled_until : hikari.undefined.UndefinedNoneOr[datetime.datetime]</span>
<span class=sd>            If provided, the datetime when the timeout (disable communication)</span>
<span class=sd>            of the member expires, up to 28 days in the future, or `None`</span>
<span class=sd>            to remove the timeout from the member.</span>

<span class=sd>            Requires the `MODERATE_MEMBERS` permission.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.Member</span>
<span class=sd>            Object of the member that was updated.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing a permission to do an action.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the user are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_my_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>nickname</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>Member</span><span class=p>:</span>
        <span class=sd>"""Edit the current user's member in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit the member in. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        nickname : hikari.undefined.UndefinedNoneOr[str]</span>
<span class=sd>            If provided, the new nickname for the member. If</span>
<span class=sd>            `None`, will remove the members nickname.</span>

<span class=sd>            Requires the `CHANGE_NICKNAME` permission.</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.Member</span>
<span class=sd>            Object of the member that was updated.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing a permission to do an action.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@deprecation</span><span class=o>.</span><span class=n>deprecated</span><span class=p>(</span><span class=s2>"2.0.0.dev104"</span><span class=p>,</span> <span class=s2>"Use `edit_my_member`'s `nick` argument instead."</span><span class=p>)</span>
    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_my_nick</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>Guild</span><span class=p>],</span>
        <span class=n>nick</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=nb>str</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Edit the associated token's member nick.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>
<span class=sd>        nick : typing.Optional[str]</span>
<span class=sd>            The new nick. If `None`,</span>
<span class=sd>            will remove the nick.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `CHANGE_NICKNAME` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>add_role_to_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=n>role</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Add a role to a member.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild where the member is in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to add the role to. This may be the</span>
<span class=sd>            object or the ID of an existing user.</span>
<span class=sd>        role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]</span>
<span class=sd>            The role to add. This may be the object or the</span>
<span class=sd>            ID of an existing role.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_ROLES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild, user or role are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>remove_role_from_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=n>role</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Remove a role from a member.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild where the member is in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to remove the role from. This may be the</span>
<span class=sd>            object or the ID of an existing user.</span>
<span class=sd>        role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]</span>
<span class=sd>            The role to remove. This may be the object or the</span>
<span class=sd>            ID of an existing role.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_ROLES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild, user or role are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>kick_user</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Kick a member from a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to kick the member from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to kick. This may be the object</span>
<span class=sd>            or the ID of an existing user.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `KICK_MEMBERS` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or user are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>kick_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Alias of `hikari.impl.rest.RESTClient.kick_user`."""</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>ban_user</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>delete_message_days</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Ban a member from a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to ban the member from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to kick. This may be the object</span>
<span class=sd>            or the ID of an existing user.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        delete_message_days : hikari.undefined.UndefinedNoneOr[int]</span>
<span class=sd>            If provided, the number of days to delete messages for.</span>
<span class=sd>            This must be between 0 and 7.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `BAN_MEMBERS` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or user are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>ban_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>delete_message_days</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Alias of `hikari.impl.rest.RESTClient.ban_user`."""</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>unban_user</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Unban a member from a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to unban the member from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to unban. This may be the object</span>
<span class=sd>            or the ID of an existing user.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `BAN_MEMBERS` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or user are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>unban_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Alias of `hikari.impl.rest.RESTClient.unban_user`."""</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_ban</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>GuildBan</span><span class=p>:</span>
        <span class=sd>"""Fetch the guild's ban info for a user.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the ban from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to fetch the ban of. This may be the</span>
<span class=sd>            object or the ID of an existing user.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.GuildBan</span>
<span class=sd>            The requested ban info.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `BAN_MEMBERS` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or user are not found or if the user</span>
<span class=sd>            is not banned.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_bans</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>GuildBan</span><span class=p>]:</span>
        <span class=sd>"""Fetch the bans of a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the bans from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.guilds.GuildBan]</span>
<span class=sd>            The requested bans.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `BAN_MEMBERS` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_roles</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>Role</span><span class=p>]:</span>
        <span class=sd>"""Fetch the roles of a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the roles from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.guilds.Role]</span>
<span class=sd>            The requested roles.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_role</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permissions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>permissions_</span><span class=o>.</span><span class=n>Permissions</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>color</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>colors</span><span class=o>.</span><span class=n>Colorish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>colour</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>colors</span><span class=o>.</span><span class=n>Colorish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>hoist</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>icon</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>unicode_emoji</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mentionable</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>Role</span><span class=p>:</span>
        <span class=sd>"""Create a role.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the role in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the name for the role.</span>
<span class=sd>        permissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]</span>
<span class=sd>            The permissions to give the role. This will default to setting</span>
<span class=sd>            NO roles if left to the default value. This is in contrast to</span>
<span class=sd>            default behaviour on Discord where some random permissions will</span>
<span class=sd>            be set by default.</span>
<span class=sd>        color : hikari.undefined.UndefinedOr[hikari.colors.Colorish]</span>
<span class=sd>            If provided, the role's color.</span>
<span class=sd>        colour : hikari.undefined.UndefinedOr[hikari.colors.Colorish]</span>
<span class=sd>            An alias for `color`.</span>
<span class=sd>        hoist : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to hoist the role.</span>
<span class=sd>        icon : hikari.undefined.UndefinedOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the role icon. Must be a 64x64 image under 256kb.</span>
<span class=sd>        unicode_emoji : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the standard emoji to set as the role icon.</span>
<span class=sd>        mentionable : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to make the role mentionable.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.Role</span>
<span class=sd>            The created role.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        TypeError</span>
<span class=sd>            If both `color` and `colour` are specified or if both `icon` and</span>
<span class=sd>            `unicode_emoji` are specified.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_ROLES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>reposition_roles</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>positions</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Mapping</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>]],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Reposition the roles in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to reposition the roles in. This may be</span>
<span class=sd>            the object or the ID of an existing guild.</span>
<span class=sd>        positions : typing.Mapping[int, hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]</span>
<span class=sd>            A mapping of the position to the role.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_ROLES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_role</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>role</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permissions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>permissions_</span><span class=o>.</span><span class=n>Permissions</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>color</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>colors</span><span class=o>.</span><span class=n>Colorish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>colour</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>colors</span><span class=o>.</span><span class=n>Colorish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>hoist</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>icon</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>unicode_emoji</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mentionable</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>Role</span><span class=p>:</span>
        <span class=sd>"""Edit a role.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit the role in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]</span>
<span class=sd>            The role to edit. This may be the object or the</span>
<span class=sd>            ID of an existing role.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new name for the role.</span>
<span class=sd>        permissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]</span>
<span class=sd>            If provided, the new permissions for the role.</span>
<span class=sd>        color : hikari.undefined.UndefinedOr[hikari.colors.Colorish]</span>
<span class=sd>            If provided, the new color for the role.</span>
<span class=sd>        colour : hikari.undefined.UndefinedOr[hikari.colors.Colorish]</span>
<span class=sd>            An alias for `color`.</span>
<span class=sd>        hoist : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to hoist the role.</span>
<span class=sd>        icon : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the new role icon. Must be a 64x64 image</span>
<span class=sd>            under 256kb.</span>
<span class=sd>        unicode_emoji : hikari.undefined.UndefinedNoneOr[str]</span>
<span class=sd>            If provided, the new unicode emoji to set as the role icon.</span>
<span class=sd>        mentionable : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to make the role mentionable.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.Role</span>
<span class=sd>            The edited role.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        TypeError</span>
<span class=sd>            If both `color` and `colour` are specified or if both `icon` and</span>
<span class=sd>            `unicode_emoji` are specified.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_ROLES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or role are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_role</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>role</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a role.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to delete the role in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]</span>
<span class=sd>            The role to delete. This may be the object or the</span>
<span class=sd>            ID of an existing role.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_ROLES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or role are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>estimate_guild_prune_count</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>days</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>include_roles</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=nb>int</span><span class=p>:</span>
        <span class=sd>"""Estimate the guild prune count.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to estimate the guild prune count for. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        days : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, number of days to count prune for.</span>
<span class=sd>        include_roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole]]]</span>
<span class=sd>            If provided, the role(s) to include. By default, this endpoint will</span>
<span class=sd>            not count users with roles. Providing roles using this attribute</span>
<span class=sd>            will make members with the specified roles also get included into</span>
<span class=sd>            the count.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        int</span>
<span class=sd>            The estimated guild prune count.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `KICK_MEMBERS` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>begin_guild_prune</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>days</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>compute_prune_count</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>include_roles</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=nb>int</span><span class=p>]:</span>
        <span class=sd>"""Begin the guild prune.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to begin the guild prune in. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        days : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, number of days to count prune for.</span>
<span class=sd>        compute_prune_count: hikari.snowflakes.SnowflakeishOr[bool]</span>
<span class=sd>            If provided, whether to return the prune count. This is discouraged</span>
<span class=sd>            for large guilds.</span>
<span class=sd>        include_roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole]]</span>
<span class=sd>            If provided, the role(s) to include. By default, this endpoint will</span>
<span class=sd>            not count users with roles. Providing roles using this attribute</span>
<span class=sd>            will make members with the specified roles also get included into</span>
<span class=sd>            the count.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Optional[int]</span>
<span class=sd>            If `compute_prune_count` is not provided or `True`, the</span>
<span class=sd>            number of members pruned. Else `None`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `KICK_MEMBERS` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_voice_regions</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>voices</span><span class=o>.</span><span class=n>VoiceRegion</span><span class=p>]:</span>
        <span class=sd>"""Fetch the available voice regions for a guild.</span>

<span class=sd>        .. note::</span>
<span class=sd>            Unlike `RESTClient.fetch_voice_regions`, this will</span>
<span class=sd>            return the VIP regions if the guild has access to them.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the voice regions for. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.voices.VoiceRegion]</span>
<span class=sd>            The available voice regions for the guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_invites</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>invites</span><span class=o>.</span><span class=n>InviteWithMetadata</span><span class=p>]:</span>
        <span class=sd>"""Fetch the guild's invites.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the invites for. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.invites.InviteWithMetadata]</span>
<span class=sd>            The invites for the guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_GUILD` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_integrations</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>Integration</span><span class=p>]:</span>
        <span class=sd>"""Fetch the guild's integrations.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the integrations for. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.guilds.Integration]</span>
<span class=sd>            The integrations for the guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_GUILD` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_widget</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>])</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>GuildWidget</span><span class=p>:</span>
        <span class=sd>"""Fetch a guilds's widget.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the widget from. This can be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.GuildWidget</span>
<span class=sd>            The requested guild widget.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_GUILD` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_widget</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>enabled</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>GuildWidget</span><span class=p>:</span>
        <span class=sd>"""Fetch a guilds's widget.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit the widget in. This can be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]]</span>
<span class=sd>            If provided, the channel to set the widget to. If `None`,</span>
<span class=sd>            will not set to any.</span>
<span class=sd>        enabled : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to enable the widget.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.GuildWidget</span>
<span class=sd>            The edited guild widget.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_GUILD` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_welcome_screen</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>])</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>WelcomeScreen</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild's welcome screen.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or ID of the guild to fetch the welcome screen for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.WelcomeScreen</span>
<span class=sd>            The requested welcome screen.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found or the welcome screen has never been set</span>
<span class=sd>            for this guild (if the welcome screen has been set for a guild</span>
<span class=sd>            before and then disabled you should still be able to fetch it).</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_welcome_screen</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>enabled</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>channels</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>WelcomeChannel</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>WelcomeScreen</span><span class=p>:</span>
        <span class=sd>"""Edit the welcome screen of a community guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            ID or object of the guild to edit the welcome screen for.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        description : undefined.UndefinedNoneOr[str]</span>
<span class=sd>            If provided, the description to set for the guild's welcome screen.</span>
<span class=sd>            This may be `None` to unset the description.</span>
<span class=sd>        enabled : undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, Whether the guild's welcome screen should be enabled.</span>
<span class=sd>        channels : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.guilds.WelcomeChannel]]</span>
<span class=sd>            If provided, a sequence of up to 5 public channels to set in this</span>
<span class=sd>            guild's welcome screen. This may be passed as `None` to</span>
<span class=sd>            remove all welcome channels</span>

<span class=sd>            .. note::</span>
<span class=sd>                Custom emojis may only be included in a guild's welcome channels</span>
<span class=sd>                if it's boost status is tier 2 or above.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.WelcomeScreen</span>
<span class=sd>            The edited guild welcome screen.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If more than 5 welcome channels are provided or if a custom emoji</span>
<span class=sd>            is included on a welcome channel in a guild that doesn't have tier</span>
<span class=sd>            2 of above boost status or if a private channel is included as a</span>
<span class=sd>            welcome channel.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_GUILD` permission, are not part of</span>
<span class=sd>            the guild or the guild doesn't have access to the community welcome</span>
<span class=sd>            screen feature.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_vanity_url</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>])</span> <span class=o>-></span> <span class=n>invites</span><span class=o>.</span><span class=n>VanityURL</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild's vanity url.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the vanity url from. This can</span>
<span class=sd>            be the object or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.invites.VanityURL</span>
<span class=sd>            The requested invite.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_template</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>:</span>
        <span class=sd>"""Create a guild template.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create a template from.</span>
<span class=sd>        name : str</span>
<span class=sd>            The name to use for the created template.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        description : hikari.undefined.UndefinedNoneOr[str]</span>
<span class=sd>            The description to set for the template.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.templates.Template</span>
<span class=sd>            The object of the created template.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found or you are missing the `MANAGE_GUILD`</span>
<span class=sd>            permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_guild_from_template</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>template</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>icon</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>RESTGuild</span><span class=p>:</span>
        <span class=sd>"""Make a guild from a template.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This endpoint can only be used by bots in less than 10 guilds.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        template : typing.Union[str, hikari.templates.Template]</span>
<span class=sd>            The object or string code of the template to create a guild based on.</span>
<span class=sd>        name : str</span>
<span class=sd>            The new guilds name.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        icon : hikari.undefined.UndefinedOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the guild icon to set. Must be a 1024x1024 image or can</span>
<span class=sd>            be an animated gif when the guild has the `ANIMATED_ICON` feature.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.RESTGuild</span>
<span class=sd>            Object of the created guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value or if you</span>
<span class=sd>            call this as a bot that's in more than 10 guilds.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_template</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>template</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>:</span>
        <span class=sd>"""Delete a guild template.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to delete a template in.</span>
<span class=sd>        template : typing.Union[str, hikari.templates.Template]</span>
<span class=sd>            Object or string code of the template to delete.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.templates.Template</span>
<span class=sd>            The deleted template's object.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found or you are missing the `MANAGE_GUILD`</span>
<span class=sd>            permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_template</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>template</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>,</span> <span class=nb>str</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>:</span>
        <span class=sd>"""Modify a guild template.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit a template in.</span>
<span class=sd>        template : typing.Union[str, hikari.templates.Template]</span>
<span class=sd>            Object or string code of the template to modify.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            The name to set for this template.</span>
<span class=sd>        description : hikari.undefined.UndefinedNoneOr[str]</span>
<span class=sd>            The description to set for the template.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.templates.Template</span>
<span class=sd>            The object of the edited template.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found or you are missing the `MANAGE_GUILD`</span>
<span class=sd>            permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_template</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>template</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>])</span> <span class=o>-></span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild template.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        template : typing.Union[str, hikari.templates.Template]</span>
<span class=sd>            The object or string code of the template to fetch.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.templates.Template</span>
<span class=sd>            The object of the found template.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the template was not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_templates</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>]:</span>
        <span class=sd>"""Fetch the templates for a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The object or ID of the guild to get the templates for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.templates.Template]</span>
<span class=sd>            A sequence of the found template objects.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found or are missing the `MANAGE_GUILD`</span>
<span class=sd>            permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>sync_guild_template</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>template</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>:</span>
        <span class=sd>"""Create a guild template.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to sync a template in.</span>
<span class=sd>        template : typing.Union[str, hikari.templates.Template]</span>
<span class=sd>            Object or code of the template to sync.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.templates.Template</span>
<span class=sd>            The object of the synced template.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild or are missing the `MANAGE_GUILD`</span>
<span class=sd>            permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or template is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>command_builder</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>description</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>SlashCommandBuilder</span><span class=p>:</span>
        <span class=sa>r</span><span class=sd>"""Create a slash command builder for use in `RESTClient.set_application_commands`.</span>

<span class=sd>        .. deprecated:: 2.0.0.dev106</span>
<span class=sd>            Use `RESTClient.slash_command_builder` instead.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        name : str</span>
<span class=sd>            The command's name. This should match the regex `^[\w-]{1,32}$` in</span>
<span class=sd>            Unicode mode and be lowercase.</span>
<span class=sd>        description : str</span>
<span class=sd>            The description to set for the command.</span>
<span class=sd>            This should be inclusively between 1-100 characters in length.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.SlashCommandBuilder</span>
<span class=sd>            The created command builder object.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>slash_command_builder</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>SlashCommandBuilder</span><span class=p>:</span>
        <span class=sa>r</span><span class=sd>"""Create a command builder for use in `RESTClient.set_application_commands`.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        name : str</span>
<span class=sd>            The command's name. This should match the regex `^[\w-]{1,32}$` in</span>
<span class=sd>            Unicode mode and be lowercase.</span>
<span class=sd>        description : str</span>
<span class=sd>            The description to set for the command if this is a slash command.</span>
<span class=sd>            This should be inclusively between 1-100 characters in length.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.SlashCommandBuilder</span>
<span class=sd>            The created command builder object.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>context_menu_command_builder</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=nb>type</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandType</span><span class=p>,</span> <span class=nb>int</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>ContextMenuCommandBuilder</span><span class=p>:</span>
        <span class=sa>r</span><span class=sd>"""Create a command builder for use in `RESTClient.set_application_commands`.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        type : commands.CommandType</span>
<span class=sd>            The commands's type.</span>
<span class=sd>        name : str</span>
<span class=sd>            The command's name.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.ContextMenuCommandBuilder</span>
<span class=sd>            The created command builder object.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_application_command</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>command</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>:</span>
        <span class=sd>"""Fetch a command set for an application.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to fetch a command for.</span>
<span class=sd>        command: hikari.snowflakes.SnowflakeishOr[hikari.commands.PartialCommand]</span>
<span class=sd>            Object or ID of the command to fetch.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or ID of the guild to fetch the command for. If left as</span>
<span class=sd>            `hikari.undefined.UNDEFINED` then this will return a global command,</span>
<span class=sd>            otherwise this will return a command made for the specified guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.commands.PartialCommand</span>
<span class=sd>            Object of the fetched command.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the target command.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the command isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_application_commands</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>]:</span>
        <span class=sd>"""Fetch the commands set for an application.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to fetch the commands for.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or ID of the guild to fetch the commands for. If left as</span>
<span class=sd>            `hikari.undefined.UNDEFINED` then this will only return the global</span>
<span class=sd>            commands, otherwise this will only return the commands set exclusively</span>
<span class=sd>            for the specific guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.commands.PartialCommand]</span>
<span class=sd>            A sequence of the commands declared for the provided application.</span>
<span class=sd>            This will exclusively either contain the commands set for a specific</span>
<span class=sd>            guild if `guild` is provided or the global commands if not.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the target guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_application_command</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>options</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandOption</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>default_permission</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>commands</span><span class=o>.</span><span class=n>SlashCommand</span><span class=p>:</span>
        <span class=sa>r</span><span class=sd>"""Create an application slash command.</span>

<span class=sd>        .. deprecated:: 2.0.0.dev106</span>
<span class=sd>            Use `RESTClient.create_slash_command` instead.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to create a command for.</span>
<span class=sd>        name : str</span>
<span class=sd>            The command's name. This should match the regex `^[\w-]{1,32}$` in</span>
<span class=sd>            Unicode mode and be lowercase.</span>
<span class=sd>        description : str</span>
<span class=sd>            The description to set for the command.</span>
<span class=sd>            This should be inclusively between 1-100 characters in length.</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or ID of the specific guild this should be made for.</span>
<span class=sd>            If left as `hikari.undefined.UNDEFINED` then this call will create</span>
<span class=sd>            a global command rather than a guild specific one.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        options : hikari.undefined.UndefinedOr[typing.Sequence[hikari.commands.CommandOption]]</span>
<span class=sd>            A sequence of up to 10 options for this command.</span>
<span class=sd>        default_permission : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            Whether this command should be enabled by default (without any</span>
<span class=sd>            permissions) when added to a guild.</span>

<span class=sd>            Defaults to `True`.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.commands.SlashCommand</span>
<span class=sd>            Object of the created command.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application isn't found.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_slash_command</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>options</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandOption</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>default_permission</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>commands</span><span class=o>.</span><span class=n>SlashCommand</span><span class=p>:</span>
        <span class=sa>r</span><span class=sd>"""Create an application command.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to create a command for.</span>
<span class=sd>        name : str</span>
<span class=sd>            The command's name. This should match the regex `^[\w-]{1,32}$` in</span>
<span class=sd>            Unicode mode and be lowercase.</span>
<span class=sd>        description : str</span>
<span class=sd>            The description to set for the command.</span>
<span class=sd>            This should be inclusively between 1-100 characters in length.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or ID of the specific guild this should be made for.</span>
<span class=sd>            If left as `hikari.undefined.UNDEFINED` then this call will create</span>
<span class=sd>            a global command rather than a guild specific one.</span>
<span class=sd>        options : hikari.undefined.UndefinedOr[typing.Sequence[hikari.commands.CommandOption]]</span>
<span class=sd>            A sequence of up to 10 options for this command.</span>
<span class=sd>        default_permission : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            Whether this command should be enabled by default (without any</span>
<span class=sd>            permissions) when added to a guild.</span>

<span class=sd>            Defaults to `True`.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.commands.SlashCommand</span>
<span class=sd>            Object of the created command.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application isn't found.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_context_menu_command</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=nb>type</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Literal</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandType</span><span class=o>.</span><span class=n>USER</span><span class=p>,</span> <span class=n>commands</span><span class=o>.</span><span class=n>CommandType</span><span class=o>.</span><span class=n>MESSAGE</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>default_permission</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>commands</span><span class=o>.</span><span class=n>ContextMenuCommand</span><span class=p>:</span>
        <span class=sa>r</span><span class=sd>"""Create an application command.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to create a command for.</span>
<span class=sd>        name : str</span>
<span class=sd>            The command's name. This should match the regex `^[\w-]{1,32}$` in</span>
<span class=sd>            Unicode mode and be lowercase.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or ID of the specific guild this should be made for.</span>
<span class=sd>            If left as `hikari.undefined.UNDEFINED` then this call will create</span>
<span class=sd>            a global command rather than a guild specific one.</span>
<span class=sd>        default_permission : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            Whether this command should be enabled by default (without any</span>
<span class=sd>            permissions) when added to a guild.</span>

<span class=sd>            Defaults to `True`.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.commands.ContextMenuCommand</span>
<span class=sd>            Object of the created command.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application isn't found.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>set_application_commands</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>commands</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>CommandBuilder</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>]:</span>
        <span class=sd>"""Set the commands for an application.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            Any existing commands not included in the provided commands array</span>
<span class=sd>            will be deleted.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to create a command for.</span>
<span class=sd>        commands: typing.Sequence[hikari.api.special_endpoints.CommandBuilder]</span>
<span class=sd>            A sequence of up to 100 initialised command builder objects of the</span>
<span class=sd>            commands to set for this the application.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or ID of the specific guild to set the commands for.</span>
<span class=sd>            If left as `hikari.undefined.UNDEFINED` then this set the global</span>
<span class=sd>            commands rather than guild specific commands.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.commands.PartialCommand]</span>
<span class=sd>            A sequence of the set command objects.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application isn't found.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_application_command</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>command</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>options</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandOption</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>:</span>
        <span class=sd>"""Edit a registered application command.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to edit a command for.</span>
<span class=sd>        command : hikari.snowflakes.SnowflakeishOr[hikari.commands.PartialCommand]</span>
<span class=sd>            Object or ID of the command to modify.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]]</span>
<span class=sd>            Object or ID of the guild to edit a command for if this is a guild</span>
<span class=sd>            specific command. Leave this as `hikari.undefined.UNDEFINED` to delete</span>
<span class=sd>            a global command.</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            The name to set for the command. Leave as `hikari.undefined.UNDEFINED`</span>
<span class=sd>            to not change.</span>
<span class=sd>        description : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            The description to set for the command. Leave as `hikari.undefined.UNDEFINED`</span>
<span class=sd>            to not change.</span>
<span class=sd>        options : hikari.undefined.UndefinedOr[typing.Sequence[hikari.commands.CommandOption]]</span>
<span class=sd>            A sequence of up to 10 options to set for this command. Leave this as</span>
<span class=sd>            `hikari.undefined.UNDEFINED` to not change.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.commands.PartialCommand</span>
<span class=sd>            The edited command object.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application or command isn't found.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_application_command</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>command</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a registered application command.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to delete a command for.</span>
<span class=sd>        command : hikari.snowflakes.SnowflakeishOr[hikari.commands.PartialCommand]</span>
<span class=sd>            Object or ID of the command to delete.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]]</span>
<span class=sd>            Object or ID of the guild to delete a command for if this is a guild</span>
<span class=sd>            specific command. Leave this as `hikari.undefined.UNDEFINED` to</span>
<span class=sd>            delete a global command.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application or command isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_application_guild_commands_permissions</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>GuildCommandPermissions</span><span class=p>]:</span>
        <span class=sd>"""Fetch the command permissions registered in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to fetch the command permissions for.</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]]</span>
<span class=sd>            Object or ID of the guild to fetch the command permissions for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.commands.GuildCommandPermissions]</span>
<span class=sd>            Sequence of the guild command permissions set for the specified guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands or guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_application_command_permissions</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>command</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>commands</span><span class=o>.</span><span class=n>GuildCommandPermissions</span><span class=p>:</span>
        <span class=sd>"""Fetch the permissions registered for a specific command in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to fetch the command permissions for.</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]]</span>
<span class=sd>            Object or ID of the guild to fetch the command permissions for.</span>
<span class=sd>        command: hikari.snowflakes.SnowflakeishOr[hikari.commands.PartialCommand]</span>
<span class=sd>            Objecr or ID of the command to fetch the command permissions for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.commands.GuildCommandPermissions</span>
<span class=sd>            Object of the command permissions set for the specified command.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands or guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application or command isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>set_application_guild_commands_permissions</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>permissions</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Mapping</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>],</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandPermission</span><span class=p>]</span>
        <span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>GuildCommandPermissions</span><span class=p>]:</span>
        <span class=sd>"""Set permissions in a guild for multiple commands.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This overwrites any previously set permissions for the specified</span>
<span class=sd>            commands.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to set the command permissions for.</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]]</span>
<span class=sd>            Object or ID of the guild to set the command permissions for.</span>
<span class=sd>        permissions : typing.Mapping[hikari.snowflakes.SnowflakeishOr[hikari.commands.PartialCommand], typing.Sequence[hikari.commands.CommandPermission]]</span>
<span class=sd>            Mapping of objects and/or IDs of commands to sequences of the commands</span>
<span class=sd>            to set for the specified guild.</span>

<span class=sd>            .. warning::</span>
<span class=sd>                Only a maximum of up to 10 permissions can be set per command.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.commands.GuildCommandPermissions]</span>
<span class=sd>            Sequence of the set guild command permissions.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands or guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application or command isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>set_application_command_permissions</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>command</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>],</span>
        <span class=n>permissions</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandPermission</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>commands</span><span class=o>.</span><span class=n>GuildCommandPermissions</span><span class=p>:</span>
        <span class=sd>"""Set permissions for a specific command.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This overwrites any previously set permissions.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to set the command permissions for.</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]]</span>
<span class=sd>            Object or ID of the guild to set the command permissions for.</span>
<span class=sd>        command : hikari.snowflakes.SnowflakeishOr[hikari.commands.PartialCommand]</span>
<span class=sd>            Object or ID of the command to set the permissions for.</span>
<span class=sd>        permissions : typing.Sequence[hikari.commands.CommandPermission]</span>
<span class=sd>            Sequence of up to 10 of the permission objects to set.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.commands.GuildCommandPermissions</span>
<span class=sd>            Object of the set permissions.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands or guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application or command isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>interaction_deferred_builder</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=nb>type</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>base_interactions</span><span class=o>.</span><span class=n>ResponseType</span><span class=p>,</span> <span class=nb>int</span><span class=p>],</span> <span class=o>/</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>InteractionDeferredBuilder</span><span class=p>:</span>
        <span class=sd>"""Create a builder for a deferred message interaction response.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        type: typing.Union[hikari.interactions.base_interactions.ResponseType, int]</span>
<span class=sd>            The type of deferred message response this builder is for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.InteractionDeferredBuilder</span>
<span class=sd>            The deferred message interaction response builder object.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>interaction_autocomplete_builder</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>choices</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandChoice</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>InteractionAutocompleteBuilder</span><span class=p>:</span>
        <span class=sd>"""Create a builder for an autocomplete interaction response.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.InteractionAutocompleteBuilder</span>
<span class=sd>            The autocomplete interaction response builder object.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>interaction_message_builder</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=nb>type</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>base_interactions</span><span class=o>.</span><span class=n>ResponseType</span><span class=p>,</span> <span class=nb>int</span><span class=p>],</span> <span class=o>/</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>InteractionMessageBuilder</span><span class=p>:</span>
        <span class=sd>"""Create a builder for a message interaction response.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        type : typing.Union[hikari.interactions.base_interactions.ResponseType, int]</span>
<span class=sd>            The type of message response this builder is for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.InteractionMessageBuilder</span>
<span class=sd>            The interaction message response builder object.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_interaction_response</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span> <span class=n>token</span><span class=p>:</span> <span class=nb>str</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Fetch the initial response for an interaction.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to fetch a command for.</span>
<span class=sd>        token: str</span>
<span class=sd>            Token of the interaction to get the initial response for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            Message object of the initial response.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the target interaction.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the initial response isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_interaction_response</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>interaction</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>base_interactions</span><span class=o>.</span><span class=n>PartialInteraction</span><span class=p>],</span>
        <span class=n>token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>response_type</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=n>base_interactions</span><span class=o>.</span><span class=n>ResponseType</span><span class=p>],</span>
        <span class=n>content</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Any</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>flags</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=n>messages_</span><span class=o>.</span><span class=n>MessageFlag</span><span class=p>,</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedType</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>tts</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachment</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachments</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>component</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>components</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embed</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embeds</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mentions_everyone</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>role_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Create the initial response for a interaction.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            Calling this with an interaction which already has an initial</span>
<span class=sd>            response will result in this raising a `hikari.errors.NotFoundError`.</span>
<span class=sd>            This includes if the REST interaction server has already responded</span>
<span class=sd>            to the request.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        interaction : hikari.snowflakes.SnowflakeishOr[hikari.interactions.base_interactions.PartialInteraction]</span>
<span class=sd>            Object or ID of the interaction this response is for.</span>
<span class=sd>        token : str</span>
<span class=sd>            The command interaction's token.</span>
<span class=sd>        response_type : typing.Union[int, hikari.interactions.base_interactions.ResponseType]</span>
<span class=sd>            The type of interaction response this is.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        content : hikari.undefined.UndefinedOr[typing.Any]</span>
<span class=sd>            If provided, the message contents. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then nothing will be sent</span>
<span class=sd>            in the content. Any other value here will be cast to a</span>
<span class=sd>            `str`.</span>

<span class=sd>            If this is a `hikari.embeds.Embed` and no `embed` nor</span>
<span class=sd>            no `embeds` kwarg is provided, then this will instead</span>
<span class=sd>            update the embed. This allows for simpler syntax when</span>
<span class=sd>            sending an embed alone.</span>
<span class=sd>        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish],</span>
<span class=sd>            If provided, the message attachment. This can be a resource,</span>
<span class=sd>            or string of a path on your computer or a URL.</span>
<span class=sd>        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]],</span>
<span class=sd>            If provided, the message attachments. These can be resources, or</span>
<span class=sd>            strings consisting of paths on your computer or URLs.</span>
<span class=sd>        component : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder]</span>
<span class=sd>            If provided, builder object of the component to include in this message.</span>
<span class=sd>        components : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]</span>
<span class=sd>            If provided, a sequence of the component builder objects to include</span>
<span class=sd>            in this message.</span>
<span class=sd>        embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed]</span>
<span class=sd>            If provided, the message embed.</span>
<span class=sd>        embeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed]]</span>
<span class=sd>            If provided, the message embeds.</span>
<span class=sd>        flags : typing.Union[int, hikari.messages.MessageFlag, hikari.undefined.UndefinedType]</span>
<span class=sd>            If provided, the message flags this response should have.</span>

<span class=sd>            As of writing the only message flag which can be set here is</span>
<span class=sd>            `hikari.messages.MessageFlag.EPHEMERAL`.</span>
<span class=sd>        tts : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the message will be read out by a screen</span>
<span class=sd>            reader using Discord's TTS (text-to-speech) system.</span>
<span class=sd>        mentions_everyone : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the message should parse @everyone/@here</span>
<span class=sd>            mentions.</span>
<span class=sd>        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], bool]]</span>
<span class=sd>            If provided, and `True`, all user mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all user mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.users.PartialUser` derivatives to enforce mentioning</span>
<span class=sd>            specific users.</span>
<span class=sd>        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], bool]]</span>
<span class=sd>            If provided, and `True`, all role mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all role mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.guilds.PartialRole` derivatives to enforce mentioning</span>
<span class=sd>            specific roles.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        ValueError</span>
<span class=sd>            If more than 100 unique objects/entities are passed for</span>
<span class=sd>            `role_mentions` or `user_mentions`.</span>
<span class=sd>        TypeError</span>
<span class=sd>            If both `embed` and `embeds` are specified.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            This may be raised in several discrete situations, such as messages</span>
<span class=sd>            being empty with no embeds; messages with more than 2000 characters</span>
<span class=sd>            in them, embeds that exceed one of the many embed limits</span>
<span class=sd>            invalid image URLs in embeds.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the interaction is not found or if the interaction's initial</span>
<span class=sd>            response has already been created.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_interaction_response</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>content</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Any</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>attachment</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachments</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>component</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>components</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embed</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embeds</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>replace_attachments</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
        <span class=n>mentions_everyone</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>role_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Edit the initial response to a command interaction.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        Mentioning everyone, roles, or users in message edits currently</span>
<span class=sd>        will not send a push notification showing a new mention to people</span>
<span class=sd>        on Discord. It will still highlight in their chat as if they</span>
<span class=sd>        were mentioned, however.</span>

<span class=sd>        Also important to note that if you specify a text `content`, `mentions_everyone`,</span>
<span class=sd>        `mentions_reply`, `user_mentions`, and `role_mentions` will default</span>
<span class=sd>        to `False` as the message will be re-parsed for mentions. This will</span>
<span class=sd>        also occur if only one of the four are specified</span>

<span class=sd>        This is a limitation of Discord's design. If in doubt, specify all</span>
<span class=sd>        four of them each time.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to edit a command response for.</span>
<span class=sd>        token : str</span>
<span class=sd>            The interaction's token.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        content : hikari.undefined.UndefinedOr[typing.Any]</span>
<span class=sd>            If provided, the message content to update with. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then the content will not</span>
<span class=sd>            be changed. If `None`, then the content will be removed.</span>

<span class=sd>            Any other value will be cast to a `str` before sending.</span>

<span class=sd>            If this is a `hikari.embeds.Embed` and neither the</span>
<span class=sd>            `embed` or `embeds` kwargs are provided or if this is a</span>
<span class=sd>            `hikari.files.Resourceish` and neither the `attachment` or</span>
<span class=sd>            `attachments` kwargs are provided, the values will be overwritten.</span>
<span class=sd>            This allows for simpler syntax when sending an embed or an</span>
<span class=sd>            attachment alone.</span>
<span class=sd>        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the attachment to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous attachment, if</span>
<span class=sd>            present, is not changed. If this is `None`, then the</span>
<span class=sd>            attachment is removed, if present. Otherwise, the new attachment</span>
<span class=sd>            that was provided will be attached.</span>
<span class=sd>        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]]</span>
<span class=sd>            If provided, the attachments to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous attachments, if</span>
<span class=sd>            present, are not changed. If this is `None`, then the</span>
<span class=sd>            attachments is removed, if present. Otherwise, the new attachments</span>
<span class=sd>            that were provided will be attached.</span>
<span class=sd>        component : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder]</span>
<span class=sd>            If provided, builder object of the component to set for this message.</span>
<span class=sd>            This component will replace any previously set components and passing</span>
<span class=sd>            `None` will remove all components.</span>
<span class=sd>        components : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]</span>
<span class=sd>            If provided, a sequence of the component builder objects set for</span>
<span class=sd>            this message. These components will replace any previously set</span>
<span class=sd>            components and passing `None` or an empty sequence will</span>
<span class=sd>            remove all components.</span>
<span class=sd>        embed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed]</span>
<span class=sd>            If provided, the embed to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.</span>
<span class=sd>            If this is `None` then any present embeds are removed.</span>
<span class=sd>            Otherwise, the new embed that was provided will be used as the</span>
<span class=sd>            replacement.</span>
<span class=sd>        embeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed]]</span>
<span class=sd>            If provided, the embeds to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.</span>
<span class=sd>            If this is `None` then any present embeds are removed.</span>
<span class=sd>            Otherwise, the new embeds that were provided will be used as the</span>
<span class=sd>            replacement.</span>
<span class=sd>        replace_attachments: bool</span>
<span class=sd>            Whether to replace the attachments with the provided ones. Defaults</span>
<span class=sd>            to `False`.</span>

<span class=sd>            Note this will also overwrite the embed attachments.</span>
<span class=sd>        mentions_everyone : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the message should parse @everyone/@here</span>
<span class=sd>            mentions.</span>
<span class=sd>        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], bool]]</span>
<span class=sd>            If provided, and `True`, all user mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all user mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.users.PartialUser` derivatives to enforce mentioning</span>
<span class=sd>            specific users.</span>
<span class=sd>        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], bool]]</span>
<span class=sd>            If provided, and `True`, all role mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all role mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.guilds.PartialRole` derivatives to enforce mentioning</span>
<span class=sd>            specific roles.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The edited message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        ValueError</span>
<span class=sd>            If both `attachment` and `attachments`, `component` and `components`</span>
<span class=sd>            or `embed` and `embeds` are specified.</span>
<span class=sd>        TypeError</span>
<span class=sd>            If `attachments`, `components` or `embeds` is passed but is not a</span>
<span class=sd>            sequence.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            This may be raised in several discrete situations, such as messages</span>
<span class=sd>            being empty with no attachments or embeds; messages with more than</span>
<span class=sd>            2000 characters in them, embeds that exceed one of the many embed</span>
<span class=sd>            limits; too many attachments; attachments that are too large;</span>
<span class=sd>            invalid image URLs in embeds; too many components.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the interaction or the message are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_interaction_response</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span> <span class=n>token</span><span class=p>:</span> <span class=nb>str</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete the initial response of an interaction.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to delete a command response for.</span>
<span class=sd>        token : str</span>
<span class=sd>            The interaction's token.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the interaction or response is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_autocomplete_response</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>interaction</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>base_interactions</span><span class=o>.</span><span class=n>PartialInteraction</span><span class=p>],</span>
        <span class=n>token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>choices</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandChoice</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Create the initial response for an autocomplete interaction.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        interaction : hikari.snowflakes.SnowflakeishOr[hikari.interactions.base_interactions.PartialInteraction]</span>
<span class=sd>            Object or ID of the interaction this response is for.</span>
<span class=sd>        token : str</span>
<span class=sd>            The command interaction's token.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        choices : typing.Sequence[commands.CommandChoice]</span>
<span class=sd>            The autocomplete choices themselves.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the interaction is not found or if the interaction's initial</span>
<span class=sd>            response has already been created.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>build_action_row</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>ActionRowBuilder</span><span class=p>:</span>
        <span class=sd>"""Build an action row message component for use in message create and REST calls.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.ActionRowBuilder</span>
<span class=sd>            The initialised action row builder.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Interface for functionality that a REST API implementation provides.</div><section class=member_divisor><h5>Variables and properties</h5><div id=RESTClient.entity_factory><div class="attr variable"><a class=headerlink href=#RESTClient.entity_factory>#  </a><span class=name>entity_factory</span><span class=annotation>: <a href=entity_factory.html#EntityFactory>hikari.api.entity_factory.EntityFactory</a></span></div><div class=docstring><p>Entity factory used by this REST client.</div></div><div id=RESTClient.http_settings><div class="attr variable"><a class=headerlink href=#RESTClient.http_settings>#  </a><span class=name>http_settings</span><span class=annotation>: <a href=../config.html#HTTPSettings>hikari.config.HTTPSettings</a></span></div><div class=docstring><p>HTTP settings in use by this component.</div></div><div id=RESTClient.is_alive><div class="attr variable"><a class=headerlink href=#RESTClient.is_alive>#  </a><span class=name>is_alive</span><span class=annotation>: bool</span></div><div class=docstring><p>Whether this component is alive.</div></div><div id=RESTClient.proxy_settings><div class="attr variable"><a class=headerlink href=#RESTClient.proxy_settings>#  </a><span class=name>proxy_settings</span><span class=annotation>: <a href=../config.html#ProxySettings>hikari.config.ProxySettings</a></span></div><div class=docstring><p>Proxy settings in use by this component.</div></div><div id=RESTClient.token_type><div class="attr variable"><a class=headerlink href=#RESTClient.token_type>#  </a><span class=name>token_type</span><span class=annotation>: Union[str, <a href=../applications.html#TokenType>hikari.applications.TokenType</a>, NoneType]</span></div><div class=docstring><p>Type of token this client is using for most requests.<p>If this is <code>None</code> then this client will likely only work for some endpoints such as public and webhook ones.</div></div></section><section class=member_divisor><h5>Methods</h5><div id=RESTClient.add_reaction><div class="attr function"><a class=headerlink href=#RESTClient.add_reaction>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>add_reaction</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   message: Union[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   emoji: Union[str, <a href=../emojis.html#Emoji>hikari.emojis.Emoji</a>],<br>   emoji_id: Union[<a href=../emojis.html#CustomEmoji>hikari.emojis.CustomEmoji</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>add_reaction</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>emojis</span><span class=o>.</span><span class=n>Emoji</span><span class=p>],</span>
        <span class=n>emoji_id</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Add a reaction emoji to a message in a given channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel where the message to add the reaction to is. This</span>
<span class=sd>            may be a `hikari.channels.TextableChannel` or the ID of an existing</span>
<span class=sd>            channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to add a reaction to. This may be the</span>
<span class=sd>            object or the ID of an existing message.</span>
<span class=sd>        emoji : typing.Union[str, hikari.emojis.Emoji]</span>
<span class=sd>            Object or name of the emoji to react with.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]]</span>
<span class=sd>            ID of the custom emoji to react with.</span>
<span class=sd>            This should only be provided when a custom emoji's name is passed</span>
<span class=sd>            for `emoji`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid unicode emoji is given, or if the given custom emoji</span>
<span class=sd>            does not exist.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `ADD_REACTIONS` (this is only necessary if you</span>
<span class=sd>            are the first person to add the reaction).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Add a reaction emoji to a message in a given channel.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>]): The channel where the message to add the reaction to is. This may be a <code><a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a></code> or the ID of an existing channel.<li><strong>message</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>]): The message to add a reaction to. This may be the object or the ID of an existing message.<li><strong>emoji</strong> (typing.Union[str, <a href=../emojis.html#Emoji>hikari.emojis.Emoji</a>]): Object or name of the emoji to react with.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>emoji_id</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../emojis.html#CustomEmoji>hikari.emojis.CustomEmoji</a>]]): ID of the custom emoji to react with. This should only be provided when a custom emoji's name is passed for <code>emoji</code>.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If an invalid unicode emoji is given, or if the given custom emoji does not exist.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>ADD_REACTIONS</code> (this is only necessary if you are the first person to add the reaction).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel or message is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.add_role_to_member><div class="attr function"><a class=headerlink href=#RESTClient.add_role_to_member>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>add_role_to_member</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   user: Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   role: Union[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>add_role_to_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=n>role</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Add a role to a member.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild where the member is in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to add the role to. This may be the</span>
<span class=sd>            object or the ID of an existing user.</span>
<span class=sd>        role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]</span>
<span class=sd>            The role to add. This may be the object or the</span>
<span class=sd>            ID of an existing role.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_ROLES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild, user or role are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Add a role to a member.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild where the member is in. This may be the object or the ID of an existing guild.<li><strong>user</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>]): The user to add the role to. This may be the object or the ID of an existing user.<li><strong>role</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>]): The role to add. This may be the object or the ID of an existing role.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_ROLES</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild, user or role are not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.add_user_to_guild><div class="attr function"><a class=headerlink href=#RESTClient.add_user_to_guild>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>add_user_to_guild</span><span class=signature>(<br>   self,<br>   access_token: Union[str, <a href=../applications.html#PartialOAuth2Token>hikari.applications.PartialOAuth2Token</a>],<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   user: Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   nick: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   roles: Union[Sequence[Union[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   mute: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   deaf: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> Optional[<a href=../guilds.html#Member>hikari.guilds.Member</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>add_user_to_guild</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>access_token</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>applications</span><span class=o>.</span><span class=n>PartialOAuth2Token</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>nick</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>roles</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mute</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>deaf</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>Member</span><span class=p>]:</span>
        <span class=sd>"""Add a user to a guild.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This requires the `access_token` to have the</span>
<span class=sd>            `hikari.applications.OAuth2Scope.GUILDS_JOIN` scope enabled along</span>
<span class=sd>            with the authorization of a Bot which has `MANAGE_INVITES`</span>
<span class=sd>            permission within the target guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        access_token : typing.Union[str, hikari.applications.PartialOAuth2Token]</span>
<span class=sd>            Object or string of the access token to use for this request.</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to add the user to. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to add to the guild. This may be the object</span>
<span class=sd>            or the ID of an existing user.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        nick : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the nick to add to the user when he joins the guild.</span>

<span class=sd>            Requires the `MANAGE_NICKNAMES` permission on the guild.</span>
<span class=sd>        roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole]]</span>
<span class=sd>            If provided, the roles to add to the user when he joins the guild.</span>
<span class=sd>            This may be a collection objects or IDs of existing roles.</span>

<span class=sd>            Requires the `MANAGE_ROLES` permission on the guild.</span>
<span class=sd>        mute : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, the mute state to add the user when he joins the guild.</span>

<span class=sd>            Requires the `MUTE_MEMBERS` permission on the guild.</span>
<span class=sd>        deaf : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, the deaf state to add the user when he joins the guild.</span>

<span class=sd>            Requires the `DEAFEN_MEMBERS` permission on the guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Optional[hikari.guilds.Member]</span>
<span class=sd>            `None` if the user was already part of the guild, else</span>
<span class=sd>            `hikari.guilds.Member`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild you want to add the user to,</span>
<span class=sd>            if you are missing permissions to do one of the things you specified,</span>
<span class=sd>            if you are using an access token for another user, if the token is</span>
<span class=sd>            bound to another bot or if the access token doesn't have the</span>
<span class=sd>            `hikari.applications.OAuth2Scope.GUILDS_JOIN` scope enabled.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If you own the guild or the user is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Add a user to a guild.<p><em>Note:</em> This requires the <code>access_token</code> to have the <code><a href=../applications.html#OAuth2Scope.GUILDS_JOIN>hikari.applications.OAuth2Scope.GUILDS_JOIN</a></code> scope enabled along with the authorization of a Bot which has <code>MANAGE_INVITES</code> permission within the target guild.<h6 id=parameters>Parameters</h6><ul><li><strong>access_token</strong> (typing.Union[str, <a href=../applications.html#PartialOAuth2Token>hikari.applications.PartialOAuth2Token</a>]): Object or string of the access token to use for this request.<li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to add the user to. This may be the object or the ID of an existing guild.<li><strong>user</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>]): The user to add to the guild. This may be the object or the ID of an existing user.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><p><strong>nick</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the nick to add to the user when he joins the guild.</p> <p>Requires the <code>MANAGE_NICKNAMES</code> permission on the guild.<li><p><strong>roles</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishSequence>hikari.snowflakes.SnowflakeishSequence</a>[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>]]): If provided, the roles to add to the user when he joins the guild. This may be a collection objects or IDs of existing roles.</p> <p>Requires the <code>MANAGE_ROLES</code> permission on the guild.<li><p><strong>mute</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, the mute state to add the user when he joins the guild.</p> <p>Requires the <code>MUTE_MEMBERS</code> permission on the guild.<li><p><strong>deaf</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, the deaf state to add the user when he joins the guild.</p> <p>Requires the <code>DEAFEN_MEMBERS</code> permission on the guild.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.Optional[<a href=../guilds.html#Member>hikari.guilds.Member</a>]</strong>: <code>None</code> if the user was already part of the guild, else <code><a href=../guilds.html#Member>hikari.guilds.Member</a></code>.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are not part of the guild you want to add the user to, if you are missing permissions to do one of the things you specified, if you are using an access token for another user, if the token is bound to another bot or if the access token doesn't have the <code><a href=../applications.html#OAuth2Scope.GUILDS_JOIN>hikari.applications.OAuth2Scope.GUILDS_JOIN</a></code> scope enabled.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If you own the guild or the user is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.authorize_access_token><div class="attr function"><a class=headerlink href=#RESTClient.authorize_access_token>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>authorize_access_token</span><span class=signature>(<br>   self,<br>   client: Union[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   client_secret: str,<br>   code: str,<br>   redirect_uri: str<br>) -> <a href=../applications.html#OAuth2AuthorizationToken>hikari.applications.OAuth2AuthorizationToken</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>authorize_access_token</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>client</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>client_secret</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>code</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>redirect_uri</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>applications</span><span class=o>.</span><span class=n>OAuth2AuthorizationToken</span><span class=p>:</span>
        <span class=sd>"""Authorize an OAuth2 token using the authorize code grant type.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        client : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to authorize with.</span>
<span class=sd>        client_secret : str</span>
<span class=sd>            Secret of the application to authorize with.</span>
<span class=sd>        code : str</span>
<span class=sd>            The authorization code to exchange for an OAuth2 access token.</span>
<span class=sd>        redirect_uri : str</span>
<span class=sd>            The redirect uri that was included in the authorization request.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.applications.OAuth2AuthorizationToken</span>
<span class=sd>            Object of the authorized OAuth2 token.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid redirect uri or code is passed.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            When an client or client secret is passed.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Authorize an OAuth2 token using the authorize code grant type.<h6 id=parameters>Parameters</h6><ul><li><strong>client</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>]): Object or ID of the application to authorize with.<li><strong>client_secret</strong> (str): Secret of the application to authorize with.<li><strong>code</strong> (str): The authorization code to exchange for an OAuth2 access token.<li><strong>redirect_uri</strong> (str): The redirect uri that was included in the authorization request.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../applications.html#OAuth2AuthorizationToken>hikari.applications.OAuth2AuthorizationToken</a></strong>: Object of the authorized OAuth2 token.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If an invalid redirect uri or code is passed.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: When an client or client secret is passed.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.authorize_client_credentials_token><div class="attr function"><a class=headerlink href=#RESTClient.authorize_client_credentials_token>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>authorize_client_credentials_token</span><span class=signature>(<br>   self,<br>   client: Union[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   client_secret: str,<br>   scopes: Sequence[Union[<a href=../applications.html#OAuth2Scope>hikari.applications.OAuth2Scope</a>, str]]<br>) -> <a href=../applications.html#PartialOAuth2Token>hikari.applications.PartialOAuth2Token</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>authorize_client_credentials_token</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>client</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>client_secret</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=c1># While according to the spec scopes are optional here, Discord requires that "valid" scopes are passed.</span>
        <span class=n>scopes</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>applications</span><span class=o>.</span><span class=n>OAuth2Scope</span><span class=p>,</span> <span class=nb>str</span><span class=p>]],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>applications</span><span class=o>.</span><span class=n>PartialOAuth2Token</span><span class=p>:</span>
        <span class=sd>"""Authorize a client credentials token for an application.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        client : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to authorize as.</span>
<span class=sd>        client_secret : str</span>
<span class=sd>            Secret of the application to authorize as.</span>
<span class=sd>        scopes : typing.Sequence[typing.Union[hikari.applications.OAuth2Scope, str]]</span>
<span class=sd>            The scopes to authorize for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.applications.PartialOAuth2Token</span>
<span class=sd>            Object of the authorized partial OAuth2 token.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If invalid any invalid or malformed scopes are passed.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            When an client or client secret is passed.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Authorize a client credentials token for an application.<h6 id=parameters>Parameters</h6><ul><li><strong>client</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>]): Object or ID of the application to authorize as.<li><strong>client_secret</strong> (str): Secret of the application to authorize as.<li><strong>scopes</strong> (typing.Sequence[typing.Union[<a href=../applications.html#OAuth2Scope>hikari.applications.OAuth2Scope</a>, str]]): The scopes to authorize for.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../applications.html#PartialOAuth2Token>hikari.applications.PartialOAuth2Token</a></strong>: Object of the authorized partial OAuth2 token.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If invalid any invalid or malformed scopes are passed.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: When an client or client secret is passed.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.ban_member><div class="attr function"><a class=headerlink href=#RESTClient.ban_member>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>ban_member</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   user: Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   delete_message_days: Union[int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>ban_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>delete_message_days</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Alias of `hikari.impl.rest.RESTClient.ban_user`."""</span>
</pre></div></details><div class=docstring><p>Alias of <code><a href=../impl/rest.html#RESTClient.ban_user>hikari.impl.rest.RESTClient.ban_user</a></code>.</div></div><div id=RESTClient.ban_user><div class="attr function"><a class=headerlink href=#RESTClient.ban_user>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>ban_user</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   user: Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   delete_message_days: Union[int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>ban_user</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>delete_message_days</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Ban a member from a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to ban the member from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to kick. This may be the object</span>
<span class=sd>            or the ID of an existing user.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        delete_message_days : hikari.undefined.UndefinedNoneOr[int]</span>
<span class=sd>            If provided, the number of days to delete messages for.</span>
<span class=sd>            This must be between 0 and 7.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `BAN_MEMBERS` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or user are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Ban a member from a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to ban the member from. This may be the object or the ID of an existing guild.<li><strong>user</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>]): The user to kick. This may be the object or the ID of an existing user.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>delete_message_days</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[int]): If provided, the number of days to delete messages for. This must be between 0 and 7.<li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>BAN_MEMBERS</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild or user are not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.begin_guild_prune><div class="attr function"><a class=headerlink href=#RESTClient.begin_guild_prune>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>begin_guild_prune</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   days: Union[int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   compute_prune_count: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   include_roles: Union[Sequence[Union[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> Optional[int]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>begin_guild_prune</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>days</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>compute_prune_count</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>include_roles</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=nb>int</span><span class=p>]:</span>
        <span class=sd>"""Begin the guild prune.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to begin the guild prune in. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        days : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, number of days to count prune for.</span>
<span class=sd>        compute_prune_count: hikari.snowflakes.SnowflakeishOr[bool]</span>
<span class=sd>            If provided, whether to return the prune count. This is discouraged</span>
<span class=sd>            for large guilds.</span>
<span class=sd>        include_roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole]]</span>
<span class=sd>            If provided, the role(s) to include. By default, this endpoint will</span>
<span class=sd>            not count users with roles. Providing roles using this attribute</span>
<span class=sd>            will make members with the specified roles also get included into</span>
<span class=sd>            the count.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Optional[int]</span>
<span class=sd>            If `compute_prune_count` is not provided or `True`, the</span>
<span class=sd>            number of members pruned. Else `None`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `KICK_MEMBERS` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>
</pre></div></details><div class=docstring><p>Begin the guild prune.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to begin the guild prune in. This may be the object or the ID of an existing guild.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>days</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[int]): If provided, number of days to count prune for.<li><strong>compute_prune_count</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[bool]): If provided, whether to return the prune count. This is discouraged for large guilds.<li><strong>include_roles</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishSequence>hikari.snowflakes.SnowflakeishSequence</a>[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>]]): If provided, the role(s) to include. By default, this endpoint will not count users with roles. Providing roles using this attribute will make members with the specified roles also get included into the count.<li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.Optional[int]</strong>: If <code>compute_prune_count</code> is not provided or <code>True</code>, the number of members pruned. Else <code>None</code>.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>KICK_MEMBERS</code> permission.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.build_action_row><div class="attr function"><a class=headerlink href=#RESTClient.build_action_row>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>def </span><span class=name>build_action_row</span><span class=signature>(self) -> <a href=special_endpoints.html#ActionRowBuilder>hikari.api.special_endpoints.ActionRowBuilder</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>build_action_row</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>ActionRowBuilder</span><span class=p>:</span>
        <span class=sd>"""Build an action row message component for use in message create and REST calls.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.ActionRowBuilder</span>
<span class=sd>            The initialised action row builder.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Build an action row message component for use in message create and REST calls.<h6 id=returns>Returns</h6><ul><li><strong><a href=special_endpoints.html#ActionRowBuilder>hikari.api.special_endpoints.ActionRowBuilder</a></strong>: The initialised action row builder.</ul></div></div><div id=RESTClient.close><div class="attr function"><a class=headerlink href=#RESTClient.close>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>close</span><span class=signature>(self) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>close</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Close the client session."""</span>
</pre></div></details><div class=docstring><p>Close the client session.</div></div><div id=RESTClient.command_builder><div class="attr function"><a class=headerlink href=#RESTClient.command_builder>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>def </span><span class=name>command_builder</span><span class=signature>(<br>   self,<br>   name: str,<br>   description: str<br>) -> <a href=special_endpoints.html#SlashCommandBuilder>hikari.api.special_endpoints.SlashCommandBuilder</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>command_builder</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>description</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>SlashCommandBuilder</span><span class=p>:</span>
        <span class=sa>r</span><span class=sd>"""Create a slash command builder for use in `RESTClient.set_application_commands`.</span>

<span class=sd>        .. deprecated:: 2.0.0.dev106</span>
<span class=sd>            Use `RESTClient.slash_command_builder` instead.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        name : str</span>
<span class=sd>            The command's name. This should match the regex `^[\w-]{1,32}$` in</span>
<span class=sd>            Unicode mode and be lowercase.</span>
<span class=sd>        description : str</span>
<span class=sd>            The description to set for the command.</span>
<span class=sd>            This should be inclusively between 1-100 characters in length.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.SlashCommandBuilder</span>
<span class=sd>            The created command builder object.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Create a slash command builder for use in <code><a href=#RESTClient.set_application_commands>RESTClient.set_application_commands</a></code>.<p><em>Deprecated since version 2.0.0.dev106:</em> Use <code><a href=#RESTClient.slash_command_builder>RESTClient.slash_command_builder</a></code> instead.<h6 id=parameters>Parameters</h6><ul><li><strong>name</strong> (str): The command's name. This should match the regex <code>^[\w-]{1,32}$</code> in Unicode mode and be lowercase.<li><strong>description</strong> (str): The description to set for the command. This should be inclusively between 1-100 characters in length.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=special_endpoints.html#SlashCommandBuilder>hikari.api.special_endpoints.SlashCommandBuilder</a></strong>: The created command builder object.</ul></div></div><div id=RESTClient.context_menu_command_builder><div class="attr function"><a class=headerlink href=#RESTClient.context_menu_command_builder>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>def </span><span class=name>context_menu_command_builder</span><span class=signature>(<br>   self,<br>   type: Union[<a href=../commands.html#CommandType>hikari.commands.CommandType</a>, int],<br>   name: str<br>) -> <a href=special_endpoints.html#ContextMenuCommandBuilder>hikari.api.special_endpoints.ContextMenuCommandBuilder</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>context_menu_command_builder</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=nb>type</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandType</span><span class=p>,</span> <span class=nb>int</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>ContextMenuCommandBuilder</span><span class=p>:</span>
        <span class=sa>r</span><span class=sd>"""Create a command builder for use in `RESTClient.set_application_commands`.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        type : commands.CommandType</span>
<span class=sd>            The commands's type.</span>
<span class=sd>        name : str</span>
<span class=sd>            The command's name.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.ContextMenuCommandBuilder</span>
<span class=sd>            The created command builder object.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Create a command builder for use in <code><a href=#RESTClient.set_application_commands>RESTClient.set_application_commands</a></code>.<h6 id=parameters>Parameters</h6><ul><li><strong>type</strong> (commands.CommandType): The commands's type.<li><strong>name</strong> (str): The command's name.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=special_endpoints.html#ContextMenuCommandBuilder>hikari.api.special_endpoints.ContextMenuCommandBuilder</a></strong>: The created command builder object.</ul></div></div><div id=RESTClient.create_application_command><div class="attr function"><a class=headerlink href=#RESTClient.create_application_command>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>create_application_command</span><span class=signature>(<br>   self,<br>   application: Union[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   name: str,<br>   description: str,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   *,<br>   options: Union[Sequence[<a href=../commands.html#CommandOption>hikari.commands.CommandOption</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   default_permission: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../commands.html#SlashCommand>hikari.commands.SlashCommand</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_application_command</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>options</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandOption</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>default_permission</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>commands</span><span class=o>.</span><span class=n>SlashCommand</span><span class=p>:</span>
        <span class=sa>r</span><span class=sd>"""Create an application slash command.</span>

<span class=sd>        .. deprecated:: 2.0.0.dev106</span>
<span class=sd>            Use `RESTClient.create_slash_command` instead.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to create a command for.</span>
<span class=sd>        name : str</span>
<span class=sd>            The command's name. This should match the regex `^[\w-]{1,32}$` in</span>
<span class=sd>            Unicode mode and be lowercase.</span>
<span class=sd>        description : str</span>
<span class=sd>            The description to set for the command.</span>
<span class=sd>            This should be inclusively between 1-100 characters in length.</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or ID of the specific guild this should be made for.</span>
<span class=sd>            If left as `hikari.undefined.UNDEFINED` then this call will create</span>
<span class=sd>            a global command rather than a guild specific one.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        options : hikari.undefined.UndefinedOr[typing.Sequence[hikari.commands.CommandOption]]</span>
<span class=sd>            A sequence of up to 10 options for this command.</span>
<span class=sd>        default_permission : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            Whether this command should be enabled by default (without any</span>
<span class=sd>            permissions) when added to a guild.</span>

<span class=sd>            Defaults to `True`.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.commands.SlashCommand</span>
<span class=sd>            Object of the created command.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application isn't found.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Create an application slash command.<p><em>Deprecated since version 2.0.0.dev106:</em> Use <code><a href=#RESTClient.create_slash_command>RESTClient.create_slash_command</a></code> instead.<h6 id=parameters>Parameters</h6><ul><li><strong>application</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>]): Object or ID of the application to create a command for.<li><strong>name</strong> (str): The command's name. This should match the regex <code>^[\w-]{1,32}$</code> in Unicode mode and be lowercase.<li><strong>description</strong> (str): The description to set for the command. This should be inclusively between 1-100 characters in length.<li><strong>guild</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): Object or ID of the specific guild this should be made for. If left as <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code> then this call will create a global command rather than a guild specific one.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>options</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Sequence[<a href=../commands.html#CommandOption>hikari.commands.CommandOption</a>]]): A sequence of up to 10 options for this command.<li><p><strong>default_permission</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): Whether this command should be enabled by default (without any permissions) when added to a guild.</p> <p>Defaults to <code>True</code>.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../commands.html#SlashCommand>hikari.commands.SlashCommand</a></strong>: Object of the created command.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you cannot access the provided application's commands.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the provided application isn't found.<li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.create_autocomplete_response><div class="attr function"><a class=headerlink href=#RESTClient.create_autocomplete_response>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>create_autocomplete_response</span><span class=signature>(<br>   self,<br>   interaction: Union[<a href=../interactions/base_interactions.html#PartialInteraction>hikari.interactions.base_interactions.PartialInteraction</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   token: str,<br>   choices: Sequence[<a href=../commands.html#CommandChoice>hikari.commands.CommandChoice</a>]<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_autocomplete_response</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>interaction</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>base_interactions</span><span class=o>.</span><span class=n>PartialInteraction</span><span class=p>],</span>
        <span class=n>token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>choices</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandChoice</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Create the initial response for an autocomplete interaction.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        interaction : hikari.snowflakes.SnowflakeishOr[hikari.interactions.base_interactions.PartialInteraction]</span>
<span class=sd>            Object or ID of the interaction this response is for.</span>
<span class=sd>        token : str</span>
<span class=sd>            The command interaction's token.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        choices : typing.Sequence[commands.CommandChoice]</span>
<span class=sd>            The autocomplete choices themselves.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the interaction is not found or if the interaction's initial</span>
<span class=sd>            response has already been created.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>
</pre></div></details><div class=docstring><p>Create the initial response for an autocomplete interaction.<h6 id=parameters>Parameters</h6><ul><li><strong>interaction</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../interactions/base_interactions.html#PartialInteraction>hikari.interactions.base_interactions.PartialInteraction</a>]): Object or ID of the interaction this response is for.<li><strong>token</strong> (str): The command interaction's token.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>choices</strong> (typing.Sequence[commands.CommandChoice]): The autocomplete choices themselves.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the interaction is not found or if the interaction's initial response has already been created.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.create_context_menu_command><div class="attr function"><a class=headerlink href=#RESTClient.create_context_menu_command>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>create_context_menu_command</span><span class=signature>(<br>   self,<br>   application: Union[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   type: Literal[&LTCommandType.USER: 2>, &LTCommandType.MESSAGE: 3>, 2, 3],<br>   name: str,<br>   *,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   default_permission: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../commands.html#ContextMenuCommand>hikari.commands.ContextMenuCommand</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_context_menu_command</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=nb>type</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Literal</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandType</span><span class=o>.</span><span class=n>USER</span><span class=p>,</span> <span class=n>commands</span><span class=o>.</span><span class=n>CommandType</span><span class=o>.</span><span class=n>MESSAGE</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>default_permission</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>commands</span><span class=o>.</span><span class=n>ContextMenuCommand</span><span class=p>:</span>
        <span class=sa>r</span><span class=sd>"""Create an application command.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to create a command for.</span>
<span class=sd>        name : str</span>
<span class=sd>            The command's name. This should match the regex `^[\w-]{1,32}$` in</span>
<span class=sd>            Unicode mode and be lowercase.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or ID of the specific guild this should be made for.</span>
<span class=sd>            If left as `hikari.undefined.UNDEFINED` then this call will create</span>
<span class=sd>            a global command rather than a guild specific one.</span>
<span class=sd>        default_permission : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            Whether this command should be enabled by default (without any</span>
<span class=sd>            permissions) when added to a guild.</span>

<span class=sd>            Defaults to `True`.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.commands.ContextMenuCommand</span>
<span class=sd>            Object of the created command.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application isn't found.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Create an application command.<h6 id=parameters>Parameters</h6><ul><li><strong>application</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>]): Object or ID of the application to create a command for.<li><strong>name</strong> (str): The command's name. This should match the regex <code>^[\w-]{1,32}$</code> in Unicode mode and be lowercase.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>guild</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): Object or ID of the specific guild this should be made for. If left as <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code> then this call will create a global command rather than a guild specific one.<li><p><strong>default_permission</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): Whether this command should be enabled by default (without any permissions) when added to a guild.</p> <p>Defaults to <code>True</code>.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../commands.html#ContextMenuCommand>hikari.commands.ContextMenuCommand</a></strong>: Object of the created command.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you cannot access the provided application's commands.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the provided application isn't found.<li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.create_dm_channel><div class="attr function"><a class=headerlink href=#RESTClient.create_dm_channel>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>create_dm_channel</span><span class=signature>(<br>   self,<br>   user: Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   /<br>) -> <a href=../channels.html#DMChannel>hikari.channels.DMChannel</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_dm_channel</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span> <span class=o>/</span><span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>DMChannel</span><span class=p>:</span>
        <span class=sd>"""Create a DM channel with a user.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to create the DM channel with. This may be the</span>
<span class=sd>            object or the ID of an existing user.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.DMChannel</span>
<span class=sd>            The created DM channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If the user is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Create a DM channel with a user.<h6 id=parameters>Parameters</h6><ul><li><strong>user</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>]): The user to create the DM channel with. This may be the object or the ID of an existing user.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../channels.html#DMChannel>hikari.channels.DMChannel</a></strong>: The created DM channel.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If the user is not found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.create_emoji><div class="attr function"><a class=headerlink href=#RESTClient.create_emoji>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>create_emoji</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   name: str,<br>   image: Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO],<br>   *,<br>   roles: Union[Sequence[Union[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../emojis.html#KnownCustomEmoji>hikari.emojis.KnownCustomEmoji</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_emoji</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>image</span><span class=p>:</span> <span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>roles</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>emojis</span><span class=o>.</span><span class=n>KnownCustomEmoji</span><span class=p>:</span>
        <span class=sd>"""Create an emoji in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the emoji on. This can be a</span>
<span class=sd>            guild object or the ID of an existing guild.</span>
<span class=sd>        name : str</span>
<span class=sd>            The name for the emoji.</span>
<span class=sd>        image : hikari.files.Resourceish</span>
<span class=sd>            The 128x128 image for the emoji. Maximum upload size is 256kb.</span>
<span class=sd>            This can be a still or an animated image.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole]]</span>
<span class=sd>            If provided, a collection of the roles that will be able to</span>
<span class=sd>            use this emoji. This can be a `hikari.guilds.PartialRole` or</span>
<span class=sd>            the ID of an existing role.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.emojis.KnownCustomEmoji</span>
<span class=sd>            The created emoji.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value or</span>
<span class=sd>            if there are no more spaces for the type of emoji in the guild.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing `MANAGE_EMOJIS_AND_STICKERS` in the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Create an emoji in a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to create the emoji on. This can be a guild object or the ID of an existing guild.<li><strong>name</strong> (str): The name for the emoji.<li><strong>image</strong> (<a href=../files.html#Resourceish>hikari.files.Resourceish</a>): The 128x128 image for the emoji. Maximum upload size is 256kb. This can be a still or an animated image.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>roles</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishSequence>hikari.snowflakes.SnowflakeishSequence</a>[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>]]): If provided, a collection of the roles that will be able to use this emoji. This can be a <code><a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a></code> or the ID of an existing role.<li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../emojis.html#KnownCustomEmoji>hikari.emojis.KnownCustomEmoji</a></strong>: The created emoji.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value or if there are no more spaces for the type of emoji in the guild.<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing <code>MANAGE_EMOJIS_AND_STICKERS</code> in the server.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.create_guild_category><div class="attr function"><a class=headerlink href=#RESTClient.create_guild_category>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>create_guild_category</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   name: str,<br>   *,<br>   position: Union[int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   permission_overwrites: Union[Sequence[<a href=../channels.html#PermissionOverwrite>hikari.channels.PermissionOverwrite</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../channels.html#GuildCategory>hikari.channels.GuildCategory</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_guild_category</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>position</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permission_overwrites</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>GuildCategory</span><span class=p>:</span>
        <span class=sd>"""Create a category in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the channel in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        name : str</span>
<span class=sd>            The channels name. Must be between 2 and 1000 characters.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        position : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the position of the category.</span>
<span class=sd>        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]</span>
<span class=sd>            If provided, the permission overwrites for the category.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.GuildCategory</span>
<span class=sd>            The created category.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Create a category in a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to create the channel in. This may be the object or the ID of an existing guild.<li><strong>name</strong> (str): The channels name. Must be between 2 and 1000 characters.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>position</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[int]): If provided, the position of the category.<li><strong>permission_overwrites</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Sequence[<a href=../channels.html#PermissionOverwrite>hikari.channels.PermissionOverwrite</a>]]): If provided, the permission overwrites for the category.<li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../channels.html#GuildCategory>hikari.channels.GuildCategory</a></strong>: The created category.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_CHANNEL</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.create_guild_from_template><div class="attr function"><a class=headerlink href=#RESTClient.create_guild_from_template>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>create_guild_from_template</span><span class=signature>(<br>   self,<br>   template: Union[str, <a href=../templates.html#Template>hikari.templates.Template</a>],<br>   name: str,<br>   *,<br>   icon: Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../guilds.html#RESTGuild>hikari.guilds.RESTGuild</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_guild_from_template</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>template</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>icon</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>RESTGuild</span><span class=p>:</span>
        <span class=sd>"""Make a guild from a template.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This endpoint can only be used by bots in less than 10 guilds.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        template : typing.Union[str, hikari.templates.Template]</span>
<span class=sd>            The object or string code of the template to create a guild based on.</span>
<span class=sd>        name : str</span>
<span class=sd>            The new guilds name.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        icon : hikari.undefined.UndefinedOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the guild icon to set. Must be a 1024x1024 image or can</span>
<span class=sd>            be an animated gif when the guild has the `ANIMATED_ICON` feature.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.RESTGuild</span>
<span class=sd>            Object of the created guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value or if you</span>
<span class=sd>            call this as a bot that's in more than 10 guilds.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Make a guild from a template.<p><em>Note:</em> This endpoint can only be used by bots in less than 10 guilds.<h6 id=parameters>Parameters</h6><ul><li><strong>template</strong> (typing.Union[str, <a href=../templates.html#Template>hikari.templates.Template</a>]): The object or string code of the template to create a guild based on.<li><strong>name</strong> (str): The new guilds name.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>icon</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../files.html#Resourceish>hikari.files.Resourceish</a>]): If provided, the guild icon to set. Must be a 1024x1024 image or can be an animated gif when the guild has the <code>ANIMATED_ICON</code> feature.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../guilds.html#RESTGuild>hikari.guilds.RESTGuild</a></strong>: Object of the created guild.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value or if you call this as a bot that's in more than 10 guilds.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.create_guild_news_channel><div class="attr function"><a class=headerlink href=#RESTClient.create_guild_news_channel>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>create_guild_news_channel</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   name: str,<br>   *,<br>   position: Union[int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   topic: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   nsfw: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   rate_limit_per_user: Union[int, float, datetime.timedelta, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   permission_overwrites: Union[Sequence[<a href=../channels.html#PermissionOverwrite>hikari.channels.PermissionOverwrite</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   category: Union[<a href=../channels.html#GuildCategory>hikari.channels.GuildCategory</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../channels.html#GuildNewsChannel>hikari.channels.GuildNewsChannel</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_guild_news_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>position</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>topic</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>nsfw</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>rate_limit_per_user</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>time</span><span class=o>.</span><span class=n>Intervalish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permission_overwrites</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>category</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildCategory</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>GuildNewsChannel</span><span class=p>:</span>
        <span class=sd>"""Create a news channel in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the channel in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        name : str</span>
<span class=sd>            The channels name. Must be between 2 and 1000 characters.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        position : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the position of the channel (relative to the</span>
<span class=sd>            category, if any).</span>
<span class=sd>        topic : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the channels topic. Maximum 1024 characters.</span>
<span class=sd>        nsfw : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to mark the channel as NSFW.</span>
<span class=sd>        rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]</span>
<span class=sd>            If provided, the amount of seconds a user has to wait</span>
<span class=sd>            before being able to send another message in the channel.</span>
<span class=sd>            Maximum 21600 seconds.</span>
<span class=sd>        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]</span>
<span class=sd>            If provided, the permission overwrites for the channel.</span>
<span class=sd>        category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]</span>
<span class=sd>            The category to create the channel under. This may be the</span>
<span class=sd>            object or the ID of an existing category.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.GuildNewsChannel</span>
<span class=sd>            The created channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Create a news channel in a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to create the channel in. This may be the object or the ID of an existing guild.<li><strong>name</strong> (str): The channels name. Must be between 2 and 1000 characters.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>position</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[int]): If provided, the position of the channel (relative to the category, if any).<li><strong>topic</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the channels topic. Maximum 1024 characters.<li><strong>nsfw</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, whether to mark the channel as NSFW.<li><strong>rate_limit_per_user</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../internal/time.html#Intervalish>hikari.internal.time.Intervalish</a>]): If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.<li><strong>permission_overwrites</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Sequence[<a href=../channels.html#PermissionOverwrite>hikari.channels.PermissionOverwrite</a>]]): If provided, the permission overwrites for the channel.<li><strong>category</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildCategory>hikari.channels.GuildCategory</a>]]): The category to create the channel under. This may be the object or the ID of an existing category.<li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../channels.html#GuildNewsChannel>hikari.channels.GuildNewsChannel</a></strong>: The created channel.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_CHANNEL</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.create_guild_stage_channel><div class="attr function"><a class=headerlink href=#RESTClient.create_guild_stage_channel>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>create_guild_stage_channel</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   name: str,<br>   *,<br>   position: Union[int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   user_limit: Union[int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   bitrate: Union[int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   permission_overwrites: Union[Sequence[<a href=../channels.html#PermissionOverwrite>hikari.channels.PermissionOverwrite</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   region: Union[<a href=../voices.html#VoiceRegion>hikari.voices.VoiceRegion</a>, str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   category: Union[<a href=../channels.html#GuildCategory>hikari.channels.GuildCategory</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../channels.html#GuildStageChannel>hikari.channels.GuildStageChannel</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_guild_stage_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>position</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_limit</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>bitrate</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permission_overwrites</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>region</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>voices</span><span class=o>.</span><span class=n>VoiceRegion</span><span class=p>,</span> <span class=nb>str</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>category</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildCategory</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>GuildStageChannel</span><span class=p>:</span>
        <span class=sd>"""Create a stage channel in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the channel in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        name : str</span>
<span class=sd>            The channel's name. Must be between 2 and 1000 characters.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        position : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the position of the channel (relative to the</span>
<span class=sd>            category, if any).</span>
<span class=sd>        user_limit : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the maximum users in the channel at once.</span>
<span class=sd>            Must be between 0 and 99 with 0 meaning no limit.</span>
<span class=sd>        bitrate : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the bitrate for the channel. Must be</span>
<span class=sd>            between 8000 and 96000 or 8000 and 128000 for VIP</span>
<span class=sd>            servers.</span>
<span class=sd>        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]</span>
<span class=sd>            If provided, the permission overwrites for the channel.</span>
<span class=sd>        region : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, str]]</span>
<span class=sd>            If provided, the voice region to for this channel. Passing</span>
<span class=sd>            `None` here will set it to "auto" mode where the used</span>
<span class=sd>            region will be decided based on the first person who connects to it</span>
<span class=sd>            when it's empty.</span>
<span class=sd>        category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]</span>
<span class=sd>            The category to create the channel under. This may be the</span>
<span class=sd>            object or the ID of an existing category.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.GuildStageChannel</span>
<span class=sd>            The created channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Create a stage channel in a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to create the channel in. This may be the object or the ID of an existing guild.<li><strong>name</strong> (str): The channel's name. Must be between 2 and 1000 characters.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>position</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[int]): If provided, the position of the channel (relative to the category, if any).<li><strong>user_limit</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[int]): If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.<li><strong>bitrate</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[int]): If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.<li><strong>permission_overwrites</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Sequence[<a href=../channels.html#PermissionOverwrite>hikari.channels.PermissionOverwrite</a>]]): If provided, the permission overwrites for the channel.<li><strong>region</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Union[<a href=../voices.html#VoiceRegion>hikari.voices.VoiceRegion</a>, str]]): If provided, the voice region to for this channel. Passing <code>None</code> here will set it to "auto" mode where the used region will be decided based on the first person who connects to it when it's empty.<li><strong>category</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildCategory>hikari.channels.GuildCategory</a>]]): The category to create the channel under. This may be the object or the ID of an existing category.<li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../channels.html#GuildStageChannel>hikari.channels.GuildStageChannel</a></strong>: The created channel.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_CHANNEL</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.create_guild_text_channel><div class="attr function"><a class=headerlink href=#RESTClient.create_guild_text_channel>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>create_guild_text_channel</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   name: str,<br>   *,<br>   position: Union[int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   topic: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   nsfw: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   rate_limit_per_user: Union[int, float, datetime.timedelta, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   permission_overwrites: Union[Sequence[<a href=../channels.html#PermissionOverwrite>hikari.channels.PermissionOverwrite</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   category: Union[<a href=../channels.html#GuildCategory>hikari.channels.GuildCategory</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../channels.html#GuildTextChannel>hikari.channels.GuildTextChannel</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_guild_text_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>position</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>topic</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>nsfw</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>rate_limit_per_user</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>time</span><span class=o>.</span><span class=n>Intervalish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permission_overwrites</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>category</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildCategory</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>GuildTextChannel</span><span class=p>:</span>
        <span class=sd>"""Create a text channel in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the channel in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        name : str</span>
<span class=sd>            The channels name. Must be between 2 and 1000 characters.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        position : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the position of the channel (relative to the</span>
<span class=sd>            category, if any).</span>
<span class=sd>        topic : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the channels topic. Maximum 1024 characters.</span>
<span class=sd>        nsfw : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to mark the channel as NSFW.</span>
<span class=sd>        rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]</span>
<span class=sd>            If provided, the amount of seconds a user has to wait</span>
<span class=sd>            before being able to send another message in the channel.</span>
<span class=sd>            Maximum 21600 seconds.</span>
<span class=sd>        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]</span>
<span class=sd>            If provided, the permission overwrites for the channel.</span>
<span class=sd>        category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]</span>
<span class=sd>            The category to create the channel under. This may be the</span>
<span class=sd>            object or the ID of an existing category.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.GuildTextChannel</span>
<span class=sd>            The created channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Create a text channel in a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to create the channel in. This may be the object or the ID of an existing guild.<li><strong>name</strong> (str): The channels name. Must be between 2 and 1000 characters.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>position</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[int]): If provided, the position of the channel (relative to the category, if any).<li><strong>topic</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the channels topic. Maximum 1024 characters.<li><strong>nsfw</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, whether to mark the channel as NSFW.<li><strong>rate_limit_per_user</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../internal/time.html#Intervalish>hikari.internal.time.Intervalish</a>]): If provided, the amount of seconds a user has to wait before being able to send another message in the channel. Maximum 21600 seconds.<li><strong>permission_overwrites</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Sequence[<a href=../channels.html#PermissionOverwrite>hikari.channels.PermissionOverwrite</a>]]): If provided, the permission overwrites for the channel.<li><strong>category</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildCategory>hikari.channels.GuildCategory</a>]]): The category to create the channel under. This may be the object or the ID of an existing category.<li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../channels.html#GuildTextChannel>hikari.channels.GuildTextChannel</a></strong>: The created channel.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_CHANNEL</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.create_guild_voice_channel><div class="attr function"><a class=headerlink href=#RESTClient.create_guild_voice_channel>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>create_guild_voice_channel</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   name: str,<br>   *,<br>   position: Union[int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   user_limit: Union[int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   bitrate: Union[int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   video_quality_mode: Union[<a href=../channels.html#VideoQualityMode>hikari.channels.VideoQualityMode</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   permission_overwrites: Union[Sequence[<a href=../channels.html#PermissionOverwrite>hikari.channels.PermissionOverwrite</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   region: Union[<a href=../voices.html#VoiceRegion>hikari.voices.VoiceRegion</a>, str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   category: Union[<a href=../channels.html#GuildCategory>hikari.channels.GuildCategory</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../channels.html#GuildVoiceChannel>hikari.channels.GuildVoiceChannel</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_guild_voice_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>position</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_limit</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>bitrate</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>video_quality_mode</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>VideoQualityMode</span><span class=p>,</span> <span class=nb>int</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permission_overwrites</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>region</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>voices</span><span class=o>.</span><span class=n>VoiceRegion</span><span class=p>,</span> <span class=nb>str</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>category</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildCategory</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>GuildVoiceChannel</span><span class=p>:</span>
        <span class=sd>"""Create a voice channel in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the channel in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        name : str</span>
<span class=sd>            The channels name. Must be between 2 and 1000 characters.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        position : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the position of the channel (relative to the</span>
<span class=sd>            category, if any).</span>
<span class=sd>        user_limit : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the maximum users in the channel at once.</span>
<span class=sd>            Must be between 0 and 99 with 0 meaning no limit.</span>
<span class=sd>        bitrate : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the bitrate for the channel. Must be</span>
<span class=sd>            between 8000 and 96000 or 8000 and 128000 for VIP</span>
<span class=sd>            servers.</span>
<span class=sd>        video_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, int]]</span>
<span class=sd>            If provided, the new video quality mode for the channel.</span>
<span class=sd>        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]</span>
<span class=sd>            If provided, the permission overwrites for the channel.</span>
<span class=sd>        region : hikari.undefined.UndefinedOr[typing.Union[hikari.voices.VoiceRegion, str]]</span>
<span class=sd>            If provided, the voice region to for this channel. Passing</span>
<span class=sd>            `None` here will set it to "auto" mode where the used</span>
<span class=sd>            region will be decided based on the first person who connects to it</span>
<span class=sd>            when it's empty.</span>
<span class=sd>        category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]</span>
<span class=sd>            The category to create the channel under. This may be the</span>
<span class=sd>            object or the ID of an existing category.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.GuildVoiceChannel</span>
<span class=sd>            The created channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Create a voice channel in a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to create the channel in. This may be the object or the ID of an existing guild.<li><strong>name</strong> (str): The channels name. Must be between 2 and 1000 characters.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>position</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[int]): If provided, the position of the channel (relative to the category, if any).<li><strong>user_limit</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[int]): If provided, the maximum users in the channel at once. Must be between 0 and 99 with 0 meaning no limit.<li><strong>bitrate</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[int]): If provided, the bitrate for the channel. Must be between 8000 and 96000 or 8000 and 128000 for VIP servers.<li><strong>video_quality_mode</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Union[<a href=../channels.html#VideoQualityMode>hikari.channels.VideoQualityMode</a>, int]]): If provided, the new video quality mode for the channel.<li><strong>permission_overwrites</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Sequence[<a href=../channels.html#PermissionOverwrite>hikari.channels.PermissionOverwrite</a>]]): If provided, the permission overwrites for the channel.<li><strong>region</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Union[<a href=../voices.html#VoiceRegion>hikari.voices.VoiceRegion</a>, str]]): If provided, the voice region to for this channel. Passing <code>None</code> here will set it to "auto" mode where the used region will be decided based on the first person who connects to it when it's empty.<li><strong>category</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildCategory>hikari.channels.GuildCategory</a>]]): The category to create the channel under. This may be the object or the ID of an existing category.<li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../channels.html#GuildVoiceChannel>hikari.channels.GuildVoiceChannel</a></strong>: The created channel.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_CHANNEL</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.create_interaction_response><div class="attr function"><a class=headerlink href=#RESTClient.create_interaction_response>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>create_interaction_response</span><span class=signature>(<br>   self,<br>   interaction: Union[<a href=../interactions/base_interactions.html#PartialInteraction>hikari.interactions.base_interactions.PartialInteraction</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   token: str,<br>   response_type: Union[int, <a href=../interactions/base_interactions.html#ResponseType>hikari.interactions.base_interactions.ResponseType</a>],<br>   content: Union[Any, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   *,<br>   flags: Union[int, <a href=../messages.html#MessageFlag>hikari.messages.MessageFlag</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   tts: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   attachment: Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   attachments: Union[Sequence[Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO]], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   component: Union[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   components: Union[Sequence[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   embed: Union[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   embeds: Union[Sequence[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   mentions_everyone: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   user_mentions: Union[Sequence[Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]], bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   role_mentions: Union[Sequence[Union[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]], bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_interaction_response</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>interaction</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>base_interactions</span><span class=o>.</span><span class=n>PartialInteraction</span><span class=p>],</span>
        <span class=n>token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>response_type</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=n>base_interactions</span><span class=o>.</span><span class=n>ResponseType</span><span class=p>],</span>
        <span class=n>content</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Any</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>flags</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=n>messages_</span><span class=o>.</span><span class=n>MessageFlag</span><span class=p>,</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedType</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>tts</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachment</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachments</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>component</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>components</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embed</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embeds</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mentions_everyone</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>role_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Create the initial response for a interaction.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            Calling this with an interaction which already has an initial</span>
<span class=sd>            response will result in this raising a `hikari.errors.NotFoundError`.</span>
<span class=sd>            This includes if the REST interaction server has already responded</span>
<span class=sd>            to the request.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        interaction : hikari.snowflakes.SnowflakeishOr[hikari.interactions.base_interactions.PartialInteraction]</span>
<span class=sd>            Object or ID of the interaction this response is for.</span>
<span class=sd>        token : str</span>
<span class=sd>            The command interaction's token.</span>
<span class=sd>        response_type : typing.Union[int, hikari.interactions.base_interactions.ResponseType]</span>
<span class=sd>            The type of interaction response this is.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        content : hikari.undefined.UndefinedOr[typing.Any]</span>
<span class=sd>            If provided, the message contents. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then nothing will be sent</span>
<span class=sd>            in the content. Any other value here will be cast to a</span>
<span class=sd>            `str`.</span>

<span class=sd>            If this is a `hikari.embeds.Embed` and no `embed` nor</span>
<span class=sd>            no `embeds` kwarg is provided, then this will instead</span>
<span class=sd>            update the embed. This allows for simpler syntax when</span>
<span class=sd>            sending an embed alone.</span>
<span class=sd>        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish],</span>
<span class=sd>            If provided, the message attachment. This can be a resource,</span>
<span class=sd>            or string of a path on your computer or a URL.</span>
<span class=sd>        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]],</span>
<span class=sd>            If provided, the message attachments. These can be resources, or</span>
<span class=sd>            strings consisting of paths on your computer or URLs.</span>
<span class=sd>        component : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder]</span>
<span class=sd>            If provided, builder object of the component to include in this message.</span>
<span class=sd>        components : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]</span>
<span class=sd>            If provided, a sequence of the component builder objects to include</span>
<span class=sd>            in this message.</span>
<span class=sd>        embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed]</span>
<span class=sd>            If provided, the message embed.</span>
<span class=sd>        embeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed]]</span>
<span class=sd>            If provided, the message embeds.</span>
<span class=sd>        flags : typing.Union[int, hikari.messages.MessageFlag, hikari.undefined.UndefinedType]</span>
<span class=sd>            If provided, the message flags this response should have.</span>

<span class=sd>            As of writing the only message flag which can be set here is</span>
<span class=sd>            `hikari.messages.MessageFlag.EPHEMERAL`.</span>
<span class=sd>        tts : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the message will be read out by a screen</span>
<span class=sd>            reader using Discord's TTS (text-to-speech) system.</span>
<span class=sd>        mentions_everyone : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the message should parse @everyone/@here</span>
<span class=sd>            mentions.</span>
<span class=sd>        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], bool]]</span>
<span class=sd>            If provided, and `True`, all user mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all user mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.users.PartialUser` derivatives to enforce mentioning</span>
<span class=sd>            specific users.</span>
<span class=sd>        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], bool]]</span>
<span class=sd>            If provided, and `True`, all role mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all role mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.guilds.PartialRole` derivatives to enforce mentioning</span>
<span class=sd>            specific roles.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        ValueError</span>
<span class=sd>            If more than 100 unique objects/entities are passed for</span>
<span class=sd>            `role_mentions` or `user_mentions`.</span>
<span class=sd>        TypeError</span>
<span class=sd>            If both `embed` and `embeds` are specified.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            This may be raised in several discrete situations, such as messages</span>
<span class=sd>            being empty with no embeds; messages with more than 2000 characters</span>
<span class=sd>            in them, embeds that exceed one of the many embed limits</span>
<span class=sd>            invalid image URLs in embeds.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the interaction is not found or if the interaction's initial</span>
<span class=sd>            response has already been created.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>
</pre></div></details><div class=docstring><p>Create the initial response for a interaction.<p><em>Warning:</em> Calling this with an interaction which already has an initial response will result in this raising a <code><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></code>. This includes if the REST interaction server has already responded to the request.<h6 id=parameters>Parameters</h6><ul><li><strong>interaction</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../interactions/base_interactions.html#PartialInteraction>hikari.interactions.base_interactions.PartialInteraction</a>]): Object or ID of the interaction this response is for.<li><strong>token</strong> (str): The command interaction's token.<li><strong>response_type</strong> (typing.Union[int, <a href=../interactions/base_interactions.html#ResponseType>hikari.interactions.base_interactions.ResponseType</a>]): The type of interaction response this is.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><p><strong>content</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Any]): If provided, the message contents. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, then nothing will be sent in the content. Any other value here will be cast to a <code>str</code>.</p> <p>If this is a <code><a href=../embeds.html#Embed>hikari.embeds.Embed</a></code> and no <code>embed</code> nor no <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.<li><strong>attachment</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../files.html#Resourceish>hikari.files.Resourceish</a>],): If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.<li><strong>attachments</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Sequence[<a href=../files.html#Resourceish>hikari.files.Resourceish</a>]],): If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.<li><strong>component</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>]): If provided, builder object of the component to include in this message.<li><strong>components</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Sequence[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>]]): If provided, a sequence of the component builder objects to include in this message.<li><strong>embed</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>]): If provided, the message embed.<li><strong>embeds</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Sequence[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>]]): If provided, the message embeds.<li><p><strong>flags</strong> (typing.Union[int, <a href=../messages.html#MessageFlag>hikari.messages.MessageFlag</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>]): If provided, the message flags this response should have.</p> <p>As of writing the only message flag which can be set here is <code><a href=../messages.html#MessageFlag.EPHEMERAL>hikari.messages.MessageFlag.EPHEMERAL</a></code>.<li><strong>tts</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.<li><strong>mentions_everyone</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, whether the message should parse @everyone/@here mentions.<li><strong>user_mentions</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Union[<a href=../snowflakes.html#SnowflakeishSequence>hikari.snowflakes.SnowflakeishSequence</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>], bool]]): If provided, and <code>True</code>, all user mentions will be detected. If provided, and <code>False</code>, all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of <code><a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a></code>, or <code><a href=../users.html#PartialUser>hikari.users.PartialUser</a></code> derivatives to enforce mentioning specific users.<li><strong>role_mentions</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Union[<a href=../snowflakes.html#SnowflakeishSequence>hikari.snowflakes.SnowflakeishSequence</a>[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>], bool]]): If provided, and <code>True</code>, all role mentions will be detected. If provided, and <code>False</code>, all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of <code><a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a></code>, or <code><a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a></code> derivatives to enforce mentioning specific roles.</ul><h6 id=raises>Raises</h6><ul><li><strong>ValueError</strong>: If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code>.<li><strong>TypeError</strong>: If both <code>embed</code> and <code>embeds</code> are specified.<li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits invalid image URLs in embeds.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the interaction is not found or if the interaction's initial response has already been created.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.create_invite><div class="attr function"><a class=headerlink href=#RESTClient.create_invite>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>create_invite</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#GuildChannel>hikari.channels.GuildChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   max_age: Union[int, float, datetime.timedelta, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   max_uses: Union[int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   temporary: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   unique: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   target_type: Union[<a href=../invites.html#TargetType>hikari.invites.TargetType</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   target_user: Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   target_application: Union[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../invites.html#InviteWithMetadata>hikari.invites.InviteWithMetadata</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_invite</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>max_age</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>time</span><span class=o>.</span><span class=n>Intervalish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>max_uses</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>temporary</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>unique</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>target_type</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>invites</span><span class=o>.</span><span class=n>TargetType</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>target_user</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>target_application</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>invites</span><span class=o>.</span><span class=n>InviteWithMetadata</span><span class=p>:</span>
        <span class=sd>"""Create an invite to the given guild channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]</span>
<span class=sd>            The channel to create a invite for. This may be the object</span>
<span class=sd>            or the ID of an existing channel.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        max_age : hikari.undefined.UndefinedOr[typing.Union[datetime.timedelta, float, int]]</span>
<span class=sd>            If provided, the duration of the invite before expiry.</span>
<span class=sd>        max_uses : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the max uses the invite can have.</span>
<span class=sd>        temporary : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the invite only grants temporary membership.</span>
<span class=sd>        unique : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the invite should be unique.</span>
<span class=sd>        target_type : hikari.undefined.UndefinedOr[hikari.invites.TargetType]</span>
<span class=sd>            If provided, the target type of this invite.</span>
<span class=sd>        target_user : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]]</span>
<span class=sd>            If provided, the target user id for this invite. This may be the</span>
<span class=sd>            object or the ID of an existing user.</span>

<span class=sd>            .. note::</span>
<span class=sd>                This is required if `target_type` is `STREAM` and the targeted</span>
<span class=sd>                user must be streaming into the channel.</span>
<span class=sd>        target_application : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]]</span>
<span class=sd>            If provided, the target application id for this invite. This may be</span>
<span class=sd>            the object or the ID of an existing application.</span>

<span class=sd>            .. note::</span>
<span class=sd>                This is required if `target_type` is `EMBEDDED_APPLICATION` and</span>
<span class=sd>                the targeted application must have the `EMBEDDED` flag.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.invites.InviteWithMetadata</span>
<span class=sd>            The invite to the given guild channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNELS` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found, or if the target user does not exist,</span>
<span class=sd>            if provided.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>
</pre></div></details><div class=docstring><p>Create an invite to the given guild channel.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildChannel>hikari.channels.GuildChannel</a>]): The channel to create a invite for. This may be the object or the ID of an existing channel.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>max_age</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Union[datetime.timedelta, float, int]]): If provided, the duration of the invite before expiry.<li><strong>max_uses</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[int]): If provided, the max uses the invite can have.<li><strong>temporary</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, whether the invite only grants temporary membership.<li><strong>unique</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, whether the invite should be unique.<li><strong>target_type</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../invites.html#TargetType>hikari.invites.TargetType</a>]): If provided, the target type of this invite.<li><p><strong>target_user</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>]]): If provided, the target user id for this invite. This may be the object or the ID of an existing user.</p> <p><em>Note:</em> This is required if <code>target_type</code> is <code>STREAM</code> and the targeted user must be streaming into the channel.<li><p><strong>target_application</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>]]): If provided, the target application id for this invite. This may be the object or the ID of an existing application.</p> <p><em>Note:</em> This is required if <code>target_type</code> is <code>EMBEDDED_APPLICATION</code> and the targeted application must have the <code>EMBEDDED</code> flag.<li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../invites.html#InviteWithMetadata>hikari.invites.InviteWithMetadata</a></strong>: The invite to the given guild channel.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_CHANNELS</code> permission.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel is not found, or if the target user does not exist, if provided.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.create_message><div class="attr function"><a class=headerlink href=#RESTClient.create_message>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>create_message</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   content: Union[Any, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   *,<br>   attachment: Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   attachments: Union[Sequence[Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO]], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   component: Union[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   components: Union[Sequence[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   embed: Union[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   embeds: Union[Sequence[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   tts: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   nonce: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reply: Union[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   mentions_everyone: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   mentions_reply: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   user_mentions: Union[Sequence[Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]], bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   role_mentions: Union[Sequence[Union[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]], bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../messages.html#Message>hikari.messages.Message</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>content</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Any</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>attachment</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachments</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>component</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>components</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embed</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embeds</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>tts</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>nonce</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reply</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mentions_everyone</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mentions_reply</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>role_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Create a message in the given channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to create the message in.</span>
<span class=sd>        content : hikari.undefined.UndefinedOr[typing.Any]</span>
<span class=sd>            If provided, the message contents. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then nothing will be sent</span>
<span class=sd>            in the content. Any other value here will be cast to a</span>
<span class=sd>            `str`.</span>

<span class=sd>            If this is a `hikari.embeds.Embed` and no `embed` nor `embeds` kwarg</span>
<span class=sd>            is provided, then this will instead update the embed. This allows</span>
<span class=sd>            for simpler syntax when sending an embed alone.</span>

<span class=sd>            Likewise, if this is a `hikari.files.Resource`, then the</span>
<span class=sd>            content is instead treated as an attachment if no `attachment` and</span>
<span class=sd>            no `attachments` kwargs are provided.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish],</span>
<span class=sd>            If provided, the message attachment. This can be a resource,</span>
<span class=sd>            or string of a path on your computer or a URL.</span>

<span class=sd>            Attachments can be passed as many different things, to aid in</span>
<span class=sd>            convenience.</span>

<span class=sd>            - If a `pathlib.PurePath` or `str` to a valid URL, the</span>
<span class=sd>                resource at the given URL will be streamed to Discord when</span>
<span class=sd>                sending the message. Subclasses of</span>
<span class=sd>                `hikari.files.WebResource` such as</span>
<span class=sd>                `hikari.files.URL`,</span>
<span class=sd>                `hikari.messages.Attachment`,</span>
<span class=sd>                `hikari.emojis.Emoji`,</span>
<span class=sd>                `EmbedResource`, etc will also be uploaded this way.</span>
<span class=sd>                This will use bit-inception, so only a small percentage of the</span>
<span class=sd>                resource will remain in memory at any one time, thus aiding in</span>
<span class=sd>                scalability.</span>
<span class=sd>            - If a `hikari.files.Bytes` is passed, or a `str`</span>
<span class=sd>                that contains a valid data URI is passed, then this is uploaded</span>
<span class=sd>                with a randomized file name if not provided.</span>
<span class=sd>            - If a `hikari.files.File`, `pathlib.PurePath` or</span>
<span class=sd>                `str` that is an absolute or relative path to a file</span>
<span class=sd>                on your file system is passed, then this resource is uploaded</span>
<span class=sd>                as an attachment using non-blocking code internally and streamed</span>
<span class=sd>                using bit-inception where possible. This depends on the</span>
<span class=sd>                type of `concurrent.futures.Executor` that is being used for</span>
<span class=sd>                the application (default is a thread pool which supports this</span>
<span class=sd>                behaviour).</span>
<span class=sd>        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]],</span>
<span class=sd>            If provided, the message attachments. These can be resources, or</span>
<span class=sd>            strings consisting of paths on your computer or URLs.</span>
<span class=sd>        component : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder]</span>
<span class=sd>            If provided, builder object of the component to include in this message.</span>
<span class=sd>        components : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]</span>
<span class=sd>            If provided, a sequence of the component builder objects to include</span>
<span class=sd>            in this message.</span>
<span class=sd>        embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed]</span>
<span class=sd>            If provided, the message embed.</span>
<span class=sd>        embeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed]]</span>
<span class=sd>            If provided, the message embeds.</span>
<span class=sd>        tts : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the message will be read out by a screen</span>
<span class=sd>            reader using Discord's TTS (text-to-speech) system.</span>
<span class=sd>        nonce : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            An arbitrary identifier to associate with the message. This</span>
<span class=sd>            can be used to identify it later in received events. If provided,</span>
<span class=sd>            this must be less than 32 bytes. If not provided, then</span>
<span class=sd>            a null value is placed on the message instead. All users can</span>
<span class=sd>            see this value.</span>
<span class=sd>        reply : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]]</span>
<span class=sd>            If provided, the message to reply to.</span>
<span class=sd>        mentions_everyone : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the message should parse @everyone/@here</span>
<span class=sd>            mentions.</span>
<span class=sd>        mentions_reply : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to mention the author of the message</span>
<span class=sd>            that is being replied to.</span>

<span class=sd>            This will not do anything if not being used with `reply`.</span>
<span class=sd>        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], bool]]</span>
<span class=sd>            If provided, and `True`, all user mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all user mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.users.PartialUser` derivatives to enforce mentioning</span>
<span class=sd>            specific users.</span>
<span class=sd>        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], bool]]</span>
<span class=sd>            If provided, and `True`, all role mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all role mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.guilds.PartialRole` derivatives to enforce mentioning</span>
<span class=sd>            specific roles.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The created message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        ValueError</span>
<span class=sd>            If more than 100 unique objects/entities are passed for</span>
<span class=sd>            `role_mentions` or `user_mentions` or if both `attachment` and</span>
<span class=sd>            `attachments`, `component` and `components` or `embed` and `embeds`</span>
<span class=sd>            are specified.</span>
<span class=sd>        TypeError</span>
<span class=sd>            If `attachments`, `components` or `embeds` is passed but is not a</span>
<span class=sd>            sequence.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            This may be raised in several discrete situations, such as messages</span>
<span class=sd>            being empty with no attachments or embeds; messages with more than</span>
<span class=sd>            2000 characters in them, embeds that exceed one of the many embed</span>
<span class=sd>            limits; too many attachments; attachments that are too large;</span>
<span class=sd>            invalid image URLs in embeds; if `reply` is not found or not in the</span>
<span class=sd>            same channel as `channel`; too many components.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `SEND_MESSAGES` in the channel or the</span>
<span class=sd>            person you are trying to message has the DM's disabled.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>
</pre></div></details><div class=docstring><p>Create a message in the given channel.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>]): The channel to create the message in.<li><p><strong>content</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Any]): If provided, the message contents. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, then nothing will be sent in the content. Any other value here will be cast to a <code>str</code>.</p> <p>If this is a <code><a href=../embeds.html#Embed>hikari.embeds.Embed</a></code> and no <code>embed</code> nor <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a <code><a href=../files.html#Resource>hikari.files.Resource</a></code>, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><p><strong>attachment</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../files.html#Resourceish>hikari.files.Resourceish</a>],): If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> <p>Attachments can be passed as many different things, to aid in convenience.</p> <ul><li>If a <code>pathlib.PurePath</code> or <code>str</code> to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of <code><a href=../files.html#WebResource>hikari.files.WebResource</a></code> such as <code><a href=../files.html#URL>hikari.files.URL</a></code>, <code><a href=../messages.html#Attachment>hikari.messages.Attachment</a></code>, <code><a href=../emojis.html#Emoji>hikari.emojis.Emoji</a></code>, <code>EmbedResource</code>, etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability.<li>If a <code><a href=../files.html#Bytes>hikari.files.Bytes</a></code> is passed, or a <code>str</code> that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided.<li>If a <code><a href=../files.html#File>hikari.files.File</a></code>, <code>pathlib.PurePath</code> or <code>str</code> that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of <code>concurrent.futures.Executor</code> that is being used for the application (default is a thread pool which supports this behaviour).</ul><li><strong>attachments</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Sequence[<a href=../files.html#Resourceish>hikari.files.Resourceish</a>]],): If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.<li><strong>component</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>]): If provided, builder object of the component to include in this message.<li><strong>components</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Sequence[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>]]): If provided, a sequence of the component builder objects to include in this message.<li><strong>embed</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>]): If provided, the message embed.<li><strong>embeds</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Sequence[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>]]): If provided, the message embeds.<li><strong>tts</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.<li><strong>nonce</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): An arbitrary identifier to associate with the message. This can be used to identify it later in received events. If provided, this must be less than 32 bytes. If not provided, then a null value is placed on the message instead. All users can see this value.<li><strong>reply</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>]]): If provided, the message to reply to.<li><strong>mentions_everyone</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, whether the message should parse @everyone/@here mentions.<li><p><strong>mentions_reply</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, whether to mention the author of the message that is being replied to.</p> <p>This will not do anything if not being used with <code>reply</code>.<li><strong>user_mentions</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Union[<a href=../snowflakes.html#SnowflakeishSequence>hikari.snowflakes.SnowflakeishSequence</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>], bool]]): If provided, and <code>True</code>, all user mentions will be detected. If provided, and <code>False</code>, all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of <code><a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a></code>, or <code><a href=../users.html#PartialUser>hikari.users.PartialUser</a></code> derivatives to enforce mentioning specific users.<li><strong>role_mentions</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Union[<a href=../snowflakes.html#SnowflakeishSequence>hikari.snowflakes.SnowflakeishSequence</a>[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>], bool]]): If provided, and <code>True</code>, all role mentions will be detected. If provided, and <code>False</code>, all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of <code><a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a></code>, or <code><a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a></code> derivatives to enforce mentioning specific roles.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../messages.html#Message>hikari.messages.Message</a></strong>: The created message.</ul><h6 id=raises>Raises</h6><ul><li><strong>ValueError</strong>: If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code> or if both <code>attachment</code> and <code>attachments</code>, <code>component</code> and <code>components</code> or <code>embed</code> and <code>embeds</code> are specified.<li><strong>TypeError</strong>: If <code>attachments</code>, <code>components</code> or <code>embeds</code> is passed but is not a sequence.<li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; if <code>reply</code> is not found or not in the same channel as <code>channel</code>; too many components.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>SEND_MESSAGES</code> in the channel or the person you are trying to message has the DM's disabled.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.create_role><div class="attr function"><a class=headerlink href=#RESTClient.create_role>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>create_role</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   name: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   permissions: Union[<a href=../permissions.html#Permissions>hikari.permissions.Permissions</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   color: Union[<a href=../colors.html#Color>hikari.colors.Color</a>, SupportsInt, Tuple[SupportsInt, SupportsInt, SupportsInt], Tuple[SupportsFloat, SupportsFloat, SupportsFloat], Sequence[SupportsInt], Sequence[SupportsFloat], str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   colour: Union[<a href=../colors.html#Color>hikari.colors.Color</a>, SupportsInt, Tuple[SupportsInt, SupportsInt, SupportsInt], Tuple[SupportsFloat, SupportsFloat, SupportsFloat], Sequence[SupportsInt], Sequence[SupportsFloat], str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   hoist: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   icon: Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   unicode_emoji: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   mentionable: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../guilds.html#Role>hikari.guilds.Role</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_role</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permissions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>permissions_</span><span class=o>.</span><span class=n>Permissions</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>color</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>colors</span><span class=o>.</span><span class=n>Colorish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>colour</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>colors</span><span class=o>.</span><span class=n>Colorish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>hoist</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>icon</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>unicode_emoji</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mentionable</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>Role</span><span class=p>:</span>
        <span class=sd>"""Create a role.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the role in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the name for the role.</span>
<span class=sd>        permissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]</span>
<span class=sd>            The permissions to give the role. This will default to setting</span>
<span class=sd>            NO roles if left to the default value. This is in contrast to</span>
<span class=sd>            default behaviour on Discord where some random permissions will</span>
<span class=sd>            be set by default.</span>
<span class=sd>        color : hikari.undefined.UndefinedOr[hikari.colors.Colorish]</span>
<span class=sd>            If provided, the role's color.</span>
<span class=sd>        colour : hikari.undefined.UndefinedOr[hikari.colors.Colorish]</span>
<span class=sd>            An alias for `color`.</span>
<span class=sd>        hoist : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to hoist the role.</span>
<span class=sd>        icon : hikari.undefined.UndefinedOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the role icon. Must be a 64x64 image under 256kb.</span>
<span class=sd>        unicode_emoji : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the standard emoji to set as the role icon.</span>
<span class=sd>        mentionable : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to make the role mentionable.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.Role</span>
<span class=sd>            The created role.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        TypeError</span>
<span class=sd>            If both `color` and `colour` are specified or if both `icon` and</span>
<span class=sd>            `unicode_emoji` are specified.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_ROLES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Create a role.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to create the role in. This may be the object or the ID of an existing guild.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>name</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the name for the role.<li><strong>permissions</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../permissions.html#Permissions>hikari.permissions.Permissions</a>]): The permissions to give the role. This will default to setting NO roles if left to the default value. This is in contrast to default behaviour on Discord where some random permissions will be set by default.<li><strong>color</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../colors.html#Colorish>hikari.colors.Colorish</a>]): If provided, the role's color.<li><strong>colour</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../colors.html#Colorish>hikari.colors.Colorish</a>]): An alias for <code>color</code>.<li><strong>hoist</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, whether to hoist the role.<li><strong>icon</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../files.html#Resourceish>hikari.files.Resourceish</a>]): If provided, the role icon. Must be a 64x64 image under 256kb.<li><strong>unicode_emoji</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the standard emoji to set as the role icon.<li><strong>mentionable</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, whether to make the role mentionable.<li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../guilds.html#Role>hikari.guilds.Role</a></strong>: The created role.</ul><h6 id=raises>Raises</h6><ul><li><strong>TypeError</strong>: If both <code>color</code> and <code>colour</code> are specified or if both <code>icon</code> and <code>unicode_emoji</code> are specified.<li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_ROLES</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.create_slash_command><div class="attr function"><a class=headerlink href=#RESTClient.create_slash_command>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>create_slash_command</span><span class=signature>(<br>   self,<br>   application: Union[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   name: str,<br>   description: str,<br>   *,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   options: Union[Sequence[<a href=../commands.html#CommandOption>hikari.commands.CommandOption</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   default_permission: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../commands.html#SlashCommand>hikari.commands.SlashCommand</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_slash_command</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>options</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandOption</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>default_permission</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>commands</span><span class=o>.</span><span class=n>SlashCommand</span><span class=p>:</span>
        <span class=sa>r</span><span class=sd>"""Create an application command.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to create a command for.</span>
<span class=sd>        name : str</span>
<span class=sd>            The command's name. This should match the regex `^[\w-]{1,32}$` in</span>
<span class=sd>            Unicode mode and be lowercase.</span>
<span class=sd>        description : str</span>
<span class=sd>            The description to set for the command.</span>
<span class=sd>            This should be inclusively between 1-100 characters in length.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or ID of the specific guild this should be made for.</span>
<span class=sd>            If left as `hikari.undefined.UNDEFINED` then this call will create</span>
<span class=sd>            a global command rather than a guild specific one.</span>
<span class=sd>        options : hikari.undefined.UndefinedOr[typing.Sequence[hikari.commands.CommandOption]]</span>
<span class=sd>            A sequence of up to 10 options for this command.</span>
<span class=sd>        default_permission : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            Whether this command should be enabled by default (without any</span>
<span class=sd>            permissions) when added to a guild.</span>

<span class=sd>            Defaults to `True`.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.commands.SlashCommand</span>
<span class=sd>            Object of the created command.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application isn't found.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Create an application command.<h6 id=parameters>Parameters</h6><ul><li><strong>application</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>]): Object or ID of the application to create a command for.<li><strong>name</strong> (str): The command's name. This should match the regex <code>^[\w-]{1,32}$</code> in Unicode mode and be lowercase.<li><strong>description</strong> (str): The description to set for the command. This should be inclusively between 1-100 characters in length.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>guild</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): Object or ID of the specific guild this should be made for. If left as <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code> then this call will create a global command rather than a guild specific one.<li><strong>options</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Sequence[<a href=../commands.html#CommandOption>hikari.commands.CommandOption</a>]]): A sequence of up to 10 options for this command.<li><p><strong>default_permission</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): Whether this command should be enabled by default (without any permissions) when added to a guild.</p> <p>Defaults to <code>True</code>.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../commands.html#SlashCommand>hikari.commands.SlashCommand</a></strong>: Object of the created command.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you cannot access the provided application's commands.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the provided application isn't found.<li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.create_sticker><div class="attr function"><a class=headerlink href=#RESTClient.create_sticker>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>create_sticker</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   name: str,<br>   tag: str,<br>   image: Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO],<br>   *,<br>   description: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../stickers.html#GuildSticker>hikari.stickers.GuildSticker</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_sticker</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>tag</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>image</span><span class=p>:</span> <span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>stickers</span><span class=o>.</span><span class=n>GuildSticker</span><span class=p>:</span>
        <span class=sd>"""Create a sticker in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create the sticker on. This can be a guild object or the</span>
<span class=sd>            ID of an existing guild.</span>
<span class=sd>        name : str</span>
<span class=sd>            The name for the sticker.</span>
<span class=sd>        tag : str</span>
<span class=sd>            The tag for the sticker.</span>
<span class=sd>        image : hikari.files.Resourceish</span>
<span class=sd>            The 320x320 image for the sticker. Maximum upload size is 500kb.</span>
<span class=sd>            This can be a still or an animated PNG or a Lottie.</span>

<span class=sd>            .. note::</span>
<span class=sd>                Lottie support is only available for verified and partnered</span>
<span class=sd>                servers.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        description: hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the description of the sticker.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.stickers.GuildSticker</span>
<span class=sd>            The created sticker.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value or</span>
<span class=sd>            if there are no more spaces for the sticker in the guild.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing `MANAGE_EMOJIS_AND_STICKERS` in the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Create a sticker in a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to create the sticker on. This can be a guild object or the ID of an existing guild.<li><strong>name</strong> (str): The name for the sticker.<li><strong>tag</strong> (str): The tag for the sticker.<li><p><strong>image</strong> (<a href=../files.html#Resourceish>hikari.files.Resourceish</a>): The 320x320 image for the sticker. Maximum upload size is 500kb. This can be a still or an animated PNG or a Lottie.</p> <p><em>Note:</em> Lottie support is only available for verified and partnered servers.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>description</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the description of the sticker.<li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../stickers.html#GuildSticker>hikari.stickers.GuildSticker</a></strong>: The created sticker.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value or if there are no more spaces for the sticker in the guild.<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing <code>MANAGE_EMOJIS_AND_STICKERS</code> in the server.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.create_template><div class="attr function"><a class=headerlink href=#RESTClient.create_template>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>create_template</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   name: str,<br>   *,<br>   description: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED<br>) -> <a href=../templates.html#Template>hikari.templates.Template</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_template</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>:</span>
        <span class=sd>"""Create a guild template.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to create a template from.</span>
<span class=sd>        name : str</span>
<span class=sd>            The name to use for the created template.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        description : hikari.undefined.UndefinedNoneOr[str]</span>
<span class=sd>            The description to set for the template.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.templates.Template</span>
<span class=sd>            The object of the created template.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found or you are missing the `MANAGE_GUILD`</span>
<span class=sd>            permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Create a guild template.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to create a template from.<li><strong>name</strong> (str): The name to use for the created template.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>description</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[str]): The description to set for the template.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../templates.html#Template>hikari.templates.Template</a></strong>: The object of the created template.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are not part of the guild.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found or you are missing the <code>MANAGE_GUILD</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.create_webhook><div class="attr function"><a class=headerlink href=#RESTClient.create_webhook>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>create_webhook</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#GuildTextChannel>hikari.channels.GuildTextChannel</a>, <a href=../channels.html#GuildNewsChannel>hikari.channels.GuildNewsChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   name: str,<br>   *,<br>   avatar: Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../webhooks.html#IncomingWebhook>hikari.webhooks.IncomingWebhook</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>create_webhook</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>WebhookChannelT</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>avatar</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>webhooks</span><span class=o>.</span><span class=n>IncomingWebhook</span><span class=p>:</span>
        <span class=sd>"""Create webhook in a channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT]</span>
<span class=sd>            The channel where the webhook will be created. This may be</span>
<span class=sd>            the object or the ID of an existing channel.</span>
<span class=sd>        name : str</span>
<span class=sd>            The name for the webhook. This cannot be `clyde`.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        avatar : typing.Optional[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the avatar for the webhook.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.webhooks.IncomingWebhook</span>
<span class=sd>            The created webhook.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If `name` doesn't follow the restrictions enforced by discord.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_WEBHOOKS` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Create webhook in a channel.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#WebhookChannelT>hikari.channels.WebhookChannelT</a>]): The channel where the webhook will be created. This may be the object or the ID of an existing channel.<li><strong>name</strong> (str): The name for the webhook. This cannot be <code>clyde</code>.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>avatar</strong> (typing.Optional[<a href=../files.html#Resourceish>hikari.files.Resourceish</a>]): If provided, the avatar for the webhook.<li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../webhooks.html#IncomingWebhook>hikari.webhooks.IncomingWebhook</a></strong>: The created webhook.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If <code>name</code> doesn't follow the restrictions enforced by discord.<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_WEBHOOKS</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.crosspost_message><div class="attr function"><a class=headerlink href=#RESTClient.crosspost_message>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>crosspost_message</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#GuildNewsChannel>hikari.channels.GuildNewsChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   message: Union[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> <a href=../messages.html#Message>hikari.messages.Message</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>crosspost_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildNewsChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Broadcast an announcement message.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildNewsChannel]</span>
<span class=sd>            The object or ID of the news channel to crosspost a message in.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The object or ID of the message to crosspost.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The message object that was crossposted.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If you tried to crosspost a message that has already been broadcast.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you try to crosspost a message by the current user without the</span>
<span class=sd>            `SEND_MESSAGES` permission for the target news channel or try to</span>
<span class=sd>            crosspost a message by another user without both the `SEND_MESSAGES`</span>
<span class=sd>            and `MANAGE_MESSAGES` permissions for the target channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Broadcast an announcement message.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildNewsChannel>hikari.channels.GuildNewsChannel</a>]): The object or ID of the news channel to crosspost a message in.<li><strong>message</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>]): The object or ID of the message to crosspost.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../messages.html#Message>hikari.messages.Message</a></strong>: The message object that was crossposted.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If you tried to crosspost a message that has already been broadcast.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you try to crosspost a message by the current user without the <code>SEND_MESSAGES</code> permission for the target news channel or try to crosspost a message by another user without both the <code>SEND_MESSAGES</code> and <code>MANAGE_MESSAGES</code> permissions for the target channel.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel or message is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.delete_all_reactions><div class="attr function"><a class=headerlink href=#RESTClient.delete_all_reactions>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>delete_all_reactions</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   message: Union[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_all_reactions</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete all reactions from a message.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel where the message to delete all reactions from is.</span>
<span class=sd>            This may be the object or the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete all reaction from. This may be the</span>
<span class=sd>            object or the ID of an existing message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid unicode emoji is given, or if the given custom emoji</span>
<span class=sd>            does not exist.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_MESSAGES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Delete all reactions from a message.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>]): The channel where the message to delete all reactions from is. This may be the object or the ID of an existing channel.<li><strong>message</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>]): The message to delete all reaction from. This may be the object or the ID of an existing message.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If an invalid unicode emoji is given, or if the given custom emoji does not exist.<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_MESSAGES</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel or message is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.delete_all_reactions_for_emoji><div class="attr function"><a class=headerlink href=#RESTClient.delete_all_reactions_for_emoji>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>delete_all_reactions_for_emoji</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   message: Union[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   emoji: Union[str, <a href=../emojis.html#Emoji>hikari.emojis.Emoji</a>],<br>   emoji_id: Union[<a href=../emojis.html#CustomEmoji>hikari.emojis.CustomEmoji</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_all_reactions_for_emoji</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>emojis</span><span class=o>.</span><span class=n>Emoji</span><span class=p>],</span>
        <span class=n>emoji_id</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete all reactions for a single emoji on a given message.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel where the message to delete the reactions from is.</span>
<span class=sd>            This may be the object or the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete a reactions from. This may be the</span>
<span class=sd>            object or the ID of an existing message.</span>
<span class=sd>        emoji : typing.Union[str, hikari.emojis.Emoji]</span>
<span class=sd>            Object or name of the emoji to remove all the reactions for.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]]</span>
<span class=sd>            ID of the custom emoji to remove all the reactions for.</span>
<span class=sd>            This should only be provided when a custom emoji's name is passed</span>
<span class=sd>            for `emoji`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid unicode emoji is given, or if the given custom emoji</span>
<span class=sd>            does not exist.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_MESSAGES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Delete all reactions for a single emoji on a given message.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>]): The channel where the message to delete the reactions from is. This may be the object or the ID of an existing channel.<li><strong>message</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>]): The message to delete a reactions from. This may be the object or the ID of an existing message.<li><strong>emoji</strong> (typing.Union[str, <a href=../emojis.html#Emoji>hikari.emojis.Emoji</a>]): Object or name of the emoji to remove all the reactions for.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>emoji_id</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../emojis.html#CustomEmoji>hikari.emojis.CustomEmoji</a>]]): ID of the custom emoji to remove all the reactions for. This should only be provided when a custom emoji's name is passed for <code>emoji</code>.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If an invalid unicode emoji is given, or if the given custom emoji does not exist.<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_MESSAGES</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel or message is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.delete_application_command><div class="attr function"><a class=headerlink href=#RESTClient.delete_application_command>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>delete_application_command</span><span class=signature>(<br>   self,<br>   application: Union[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   command: Union[<a href=../commands.html#PartialCommand>hikari.commands.PartialCommand</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_application_command</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>command</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a registered application command.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to delete a command for.</span>
<span class=sd>        command : hikari.snowflakes.SnowflakeishOr[hikari.commands.PartialCommand]</span>
<span class=sd>            Object or ID of the command to delete.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]]</span>
<span class=sd>            Object or ID of the guild to delete a command for if this is a guild</span>
<span class=sd>            specific command. Leave this as `hikari.undefined.UNDEFINED` to</span>
<span class=sd>            delete a global command.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application or command isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Delete a registered application command.<h6 id=parameters>Parameters</h6><ul><li><strong>application</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>]): Object or ID of the application to delete a command for.<li><strong>command</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../commands.html#PartialCommand>hikari.commands.PartialCommand</a>]): Object or ID of the command to delete.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>guild</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]]): Object or ID of the guild to delete a command for if this is a guild specific command. Leave this as <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code> to delete a global command.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you cannot access the provided application's commands.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the provided application or command isn't found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.delete_channel><div class="attr function"><a class=headerlink href=#RESTClient.delete_channel>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>delete_channel</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#PartialChannel>hikari.channels.PartialChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> <a href=../channels.html#PartialChannel>hikari.channels.PartialChannel</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PartialChannel</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>PartialChannel</span><span class=p>:</span>
        <span class=sd>"""Delete a channel in a guild, or close a DM.</span>

<span class=sd>        .. note::</span>
<span class=sd>            For Public servers, the set 'Rules' or 'Guidelines' channels and the</span>
<span class=sd>            'Public Server Updates' channel cannot be deleted.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel]</span>
<span class=sd>            The channel to delete. This may be the object or the ID of an</span>
<span class=sd>            existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.PartialChannel</span>
<span class=sd>            Object of the channel that was deleted.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Delete a channel in a guild, or close a DM.<p><em>Note:</em> For Public servers, the set 'Rules' or 'Guidelines' channels and the 'Public Server Updates' channel cannot be deleted.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#PartialChannel>hikari.channels.PartialChannel</a>]): The channel to delete. This may be the object or the ID of an existing channel.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../channels.html#PartialChannel>hikari.channels.PartialChannel</a></strong>: Object of the channel that was deleted.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_CHANNEL</code> permission in the channel.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.delete_emoji><div class="attr function"><a class=headerlink href=#RESTClient.delete_emoji>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>delete_emoji</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   emoji: Union[<a href=../emojis.html#CustomEmoji>hikari.emojis.CustomEmoji</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_emoji</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete an emoji in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to delete the emoji on. This can be a guild object or the</span>
<span class=sd>            ID of an existing guild.</span>
<span class=sd>        emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]</span>
<span class=sd>            The emoji to delete. This can be a `hikari.emojis.CustomEmoji`</span>
<span class=sd>            or the ID of an existing emoji.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing `MANAGE_EMOJIS_AND_STICKERS` in the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the emoji are not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Delete an emoji in a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to delete the emoji on. This can be a guild object or the ID of an existing guild.<li><strong>emoji</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../emojis.html#CustomEmoji>hikari.emojis.CustomEmoji</a>]): The emoji to delete. This can be a <code><a href=../emojis.html#CustomEmoji>hikari.emojis.CustomEmoji</a></code> or the ID of an existing emoji.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing <code>MANAGE_EMOJIS_AND_STICKERS</code> in the server.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild or the emoji are not found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.delete_guild><div class="attr function"><a class=headerlink href=#RESTClient.delete_guild>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>delete_guild</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_guild</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>])</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to delete. This may be the object or</span>
<span class=sd>            the ID of an existing guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not the owner of the guild.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If you own the guild or if you are not in it.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Delete a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to delete. This may be the object or the ID of an existing guild.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are not the owner of the guild.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If you own the guild or if you are not in it.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.delete_interaction_response><div class="attr function"><a class=headerlink href=#RESTClient.delete_interaction_response>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>delete_interaction_response</span><span class=signature>(<br>   self,<br>   application: Union[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   token: str<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_interaction_response</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span> <span class=n>token</span><span class=p>:</span> <span class=nb>str</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete the initial response of an interaction.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to delete a command response for.</span>
<span class=sd>        token : str</span>
<span class=sd>            The interaction's token.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the interaction or response is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Delete the initial response of an interaction.<h6 id=parameters>Parameters</h6><ul><li><strong>application</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>]): Object or ID of the application to delete a command response for.<li><strong>token</strong> (str): The interaction's token.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the interaction or response is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.delete_invite><div class="attr function"><a class=headerlink href=#RESTClient.delete_invite>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>delete_invite</span><span class=signature>(<br>   self,<br>   invite: Union[<a href=../invites.html#InviteCode>hikari.invites.InviteCode</a>, str]<br>) -> <a href=../invites.html#Invite>hikari.invites.Invite</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_invite</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>invite</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>invites</span><span class=o>.</span><span class=n>InviteCode</span><span class=p>,</span> <span class=nb>str</span><span class=p>])</span> <span class=o>-></span> <span class=n>invites</span><span class=o>.</span><span class=n>Invite</span><span class=p>:</span>
        <span class=sd>"""Delete an existing invite.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        invite : typing.Union[hikari.invites.InviteCode, str]</span>
<span class=sd>            The invite to delete. This may be an invite object or</span>
<span class=sd>            the code of an existing invite.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.invites.Invite</span>
<span class=sd>            Object of the invite that was deleted.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_GUILD` permission in the guild</span>
<span class=sd>            the invite is from or if you are missing the `MANAGE_CHANNELS`</span>
<span class=sd>            permission in the channel the invite is from.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the invite is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Delete an existing invite.<h6 id=parameters>Parameters</h6><ul><li><strong>invite</strong> (typing.Union[<a href=../invites.html#InviteCode>hikari.invites.InviteCode</a>, str]): The invite to delete. This may be an invite object or the code of an existing invite.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../invites.html#Invite>hikari.invites.Invite</a></strong>: Object of the invite that was deleted.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_GUILD</code> permission in the guild the invite is from or if you are missing the <code>MANAGE_CHANNELS</code> permission in the channel the invite is from.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the invite is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.delete_message><div class="attr function"><a class=headerlink href=#RESTClient.delete_message>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>delete_message</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   message: Union[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a given message in a given channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to delete the message in. This may be</span>
<span class=sd>            the object or the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete. This may be the object or the ID of</span>
<span class=sd>            an existing message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_MESSAGES`, and the message is</span>
<span class=sd>            not sent by you.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Delete a given message in a given channel.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>]): The channel to delete the message in. This may be the object or the ID of an existing channel.<li><strong>message</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>]): The message to delete. This may be the object or the ID of an existing message.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_MESSAGES</code>, and the message is not sent by you.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel or message is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.delete_messages><div class="attr function"><a class=headerlink href=#RESTClient.delete_messages>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>delete_messages</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   messages: Union[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, Iterable[Union[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]]],<br>   /,<br>   *other_messages: Union[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_messages</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>messages</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishIterable</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
        <span class=p>],</span>
        <span class=o>/</span><span class=p>,</span>
        <span class=o>*</span><span class=n>other_messages</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Bulk-delete messages from the channel.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This API endpoint will only be able to delete 100 messages</span>
<span class=sd>            at a time. For anything more than this, multiple requests will</span>
<span class=sd>            be executed one-after-the-other, since the rate limits for this</span>
<span class=sd>            endpoint do not favour more than one request per bucket.</span>

<span class=sd>            If one message is left over from chunking per 100 messages, or</span>
<span class=sd>            only one message is passed to this coroutine function, then the</span>
<span class=sd>            logic is expected to defer to `delete_message`. The implication</span>
<span class=sd>            of this is that the `delete_message` endpoint is rate limited</span>
<span class=sd>            by a different bucket with different usage rates.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            This endpoint is not atomic. If an error occurs midway through</span>
<span class=sd>            a bulk delete, you will **not** be able to revert any changes made</span>
<span class=sd>            up to this point.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            Specifying any messages more than 14 days old will cause the call</span>
<span class=sd>            to fail, potentially with partial completion.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to bulk delete the messages in. This may be</span>
<span class=sd>            the object or the ID of an existing channel.</span>
<span class=sd>        messages : typing.Union[hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage], hikari.snowflakes.SnowflakeishIterable[hikari.messages.PartialMessage]]</span>
<span class=sd>            Either the object/ID of an existing message to delete or an iterable</span>
<span class=sd>            of the objects and/or IDs of existing messages to delete.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        *other_messages : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The objects and/or IDs of other existing messages to delete.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BulkDeleteError</span>
<span class=sd>            An error containing the messages successfully deleted, and the</span>
<span class=sd>            messages that were not removed. The</span>
<span class=sd>            `BaseException.__cause__` of the exception will be the</span>
<span class=sd>            original error that terminated this process.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>
</pre></div></details><div class=docstring><p>Bulk-delete messages from the channel.<p><em>Note:</em> This API endpoint will only be able to delete 100 messages at a time. For anything more than this, multiple requests will be executed one-after-the-other, since the rate limits for this endpoint do not favour more than one request per bucket.<p>If one message is left over from chunking per 100 messages, or only one message is passed to this coroutine function, then the logic is expected to defer to <code><a href=#RESTClient.delete_message>delete_message</a></code>. The implication of this is that the <code><a href=#RESTClient.delete_message>delete_message</a></code> endpoint is rate limited by a different bucket with different usage rates.<p><em>Warning:</em> This endpoint is not atomic. If an error occurs midway through a bulk delete, you will <strong>not</strong> be able to revert any changes made up to this point.<p><em>Warning:</em> Specifying any messages more than 14 days old will cause the call to fail, potentially with partial completion.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>]): The channel to bulk delete the messages in. This may be the object or the ID of an existing channel.<li><strong>messages</strong> (typing.Union[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>], <a href=../snowflakes.html#SnowflakeishIterable>hikari.snowflakes.SnowflakeishIterable</a>[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>]]): Either the object/ID of an existing message to delete or an iterable of the objects and/or IDs of existing messages to delete.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>*other_messages</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>]): The objects and/or IDs of other existing messages to delete.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BulkDeleteError>hikari.errors.BulkDeleteError</a></strong>: An error containing the messages successfully deleted, and the messages that were not removed. The <code>BaseException.__cause__</code> of the exception will be the original error that terminated this process.</ul></div></div><div id=RESTClient.delete_my_reaction><div class="attr function"><a class=headerlink href=#RESTClient.delete_my_reaction>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>delete_my_reaction</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   message: Union[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   emoji: Union[str, <a href=../emojis.html#Emoji>hikari.emojis.Emoji</a>],<br>   emoji_id: Union[<a href=../emojis.html#CustomEmoji>hikari.emojis.CustomEmoji</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_my_reaction</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>emojis</span><span class=o>.</span><span class=n>Emoji</span><span class=p>],</span>
        <span class=n>emoji_id</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a reaction that your application user created.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel where the message to delete the reaction from is.</span>
<span class=sd>            This may be the object or the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete a reaction from. This may be the</span>
<span class=sd>            object or the ID of an existing message.</span>
<span class=sd>        emoji : typing.Union[str, hikari.emojis.Emoji]</span>
<span class=sd>            Object or name of the emoji to remove your reaction for.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]]</span>
<span class=sd>            ID of the custom emoji to remove your reaction for.</span>
<span class=sd>            This should only be provided when a custom emoji's name is passed</span>
<span class=sd>            for `emoji`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid unicode emoji is given, or if the given custom emoji</span>
<span class=sd>            does not exist.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Delete a reaction that your application user created.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>]): The channel where the message to delete the reaction from is. This may be the object or the ID of an existing channel.<li><strong>message</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>]): The message to delete a reaction from. This may be the object or the ID of an existing message.<li><strong>emoji</strong> (typing.Union[str, <a href=../emojis.html#Emoji>hikari.emojis.Emoji</a>]): Object or name of the emoji to remove your reaction for.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>emoji_id</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../emojis.html#CustomEmoji>hikari.emojis.CustomEmoji</a>]]): ID of the custom emoji to remove your reaction for. This should only be provided when a custom emoji's name is passed for <code>emoji</code>.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If an invalid unicode emoji is given, or if the given custom emoji does not exist.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel or message is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.delete_permission_overwrite><div class="attr function"><a class=headerlink href=#RESTClient.delete_permission_overwrite>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>delete_permission_overwrite</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#GuildChannel>hikari.channels.GuildChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   target: Union[<a href=../channels.html#PermissionOverwrite>hikari.channels.PermissionOverwrite</a>, <a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>, <a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_permission_overwrite</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>],</span>
        <span class=n>target</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span>
            <span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>,</span> <span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>,</span> <span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>,</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>Snowflakeish</span>
        <span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a custom permission for an entity in a given guild channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]</span>
<span class=sd>            The channel to delete a permission overwrite in. This may be the</span>
<span class=sd>            object, or the ID of an existing channel.</span>
<span class=sd>        target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish]</span>
<span class=sd>            The channel overwrite to delete.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_PERMISSIONS` permission in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found or the target is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>
</pre></div></details><div class=docstring><p>Delete a custom permission for an entity in a given guild channel.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildChannel>hikari.channels.GuildChannel</a>]): The channel to delete a permission overwrite in. This may be the object, or the ID of an existing channel.<li><strong>target</strong> (typing.Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>, <a href=../channels.html#PermissionOverwrite>hikari.channels.PermissionOverwrite</a>, <a href=../snowflakes.html#Snowflakeish>hikari.snowflakes.Snowflakeish</a>]): The channel overwrite to delete.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_PERMISSIONS</code> permission in the channel.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel is not found or the target is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.delete_reaction><div class="attr function"><a class=headerlink href=#RESTClient.delete_reaction>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>delete_reaction</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   message: Union[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   user: Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   emoji: Union[str, <a href=../emojis.html#Emoji>hikari.emojis.Emoji</a>],<br>   emoji_id: Union[<a href=../emojis.html#CustomEmoji>hikari.emojis.CustomEmoji</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_reaction</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>emojis</span><span class=o>.</span><span class=n>Emoji</span><span class=p>],</span>
        <span class=n>emoji_id</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a reaction from a message.</span>

<span class=sd>        If you are looking to delete your own applications reaction, use</span>
<span class=sd>        `delete_my_reaction`.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel where the message to delete the reaction from is.</span>
<span class=sd>            This may be the object or the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete a reaction from. This may be the</span>
<span class=sd>            object or the ID of an existing message.</span>
<span class=sd>        user: hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            Object or ID of the user to remove the reaction of.</span>
<span class=sd>        emoji : typing.Union[str, hikari.emojis.Emoji]</span>
<span class=sd>            Object or name of the emoji to react with.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]]</span>
<span class=sd>            ID of the custom emoji to react with.</span>
<span class=sd>            This should only be provided when a custom emoji's name is passed</span>
<span class=sd>            for `emoji`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid unicode emoji is given, or if the given custom emoji</span>
<span class=sd>            does not exist.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_MESSAGES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Delete a reaction from a message.<p>If you are looking to delete your own applications reaction, use <code><a href=#RESTClient.delete_my_reaction>delete_my_reaction</a></code>.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>]): The channel where the message to delete the reaction from is. This may be the object or the ID of an existing channel.<li><strong>message</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>]): The message to delete a reaction from. This may be the object or the ID of an existing message.<li><strong>user</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>]): Object or ID of the user to remove the reaction of.<li><strong>emoji</strong> (typing.Union[str, <a href=../emojis.html#Emoji>hikari.emojis.Emoji</a>]): Object or name of the emoji to react with.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>emoji_id</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../emojis.html#CustomEmoji>hikari.emojis.CustomEmoji</a>]]): ID of the custom emoji to react with. This should only be provided when a custom emoji's name is passed for <code>emoji</code>.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If an invalid unicode emoji is given, or if the given custom emoji does not exist.<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_MESSAGES</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel or message is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.delete_role><div class="attr function"><a class=headerlink href=#RESTClient.delete_role>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>delete_role</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   role: Union[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_role</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>role</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a role.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to delete the role in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]</span>
<span class=sd>            The role to delete. This may be the object or the</span>
<span class=sd>            ID of an existing role.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_ROLES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or role are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Delete a role.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to delete the role in. This may be the object or the ID of an existing guild.<li><strong>role</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>]): The role to delete. This may be the object or the ID of an existing role.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_ROLES</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild or role are not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.delete_sticker><div class="attr function"><a class=headerlink href=#RESTClient.delete_sticker>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>delete_sticker</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   sticker: Union[<a href=../stickers.html#PartialSticker>hikari.stickers.PartialSticker</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_sticker</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>sticker</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>stickers</span><span class=o>.</span><span class=n>PartialSticker</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a sticker in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to delete the sticker on. This can be a guild object or</span>
<span class=sd>            the ID of an existing guild.</span>
<span class=sd>        sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker]</span>
<span class=sd>            The sticker to delete. This can be a sticker object or the ID</span>
<span class=sd>            of an existing sticker.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing `MANAGE_EMOJIS_AND_STICKERS` in the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the sticker are not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Delete a sticker in a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to delete the sticker on. This can be a guild object or the ID of an existing guild.<li><strong>sticker</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../stickers.html#PartialSticker>hikari.stickers.PartialSticker</a>]): The sticker to delete. This can be a sticker object or the ID of an existing sticker.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing <code>MANAGE_EMOJIS_AND_STICKERS</code> in the server.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild or the sticker are not found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.delete_template><div class="attr function"><a class=headerlink href=#RESTClient.delete_template>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>delete_template</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   template: Union[str, <a href=../templates.html#Template>hikari.templates.Template</a>]<br>) -> <a href=../templates.html#Template>hikari.templates.Template</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_template</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>template</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>:</span>
        <span class=sd>"""Delete a guild template.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to delete a template in.</span>
<span class=sd>        template : typing.Union[str, hikari.templates.Template]</span>
<span class=sd>            Object or string code of the template to delete.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.templates.Template</span>
<span class=sd>            The deleted template's object.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found or you are missing the `MANAGE_GUILD`</span>
<span class=sd>            permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Delete a guild template.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to delete a template in.<li><strong>template</strong> (typing.Union[str, <a href=../templates.html#Template>hikari.templates.Template</a>]): Object or string code of the template to delete.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../templates.html#Template>hikari.templates.Template</a></strong>: The deleted template's object.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are not part of the guild.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found or you are missing the <code>MANAGE_GUILD</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.delete_webhook><div class="attr function"><a class=headerlink href=#RESTClient.delete_webhook>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>delete_webhook</span><span class=signature>(<br>   self,<br>   webhook: Union[<a href=../webhooks.html#PartialWebhook>hikari.webhooks.PartialWebhook</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   token: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_webhook</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>webhook</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>PartialWebhook</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>token</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a webhook.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.PartialWebhook]</span>
<span class=sd>            The webhook to delete. This may be the object or the</span>
<span class=sd>            ID of an existing webhook.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        token : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the webhoook token that will be used to delete</span>
<span class=sd>            the webhook instead of the token the client was initialized with.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_WEBHOOKS` permission when not</span>
<span class=sd>            using a token.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the webhoook is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Delete a webhook.<h6 id=parameters>Parameters</h6><ul><li><strong>webhook</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../webhooks.html#PartialWebhook>hikari.webhooks.PartialWebhook</a>]): The webhook to delete. This may be the object or the ID of an existing webhook.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>token</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the webhoook token that will be used to delete the webhook instead of the token the client was initialized with.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_WEBHOOKS</code> permission when not using a token.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the webhoook is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.delete_webhook_message><div class="attr function"><a class=headerlink href=#RESTClient.delete_webhook_message>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>delete_webhook_message</span><span class=signature>(<br>   self,<br>   webhook: Union[<a href=../webhooks.html#ExecutableWebhook>hikari.webhooks.ExecutableWebhook</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   token: str,<br>   message: Union[<a href=../messages.html#Message>hikari.messages.Message</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>delete_webhook_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=c1># MyPy might not say this but SnowflakeishOr[ExecutableWebhook] isn't valid as ExecutableWebhook isn't Unique</span>
        <span class=n>webhook</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>ExecutableWebhook</span><span class=p>,</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>Snowflakeish</span><span class=p>],</span>
        <span class=n>token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Delete a given message in a given channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        webhook : typing.Union[hikari.snowflakes.Snowflakeish, hikari.webhooks.ExecutableWebhook]</span>
<span class=sd>            The webhook to execute. This may be the object</span>
<span class=sd>            or the ID of an existing webhook.</span>
<span class=sd>        token: str</span>
<span class=sd>            The webhook token.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete. This may be the object or the ID of</span>
<span class=sd>            an existing message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the webhook or the message are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Delete a given message in a given channel.<h6 id=parameters>Parameters</h6><ul><li><strong>webhook</strong> (typing.Union[<a href=../snowflakes.html#Snowflakeish>hikari.snowflakes.Snowflakeish</a>, <a href=../webhooks.html#ExecutableWebhook>hikari.webhooks.ExecutableWebhook</a>]): The webhook to execute. This may be the object or the ID of an existing webhook.<li><strong>token</strong> (str): The webhook token.<li><strong>message</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>]): The message to delete. This may be the object or the ID of an existing message.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the webhook or the message are not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.edit_application_command><div class="attr function"><a class=headerlink href=#RESTClient.edit_application_command>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>edit_application_command</span><span class=signature>(<br>   self,<br>   application: Union[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   command: Union[<a href=../commands.html#PartialCommand>hikari.commands.PartialCommand</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   *,<br>   name: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   description: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   options: Union[Sequence[<a href=../commands.html#CommandOption>hikari.commands.CommandOption</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../commands.html#PartialCommand>hikari.commands.PartialCommand</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_application_command</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>command</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>options</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandOption</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>:</span>
        <span class=sd>"""Edit a registered application command.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to edit a command for.</span>
<span class=sd>        command : hikari.snowflakes.SnowflakeishOr[hikari.commands.PartialCommand]</span>
<span class=sd>            Object or ID of the command to modify.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]]</span>
<span class=sd>            Object or ID of the guild to edit a command for if this is a guild</span>
<span class=sd>            specific command. Leave this as `hikari.undefined.UNDEFINED` to delete</span>
<span class=sd>            a global command.</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            The name to set for the command. Leave as `hikari.undefined.UNDEFINED`</span>
<span class=sd>            to not change.</span>
<span class=sd>        description : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            The description to set for the command. Leave as `hikari.undefined.UNDEFINED`</span>
<span class=sd>            to not change.</span>
<span class=sd>        options : hikari.undefined.UndefinedOr[typing.Sequence[hikari.commands.CommandOption]]</span>
<span class=sd>            A sequence of up to 10 options to set for this command. Leave this as</span>
<span class=sd>            `hikari.undefined.UNDEFINED` to not change.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.commands.PartialCommand</span>
<span class=sd>            The edited command object.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application or command isn't found.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Edit a registered application command.<h6 id=parameters>Parameters</h6><ul><li><strong>application</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>]): Object or ID of the application to edit a command for.<li><strong>command</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../commands.html#PartialCommand>hikari.commands.PartialCommand</a>]): Object or ID of the command to modify.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>guild</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]]): Object or ID of the guild to edit a command for if this is a guild specific command. Leave this as <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code> to delete a global command.<li><strong>name</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): The name to set for the command. Leave as <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code> to not change.<li><strong>description</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): The description to set for the command. Leave as <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code> to not change.<li><strong>options</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Sequence[<a href=../commands.html#CommandOption>hikari.commands.CommandOption</a>]]): A sequence of up to 10 options to set for this command. Leave this as <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code> to not change.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../commands.html#PartialCommand>hikari.commands.PartialCommand</a></strong>: The edited command object.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you cannot access the provided application's commands.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the provided application or command isn't found.<li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.edit_channel><div class="attr function"><a class=headerlink href=#RESTClient.edit_channel>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>edit_channel</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#GuildChannel>hikari.channels.GuildChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   /,<br>   *,<br>   name: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   position: Union[int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   topic: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   nsfw: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   bitrate: Union[int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   video_quality_mode: Union[<a href=../channels.html#VideoQualityMode>hikari.channels.VideoQualityMode</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   user_limit: Union[int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   rate_limit_per_user: Union[int, float, datetime.timedelta, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   region: Union[<a href=../voices.html#VoiceRegion>hikari.voices.VoiceRegion</a>, str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   permission_overwrites: Union[Sequence[<a href=../channels.html#PermissionOverwrite>hikari.channels.PermissionOverwrite</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   parent_category: Union[<a href=../channels.html#GuildCategory>hikari.channels.GuildCategory</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../channels.html#PartialChannel>hikari.channels.PartialChannel</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>],</span>
        <span class=o>/</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>position</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>topic</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>nsfw</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>bitrate</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>video_quality_mode</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>VideoQualityMode</span><span class=p>,</span> <span class=nb>int</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_limit</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>rate_limit_per_user</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>time</span><span class=o>.</span><span class=n>Intervalish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>region</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>voices</span><span class=o>.</span><span class=n>VoiceRegion</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permission_overwrites</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>parent_category</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildCategory</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>PartialChannel</span><span class=p>:</span>
        <span class=sd>"""Edit a channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]</span>
<span class=sd>            The channel to edit. This may be the object or the ID of an</span>
<span class=sd>            existing channel.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[[str]</span>
<span class=sd>            If provided, the new name for the channel.</span>
<span class=sd>        position : hikari.undefined.UndefinedOr[[int]</span>
<span class=sd>            If provided, the new position for the channel.</span>
<span class=sd>        topic : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new topic for the channel.</span>
<span class=sd>        nsfw : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the channel should be marked as NSFW or not.</span>
<span class=sd>        bitrate : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the new bitrate for the channel.</span>
<span class=sd>        video_quality_mode: hikari.undefined.UndefinedOr[typing.Union[hikari.channels.VideoQualityMode, int]]</span>
<span class=sd>            If provided, the new video quality mode for the channel.</span>
<span class=sd>        user_limit : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, the new user limit in the channel.</span>
<span class=sd>        rate_limit_per_user : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]</span>
<span class=sd>            If provided, the new rate limit per user in the channel.</span>
<span class=sd>        region : hikari.undefined.UndefinedOr[typing.Union[str, hikari.voices.VoiceRegion]]</span>
<span class=sd>            If provided, the voice region to set for this channel. Passing</span>
<span class=sd>            `None` here will set it to "auto" mode where the used</span>
<span class=sd>            region will be decided based on the first person who connects to it</span>
<span class=sd>            when it's empty.</span>
<span class=sd>        permission_overwrites : hikari.undefined.UndefinedOr[typing.Sequence[hikari.channels.PermissionOverwrite]]</span>
<span class=sd>            If provided, the new permission overwrites for the channel.</span>
<span class=sd>        parent_category : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildCategory]]</span>
<span class=sd>            If provided, the new guild category for the channel.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.PartialChannel</span>
<span class=sd>            The edited channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing permissions to edit the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Edit a channel.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildChannel>hikari.channels.GuildChannel</a>]): The channel to edit. This may be the object or the ID of an existing channel.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>name</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[[str]): If provided, the new name for the channel.<li><strong>position</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[[int]): If provided, the new position for the channel.<li><strong>topic</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the new topic for the channel.<li><strong>nsfw</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, whether the channel should be marked as NSFW or not.<li><strong>bitrate</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[int]): If provided, the new bitrate for the channel.<li><strong>video_quality_mode</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Union[<a href=../channels.html#VideoQualityMode>hikari.channels.VideoQualityMode</a>, int]]): If provided, the new video quality mode for the channel.<li><strong>user_limit</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[int]): If provided, the new user limit in the channel.<li><strong>rate_limit_per_user</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../internal/time.html#Intervalish>hikari.internal.time.Intervalish</a>]): If provided, the new rate limit per user in the channel.<li><strong>region</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Union[str, <a href=../voices.html#VoiceRegion>hikari.voices.VoiceRegion</a>]]): If provided, the voice region to set for this channel. Passing <code>None</code> here will set it to "auto" mode where the used region will be decided based on the first person who connects to it when it's empty.<li><strong>permission_overwrites</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Sequence[<a href=../channels.html#PermissionOverwrite>hikari.channels.PermissionOverwrite</a>]]): If provided, the new permission overwrites for the channel.<li><strong>parent_category</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildCategory>hikari.channels.GuildCategory</a>]]): If provided, the new guild category for the channel.<li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../channels.html#PartialChannel>hikari.channels.PartialChannel</a></strong>: The edited channel.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing permissions to edit the channel.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.edit_emoji><div class="attr function"><a class=headerlink href=#RESTClient.edit_emoji>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>edit_emoji</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   emoji: Union[<a href=../emojis.html#CustomEmoji>hikari.emojis.CustomEmoji</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   name: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   roles: Union[Sequence[Union[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../emojis.html#KnownCustomEmoji>hikari.emojis.KnownCustomEmoji</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_emoji</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>roles</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>emojis</span><span class=o>.</span><span class=n>KnownCustomEmoji</span><span class=p>:</span>
        <span class=sd>"""Edit an emoji in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit the emoji on. This can be a</span>
<span class=sd>            guild object or the ID of an existing guild.</span>
<span class=sd>        emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]</span>
<span class=sd>            The emoji to edit. This can be a `hikari.emojis.CustomEmoji`</span>
<span class=sd>            or the ID of an existing emoji.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new name for the emoji.</span>
<span class=sd>        roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole]]</span>
<span class=sd>            If provided, the new collection of roles that will be able to</span>
<span class=sd>            use this emoji. This can be a `hikari.guilds.PartialRole` or</span>
<span class=sd>            the ID of an existing role.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.emojis.KnownCustomEmoji</span>
<span class=sd>            The edited emoji.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing `MANAGE_EMOJIS_AND_STICKERS` in the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the emoji are not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Edit an emoji in a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to edit the emoji on. This can be a guild object or the ID of an existing guild.<li><strong>emoji</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../emojis.html#CustomEmoji>hikari.emojis.CustomEmoji</a>]): The emoji to edit. This can be a <code><a href=../emojis.html#CustomEmoji>hikari.emojis.CustomEmoji</a></code> or the ID of an existing emoji.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>name</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the new name for the emoji.<li><strong>roles</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishSequence>hikari.snowflakes.SnowflakeishSequence</a>[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>]]): If provided, the new collection of roles that will be able to use this emoji. This can be a <code><a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a></code> or the ID of an existing role.<li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../emojis.html#KnownCustomEmoji>hikari.emojis.KnownCustomEmoji</a></strong>: The edited emoji.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing <code>MANAGE_EMOJIS_AND_STICKERS</code> in the server.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild or the emoji are not found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.edit_guild><div class="attr function"><a class=headerlink href=#RESTClient.edit_guild>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>edit_guild</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   name: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   verification_level: Union[<a href=../guilds.html#GuildVerificationLevel>hikari.guilds.GuildVerificationLevel</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   default_message_notifications: Union[<a href=../guilds.html#GuildMessageNotificationsLevel>hikari.guilds.GuildMessageNotificationsLevel</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   explicit_content_filter_level: Union[<a href=../guilds.html#GuildExplicitContentFilterLevel>hikari.guilds.GuildExplicitContentFilterLevel</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   afk_channel: Union[<a href=../channels.html#GuildVoiceChannel>hikari.channels.GuildVoiceChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   afk_timeout: Union[int, float, datetime.timedelta, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   icon: Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   owner: Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   splash: Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   banner: Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   system_channel: Union[<a href=../channels.html#GuildTextChannel>hikari.channels.GuildTextChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   rules_channel: Union[<a href=../channels.html#GuildTextChannel>hikari.channels.GuildTextChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   public_updates_channel: Union[<a href=../channels.html#GuildTextChannel>hikari.channels.GuildTextChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   preferred_locale: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../guilds.html#RESTGuild>hikari.guilds.RESTGuild</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_guild</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>verification_level</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>GuildVerificationLevel</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>default_message_notifications</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>guilds</span><span class=o>.</span><span class=n>GuildMessageNotificationsLevel</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>explicit_content_filter_level</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>guilds</span><span class=o>.</span><span class=n>GuildExplicitContentFilterLevel</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>afk_channel</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildVoiceChannel</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>afk_timeout</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>time</span><span class=o>.</span><span class=n>Intervalish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>icon</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>owner</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>splash</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>banner</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>system_channel</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildTextChannel</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>rules_channel</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildTextChannel</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>public_updates_channel</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildTextChannel</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>preferred_locale</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>RESTGuild</span><span class=p>:</span>
        <span class=sd>"""Edit a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new name for the guild.</span>
<span class=sd>        verification_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildVerificationLevel]</span>
<span class=sd>            If provided, the new verification level.</span>
<span class=sd>        default_message_notifications : hikari.undefined.UndefinedOr[hikari.guilds.GuildMessageNotificationsLevel]</span>
<span class=sd>            If provided, the new default message notifications level.</span>
<span class=sd>        explicit_content_filter_level : hikari.undefined.UndefinedOr[hikari.guilds.GuildExplicitContentFilterLevel]</span>
<span class=sd>            If provided, the new explicit content filter level.</span>
<span class=sd>        afk_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel]]</span>
<span class=sd>            If provided, the new afk channel. Requires `afk_timeout` to</span>
<span class=sd>            be set to work.</span>
<span class=sd>        afk_timeout : hikari.undefined.UndefinedOr[hikari.internal.time.Intervalish]</span>
<span class=sd>            If provided, the new afk timeout.</span>
<span class=sd>        icon : hikari.undefined.UndefinedOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the new guild icon. Must be a 1024x1024 image or can be</span>
<span class=sd>            an animated gif when the guild has the `ANIMATED_ICON` feature.</span>
<span class=sd>        owner : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]]]</span>
<span class=sd>            If provided, the new guild owner.</span>

<span class=sd>            .. warning::</span>
<span class=sd>                You need to be the owner of the server to use this.</span>
<span class=sd>        splash : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the new guild splash. Must be a 16:9 image and the</span>
<span class=sd>            guild must have the `INVITE_SPLASH` feature.</span>
<span class=sd>        banner : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the new guild banner. Must be a 16:9 image and the</span>
<span class=sd>            guild must have the `BANNER` feature.</span>
<span class=sd>        system_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel]]</span>
<span class=sd>            If provided, the new system channel.</span>
<span class=sd>        rules_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel]]</span>
<span class=sd>            If provided, the new rules channel.</span>
<span class=sd>        public_updates_channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildTextChannel]]</span>
<span class=sd>            If provided, the new public updates channel.</span>
<span class=sd>        preferred_locale : hikari.undefined.UndefinedNoneOr[str]</span>
<span class=sd>            If provided, the new preferred locale.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.RESTGuild</span>
<span class=sd>            The edited guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value. Or</span>
<span class=sd>            you are missing the</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_GUILD` permission or if you tried to</span>
<span class=sd>            pass ownership without being the server owner.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>
</pre></div></details><div class=docstring><p>Edit a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to edit. This may be the object or the ID of an existing guild.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>name</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the new name for the guild.<li><strong>verification_level</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../guilds.html#GuildVerificationLevel>hikari.guilds.GuildVerificationLevel</a>]): If provided, the new verification level.<li><strong>default_message_notifications</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../guilds.html#GuildMessageNotificationsLevel>hikari.guilds.GuildMessageNotificationsLevel</a>]): If provided, the new default message notifications level.<li><strong>explicit_content_filter_level</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../guilds.html#GuildExplicitContentFilterLevel>hikari.guilds.GuildExplicitContentFilterLevel</a>]): If provided, the new explicit content filter level.<li><strong>afk_channel</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildVoiceChannel>hikari.channels.GuildVoiceChannel</a>]]): If provided, the new afk channel. Requires <code>afk_timeout</code> to be set to work.<li><strong>afk_timeout</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../internal/time.html#Intervalish>hikari.internal.time.Intervalish</a>]): If provided, the new afk timeout.<li><strong>icon</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../files.html#Resourceish>hikari.files.Resourceish</a>]): If provided, the new guild icon. Must be a 1024x1024 image or can be an animated gif when the guild has the <code>ANIMATED_ICON</code> feature.<li><p><strong>owner</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>]]]): If provided, the new guild owner.</p> <p><em>Warning:</em> You need to be the owner of the server to use this.<li><strong>splash</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[<a href=../files.html#Resourceish>hikari.files.Resourceish</a>]): If provided, the new guild splash. Must be a 16:9 image and the guild must have the <code>INVITE_SPLASH</code> feature.<li><strong>banner</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[<a href=../files.html#Resourceish>hikari.files.Resourceish</a>]): If provided, the new guild banner. Must be a 16:9 image and the guild must have the <code>BANNER</code> feature.<li><strong>system_channel</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildTextChannel>hikari.channels.GuildTextChannel</a>]]): If provided, the new system channel.<li><strong>rules_channel</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildTextChannel>hikari.channels.GuildTextChannel</a>]]): If provided, the new rules channel.<li><strong>public_updates_channel</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildTextChannel>hikari.channels.GuildTextChannel</a>]]): If provided, the new public updates channel.<li><strong>preferred_locale</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[str]): If provided, the new preferred locale.<li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../guilds.html#RESTGuild>hikari.guilds.RESTGuild</a></strong>: The edited guild.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value. Or you are missing the<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_GUILD</code> permission or if you tried to pass ownership without being the server owner.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.edit_interaction_response><div class="attr function"><a class=headerlink href=#RESTClient.edit_interaction_response>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>edit_interaction_response</span><span class=signature>(<br>   self,<br>   application: Union[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   token: str,<br>   content: Union[Any, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   *,<br>   attachment: Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   attachments: Union[Sequence[Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO]], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   component: Union[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   components: Union[Sequence[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   embed: Union[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   embeds: Union[Sequence[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   replace_attachments: bool = False,<br>   mentions_everyone: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   user_mentions: Union[Sequence[Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]], bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   role_mentions: Union[Sequence[Union[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]], bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../messages.html#Message>hikari.messages.Message</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_interaction_response</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>content</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Any</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>attachment</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachments</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>component</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>components</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embed</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embeds</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>replace_attachments</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
        <span class=n>mentions_everyone</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>role_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Edit the initial response to a command interaction.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        Mentioning everyone, roles, or users in message edits currently</span>
<span class=sd>        will not send a push notification showing a new mention to people</span>
<span class=sd>        on Discord. It will still highlight in their chat as if they</span>
<span class=sd>        were mentioned, however.</span>

<span class=sd>        Also important to note that if you specify a text `content`, `mentions_everyone`,</span>
<span class=sd>        `mentions_reply`, `user_mentions`, and `role_mentions` will default</span>
<span class=sd>        to `False` as the message will be re-parsed for mentions. This will</span>
<span class=sd>        also occur if only one of the four are specified</span>

<span class=sd>        This is a limitation of Discord's design. If in doubt, specify all</span>
<span class=sd>        four of them each time.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to edit a command response for.</span>
<span class=sd>        token : str</span>
<span class=sd>            The interaction's token.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        content : hikari.undefined.UndefinedOr[typing.Any]</span>
<span class=sd>            If provided, the message content to update with. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then the content will not</span>
<span class=sd>            be changed. If `None`, then the content will be removed.</span>

<span class=sd>            Any other value will be cast to a `str` before sending.</span>

<span class=sd>            If this is a `hikari.embeds.Embed` and neither the</span>
<span class=sd>            `embed` or `embeds` kwargs are provided or if this is a</span>
<span class=sd>            `hikari.files.Resourceish` and neither the `attachment` or</span>
<span class=sd>            `attachments` kwargs are provided, the values will be overwritten.</span>
<span class=sd>            This allows for simpler syntax when sending an embed or an</span>
<span class=sd>            attachment alone.</span>
<span class=sd>        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the attachment to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous attachment, if</span>
<span class=sd>            present, is not changed. If this is `None`, then the</span>
<span class=sd>            attachment is removed, if present. Otherwise, the new attachment</span>
<span class=sd>            that was provided will be attached.</span>
<span class=sd>        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]]</span>
<span class=sd>            If provided, the attachments to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous attachments, if</span>
<span class=sd>            present, are not changed. If this is `None`, then the</span>
<span class=sd>            attachments is removed, if present. Otherwise, the new attachments</span>
<span class=sd>            that were provided will be attached.</span>
<span class=sd>        component : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder]</span>
<span class=sd>            If provided, builder object of the component to set for this message.</span>
<span class=sd>            This component will replace any previously set components and passing</span>
<span class=sd>            `None` will remove all components.</span>
<span class=sd>        components : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]</span>
<span class=sd>            If provided, a sequence of the component builder objects set for</span>
<span class=sd>            this message. These components will replace any previously set</span>
<span class=sd>            components and passing `None` or an empty sequence will</span>
<span class=sd>            remove all components.</span>
<span class=sd>        embed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed]</span>
<span class=sd>            If provided, the embed to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.</span>
<span class=sd>            If this is `None` then any present embeds are removed.</span>
<span class=sd>            Otherwise, the new embed that was provided will be used as the</span>
<span class=sd>            replacement.</span>
<span class=sd>        embeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed]]</span>
<span class=sd>            If provided, the embeds to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.</span>
<span class=sd>            If this is `None` then any present embeds are removed.</span>
<span class=sd>            Otherwise, the new embeds that were provided will be used as the</span>
<span class=sd>            replacement.</span>
<span class=sd>        replace_attachments: bool</span>
<span class=sd>            Whether to replace the attachments with the provided ones. Defaults</span>
<span class=sd>            to `False`.</span>

<span class=sd>            Note this will also overwrite the embed attachments.</span>
<span class=sd>        mentions_everyone : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the message should parse @everyone/@here</span>
<span class=sd>            mentions.</span>
<span class=sd>        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], bool]]</span>
<span class=sd>            If provided, and `True`, all user mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all user mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.users.PartialUser` derivatives to enforce mentioning</span>
<span class=sd>            specific users.</span>
<span class=sd>        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], bool]]</span>
<span class=sd>            If provided, and `True`, all role mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all role mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.guilds.PartialRole` derivatives to enforce mentioning</span>
<span class=sd>            specific roles.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The edited message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        ValueError</span>
<span class=sd>            If both `attachment` and `attachments`, `component` and `components`</span>
<span class=sd>            or `embed` and `embeds` are specified.</span>
<span class=sd>        TypeError</span>
<span class=sd>            If `attachments`, `components` or `embeds` is passed but is not a</span>
<span class=sd>            sequence.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            This may be raised in several discrete situations, such as messages</span>
<span class=sd>            being empty with no attachments or embeds; messages with more than</span>
<span class=sd>            2000 characters in them, embeds that exceed one of the many embed</span>
<span class=sd>            limits; too many attachments; attachments that are too large;</span>
<span class=sd>            invalid image URLs in embeds; too many components.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the interaction or the message are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>
</pre></div></details><div class=docstring><p>Edit the initial response to a command interaction.<h6 id=notes>Notes</h6><p>Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however.<p>Also important to note that if you specify a text <code>content</code>, <code>mentions_everyone</code>, <code>mentions_reply</code>, <code>user_mentions</code>, and <code>role_mentions</code> will default to <code>False</code> as the message will be re-parsed for mentions. This will also occur if only one of the four are specified<p>This is a limitation of Discord's design. If in doubt, specify all four of them each time.<h6 id=parameters>Parameters</h6><ul><li><strong>application</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>]): Object or ID of the application to edit a command response for.<li><strong>token</strong> (str): The interaction's token.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><p><strong>content</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Any]): If provided, the message content to update with. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, then the content will not be changed. If <code>None</code>, then the content will be removed.</p> <p>Any other value will be cast to a <code>str</code> before sending.</p> <p>If this is a <code><a href=../embeds.html#Embed>hikari.embeds.Embed</a></code> and neither the <code>embed</code> or <code>embeds</code> kwargs are provided or if this is a <code><a href=../files.html#Resourceish>hikari.files.Resourceish</a></code> and neither the <code>attachment</code> or <code>attachments</code> kwargs are provided, the values will be overwritten. This allows for simpler syntax when sending an embed or an attachment alone.<li><strong>attachment</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../files.html#Resourceish>hikari.files.Resourceish</a>]): If provided, the attachment to set on the message. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, the previous attachment, if present, is not changed. If this is <code>None</code>, then the attachment is removed, if present. Otherwise, the new attachment that was provided will be attached.<li><strong>attachments</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Sequence[<a href=../files.html#Resourceish>hikari.files.Resourceish</a>]]): If provided, the attachments to set on the message. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, the previous attachments, if present, are not changed. If this is <code>None</code>, then the attachments is removed, if present. Otherwise, the new attachments that were provided will be attached.<li><strong>component</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>]): If provided, builder object of the component to set for this message. This component will replace any previously set components and passing <code>None</code> will remove all components.<li><strong>components</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[typing.Sequence[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>]]): If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing <code>None</code> or an empty sequence will remove all components.<li><strong>embed</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>]): If provided, the embed to set on the message. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, the previous embed(s) are not changed. If this is <code>None</code> then any present embeds are removed. Otherwise, the new embed that was provided will be used as the replacement.<li><strong>embeds</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[typing.Sequence[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>]]): If provided, the embeds to set on the message. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, the previous embed(s) are not changed. If this is <code>None</code> then any present embeds are removed. Otherwise, the new embeds that were provided will be used as the replacement.<li><p><strong>replace_attachments</strong> (bool): Whether to replace the attachments with the provided ones. Defaults to <code>False</code>.</p> <p>Note this will also overwrite the embed attachments.<li><strong>mentions_everyone</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, whether the message should parse @everyone/@here mentions.<li><strong>user_mentions</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Union[<a href=../snowflakes.html#SnowflakeishSequence>hikari.snowflakes.SnowflakeishSequence</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>], bool]]): If provided, and <code>True</code>, all user mentions will be detected. If provided, and <code>False</code>, all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of <code><a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a></code>, or <code><a href=../users.html#PartialUser>hikari.users.PartialUser</a></code> derivatives to enforce mentioning specific users.<li><strong>role_mentions</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Union[<a href=../snowflakes.html#SnowflakeishSequence>hikari.snowflakes.SnowflakeishSequence</a>[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>], bool]]): If provided, and <code>True</code>, all role mentions will be detected. If provided, and <code>False</code>, all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of <code><a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a></code>, or <code><a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a></code> derivatives to enforce mentioning specific roles.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../messages.html#Message>hikari.messages.Message</a></strong>: The edited message.</ul><h6 id=raises>Raises</h6><ul><li><strong>ValueError</strong>: If both <code>attachment</code> and <code>attachments</code>, <code>component</code> and <code>components</code> or <code>embed</code> and <code>embeds</code> are specified.<li><strong>TypeError</strong>: If <code>attachments</code>, <code>components</code> or <code>embeds</code> is passed but is not a sequence.<li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the interaction or the message are not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.edit_member><div class="attr function"><a class=headerlink href=#RESTClient.edit_member>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>edit_member</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   user: Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   nick: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   roles: Union[Sequence[Union[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   mute: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   deaf: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   voice_channel: Union[<a href=../channels.html#GuildVoiceChannel>hikari.channels.GuildVoiceChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   communication_disabled_until: Union[datetime.datetime, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../guilds.html#Member>hikari.guilds.Member</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>nick</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>roles</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mute</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>deaf</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>voice_channel</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildVoiceChannel</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>communication_disabled_until</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>datetime</span><span class=o>.</span><span class=n>datetime</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>Member</span><span class=p>:</span>
        <span class=sd>"""Edit a guild member.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to edit. This may be the object</span>
<span class=sd>            or the ID of an existing user.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        nick : hikari.undefined.UndefinedNoneOr[str]</span>
<span class=sd>            If provided, the new nick for the member. If `None`,</span>
<span class=sd>            will remove the members nick.</span>

<span class=sd>            Requires the `MANAGE_NICKNAMES` permission.</span>
<span class=sd>        roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole]]</span>
<span class=sd>            If provided, the new roles for the member.</span>

<span class=sd>            Requires the `MANAGE_ROLES` permission.</span>
<span class=sd>        mute : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, the new server mute state for the member.</span>

<span class=sd>            Requires the `MUTE_MEMBERS` permission.</span>
<span class=sd>        deaf : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, the new server deaf state for the member.</span>

<span class=sd>            Requires the `DEAFEN_MEMBERS` permission.</span>
<span class=sd>        voice_channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildVoiceChannel]]]</span>
<span class=sd>            If provided, `None` or the object or the ID of</span>
<span class=sd>            an existing voice channel to move the member to.</span>
<span class=sd>            If `None`, will disconnect the member from voice.</span>

<span class=sd>            Requires the `MOVE_MEMBERS` permission and the `CONNECT`</span>
<span class=sd>            permission in the original voice channel and the target</span>
<span class=sd>            voice channel.</span>

<span class=sd>            .. note::</span>
<span class=sd>                If the member is not in a voice channel, this will</span>
<span class=sd>                take no effect.</span>
<span class=sd>        communication_disabled_until : hikari.undefined.UndefinedNoneOr[datetime.datetime]</span>
<span class=sd>            If provided, the datetime when the timeout (disable communication)</span>
<span class=sd>            of the member expires, up to 28 days in the future, or `None`</span>
<span class=sd>            to remove the timeout from the member.</span>

<span class=sd>            Requires the `MODERATE_MEMBERS` permission.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.Member</span>
<span class=sd>            Object of the member that was updated.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing a permission to do an action.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the user are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Edit a guild member.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to edit. This may be the object or the ID of an existing guild.<li><strong>user</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>]): The user to edit. This may be the object or the ID of an existing user.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><p><strong>nick</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[str]): If provided, the new nick for the member. If <code>None</code>, will remove the members nick.</p> <p>Requires the <code>MANAGE_NICKNAMES</code> permission.<li><p><strong>roles</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishSequence>hikari.snowflakes.SnowflakeishSequence</a>[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>]]): If provided, the new roles for the member.</p> <p>Requires the <code>MANAGE_ROLES</code> permission.<li><p><strong>mute</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, the new server mute state for the member.</p> <p>Requires the <code>MUTE_MEMBERS</code> permission.<li><p><strong>deaf</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, the new server deaf state for the member.</p> <p>Requires the <code>DEAFEN_MEMBERS</code> permission.<li><p><strong>voice_channel</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildVoiceChannel>hikari.channels.GuildVoiceChannel</a>]]]): If provided, <code>None</code> or the object or the ID of an existing voice channel to move the member to. If <code>None</code>, will disconnect the member from voice.</p> <p>Requires the <code>MOVE_MEMBERS</code> permission and the <code>CONNECT</code> permission in the original voice channel and the target voice channel.</p> <p><em>Note:</em> If the member is not in a voice channel, this will take no effect.<li><p><strong>communication_disabled_until</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[datetime.datetime]): If provided, the datetime when the timeout (disable communication) of the member expires, up to 28 days in the future, or <code>None</code> to remove the timeout from the member.</p> <p>Requires the <code>MODERATE_MEMBERS</code> permission.<li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../guilds.html#Member>hikari.guilds.Member</a></strong>: Object of the member that was updated.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing a permission to do an action.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild or the user are not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.edit_message><div class="attr function"><a class=headerlink href=#RESTClient.edit_message>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>edit_message</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   message: Union[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   content: Union[Any, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   *,<br>   attachment: Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   attachments: Union[Sequence[Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO]], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   component: Union[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   components: Union[Sequence[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   embed: Union[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   embeds: Union[Sequence[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   replace_attachments: bool = False,<br>   mentions_everyone: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   mentions_reply: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   user_mentions: Union[Sequence[Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]], bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   role_mentions: Union[Sequence[Union[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]], bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   flags: Union[<a href=../messages.html#MessageFlag>hikari.messages.MessageFlag</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../messages.html#Message>hikari.messages.Message</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
        <span class=n>content</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Any</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>attachment</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachments</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>component</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>components</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embed</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embeds</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>replace_attachments</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
        <span class=n>mentions_everyone</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mentions_reply</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>role_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>flags</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>MessageFlag</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Edit an existing message in a given channel.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            If the message was not sent by your user, the only parameter</span>
<span class=sd>            you may provide to this call is the `flags` parameter. Anything</span>
<span class=sd>            else will result in a `hikari.errors.ForbiddenError` being raised.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        Mentioning everyone, roles, or users in message edits currently</span>
<span class=sd>        will not send a push notification showing a new mention to people</span>
<span class=sd>        on Discord. It will still highlight in their chat as if they</span>
<span class=sd>        were mentioned, however.</span>

<span class=sd>        Also important to note that if you specify a text `content`, `mentions_everyone`,</span>
<span class=sd>        `mentions_reply`, `user_mentions`, and `role_mentions` will default</span>
<span class=sd>        to `False` as the message will be re-parsed for mentions. This will</span>
<span class=sd>        also occur if only one of the four are specified</span>

<span class=sd>        This is a limitation of Discord's design. If in doubt, specify all</span>
<span class=sd>        four of them each time.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to create the message in. This may be</span>
<span class=sd>            the object or the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to edit. This may be the object or the ID</span>
<span class=sd>            of an existing message.</span>
<span class=sd>        content : hikari.undefined.UndefinedOr[typing.Any]</span>
<span class=sd>            If provided, the message content to update with. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then the content will not</span>
<span class=sd>            be changed. If `None`, then the content will be removed.</span>

<span class=sd>            Any other value will be cast to a `str` before sending.</span>

<span class=sd>            If this is a `hikari.embeds.Embed` and neither the `embed` or</span>
<span class=sd>            `embeds` kwargs are provided or if this is a</span>
<span class=sd>            `hikari.files.Resourceish` and neither the</span>
<span class=sd>            `attachment` or `attachments` kwargs are provided, the values will</span>
<span class=sd>            be overwritten. This allows for simpler syntax when sending an</span>
<span class=sd>            embed or an attachment alone.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the attachment to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous attachment, if</span>
<span class=sd>            present, is not changed. If this is `None`, then the</span>
<span class=sd>            attachment is removed, if present. Otherwise, the new attachment</span>
<span class=sd>            that was provided will be attached.</span>
<span class=sd>        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]]</span>
<span class=sd>            If provided, the attachments to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous attachments, if</span>
<span class=sd>            present, are not changed. If this is `None`, then the</span>
<span class=sd>            attachments is removed, if present. Otherwise, the new attachments</span>
<span class=sd>            that were provided will be attached.</span>
<span class=sd>        component : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder]</span>
<span class=sd>            If provided, builder object of the component to set for this message.</span>
<span class=sd>            This component will replace any previously set components and passing</span>
<span class=sd>            `None` will remove all components.</span>
<span class=sd>        components : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]</span>
<span class=sd>            If provided, a sequence of the component builder objects set for</span>
<span class=sd>            this message. These components will replace any previously set</span>
<span class=sd>            components and passing `None` or an empty sequence will</span>
<span class=sd>            remove all components.</span>
<span class=sd>        embed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed]</span>
<span class=sd>            If provided, the embed to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.</span>
<span class=sd>            If this is `None` then any present embeds are removed.</span>
<span class=sd>            Otherwise, the new embed that was provided will be used as the</span>
<span class=sd>            replacement.</span>
<span class=sd>        embeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed]]</span>
<span class=sd>            If provided, the embeds to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.</span>
<span class=sd>            If this is `None` then any present embeds are removed.</span>
<span class=sd>            Otherwise, the new embeds that were provided will be used as the</span>
<span class=sd>            replacement.</span>
<span class=sd>        replace_attachments: bool</span>
<span class=sd>            Whether to replace the attachments with the provided ones. Defaults</span>
<span class=sd>            to `False`.</span>

<span class=sd>            Note this will also overwrite the embed attachments.</span>
<span class=sd>        mentions_everyone : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, sanitation for `@everyone` mentions. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then the previous setting is</span>
<span class=sd>            not changed. If `True`, then `@everyone`/`@here` mentions</span>
<span class=sd>            in the message content will show up as mentioning everyone that can</span>
<span class=sd>            view the chat.</span>
<span class=sd>        mentions_reply : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to mention the author of the message</span>
<span class=sd>            that is being replied to.</span>

<span class=sd>            This will not do anything if `message` is not a reply message.</span>
<span class=sd>        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], bool]]</span>
<span class=sd>            If provided, sanitation for user mentions. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then the previous setting is</span>
<span class=sd>            not changed. If `True`, all valid user mentions will behave</span>
<span class=sd>            as mentions. If `False`, all valid user mentions will not</span>
<span class=sd>            behave as mentions.</span>

<span class=sd>            You may alternatively pass a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake` user IDs, or</span>
<span class=sd>            `hikari.users.PartialUser`-derived objects.</span>
<span class=sd>        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], bool]]</span>
<span class=sd>            If provided, sanitation for role mentions. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then the previous setting is</span>
<span class=sd>            not changed. If `True`, all valid role mentions will behave</span>
<span class=sd>            as mentions. If `False`, all valid role mentions will not</span>
<span class=sd>            behave as mentions.</span>

<span class=sd>            You may alternatively pass a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake` role IDs, or</span>
<span class=sd>            `hikari.guilds.PartialRole`-derived objects.</span>
<span class=sd>        flags : hikari.undefined.UndefinedOr[hikari.messages.MessageFlag]</span>
<span class=sd>            If provided, optional flags to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then nothing is changed.</span>

<span class=sd>            Note that some flags may not be able to be set. Currently the only</span>
<span class=sd>            flags that can be set are `NONE` and `SUPPRESS_EMBEDS`. If you</span>
<span class=sd>            have `MANAGE_MESSAGES` permissions, you can use this call to</span>
<span class=sd>            suppress embeds on another user's message.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The edited message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        ValueError</span>
<span class=sd>            If both `attachment` and `attachments`, `component` and `components`</span>
<span class=sd>            or `embed` and `embeds` are specified.</span>
<span class=sd>        TypeError</span>
<span class=sd>            If `attachments`, `components` or `embeds` is passed but is not a</span>
<span class=sd>            sequence.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            This may be raised in several discrete situations, such as messages</span>
<span class=sd>            being empty with no embeds; messages with more than 2000 characters</span>
<span class=sd>            in them, embeds that exceed one of the many embed</span>
<span class=sd>            limits; invalid image URLs in embeds.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `SEND_MESSAGES` in the channel; if you try to</span>
<span class=sd>            change the contents of another user's message; or if you try to edit</span>
<span class=sd>            the flags on another user's message without the `MANAGE_MESSAGES`</span>
<span class=sd>            permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>
</pre></div></details><div class=docstring><p>Edit an existing message in a given channel.<p><em>Warning:</em> If the message was not sent by your user, the only parameter you may provide to this call is the <code>flags</code> parameter. Anything else will result in a <code><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></code> being raised.<h6 id=notes>Notes</h6><p>Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however.<p>Also important to note that if you specify a text <code>content</code>, <code>mentions_everyone</code>, <code>mentions_reply</code>, <code>user_mentions</code>, and <code>role_mentions</code> will default to <code>False</code> as the message will be re-parsed for mentions. This will also occur if only one of the four are specified<p>This is a limitation of Discord's design. If in doubt, specify all four of them each time.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>]): The channel to create the message in. This may be the object or the ID of an existing channel.<li><strong>message</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>]): The message to edit. This may be the object or the ID of an existing message.<li><p><strong>content</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Any]): If provided, the message content to update with. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, then the content will not be changed. If <code>None</code>, then the content will be removed.</p> <p>Any other value will be cast to a <code>str</code> before sending.</p> <p>If this is a <code><a href=../embeds.html#Embed>hikari.embeds.Embed</a></code> and neither the <code>embed</code> or <code>embeds</code> kwargs are provided or if this is a <code><a href=../files.html#Resourceish>hikari.files.Resourceish</a></code> and neither the <code>attachment</code> or <code>attachments</code> kwargs are provided, the values will be overwritten. This allows for simpler syntax when sending an embed or an attachment alone.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>attachment</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../files.html#Resourceish>hikari.files.Resourceish</a>]): If provided, the attachment to set on the message. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, the previous attachment, if present, is not changed. If this is <code>None</code>, then the attachment is removed, if present. Otherwise, the new attachment that was provided will be attached.<li><strong>attachments</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Sequence[<a href=../files.html#Resourceish>hikari.files.Resourceish</a>]]): If provided, the attachments to set on the message. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, the previous attachments, if present, are not changed. If this is <code>None</code>, then the attachments is removed, if present. Otherwise, the new attachments that were provided will be attached.<li><strong>component</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>]): If provided, builder object of the component to set for this message. This component will replace any previously set components and passing <code>None</code> will remove all components.<li><strong>components</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[typing.Sequence[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>]]): If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing <code>None</code> or an empty sequence will remove all components.<li><strong>embed</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>]): If provided, the embed to set on the message. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, the previous embed(s) are not changed. If this is <code>None</code> then any present embeds are removed. Otherwise, the new embed that was provided will be used as the replacement.<li><strong>embeds</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[typing.Sequence[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>]]): If provided, the embeds to set on the message. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, the previous embed(s) are not changed. If this is <code>None</code> then any present embeds are removed. Otherwise, the new embeds that were provided will be used as the replacement.<li><p><strong>replace_attachments</strong> (bool): Whether to replace the attachments with the provided ones. Defaults to <code>False</code>.</p> <p>Note this will also overwrite the embed attachments.<li><strong>mentions_everyone</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, sanitation for <code>@everyone</code> mentions. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, then the previous setting is not changed. If <code>True</code>, then <code>@everyone</code>/<code>@here</code> mentions in the message content will show up as mentioning everyone that can view the chat.<li><p><strong>mentions_reply</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, whether to mention the author of the message that is being replied to.</p> <p>This will not do anything if <code>message</code> is not a reply message.<li><p><strong>user_mentions</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Union[<a href=../snowflakes.html#SnowflakeishSequence>hikari.snowflakes.SnowflakeishSequence</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>], bool]]): If provided, sanitation for user mentions. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, then the previous setting is not changed. If <code>True</code>, all valid user mentions will behave as mentions. If <code>False</code>, all valid user mentions will not behave as mentions.</p> <p>You may alternatively pass a collection of <code><a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a></code> user IDs, or <code><a href=../users.html#PartialUser>hikari.users.PartialUser</a></code>-derived objects.<li><p><strong>role_mentions</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Union[<a href=../snowflakes.html#SnowflakeishSequence>hikari.snowflakes.SnowflakeishSequence</a>[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>], bool]]): If provided, sanitation for role mentions. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, then the previous setting is not changed. If <code>True</code>, all valid role mentions will behave as mentions. If <code>False</code>, all valid role mentions will not behave as mentions.</p> <p>You may alternatively pass a collection of <code><a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a></code> role IDs, or <code><a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a></code>-derived objects.<li><p><strong>flags</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../messages.html#MessageFlag>hikari.messages.MessageFlag</a>]): If provided, optional flags to set on the message. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, then nothing is changed.</p> <p>Note that some flags may not be able to be set. Currently the only flags that can be set are <code>NONE</code> and <code>SUPPRESS_EMBEDS</code>. If you have <code>MANAGE_MESSAGES</code> permissions, you can use this call to suppress embeds on another user's message.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../messages.html#Message>hikari.messages.Message</a></strong>: The edited message.</ul><h6 id=raises>Raises</h6><ul><li><strong>ValueError</strong>: If both <code>attachment</code> and <code>attachments</code>, <code>component</code> and <code>components</code> or <code>embed</code> and <code>embeds</code> are specified.<li><strong>TypeError</strong>: If <code>attachments</code>, <code>components</code> or <code>embeds</code> is passed but is not a sequence.<li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: This may be raised in several discrete situations, such as messages being empty with no embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; invalid image URLs in embeds.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>SEND_MESSAGES</code> in the channel; if you try to change the contents of another user's message; or if you try to edit the flags on another user's message without the <code>MANAGE_MESSAGES</code> permission.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel or message is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.edit_my_member><div class="attr function"><a class=headerlink href=#RESTClient.edit_my_member>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>edit_my_member</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   nickname: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../guilds.html#Member>hikari.guilds.Member</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_my_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>nickname</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>Member</span><span class=p>:</span>
        <span class=sd>"""Edit the current user's member in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit the member in. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        nickname : hikari.undefined.UndefinedNoneOr[str]</span>
<span class=sd>            If provided, the new nickname for the member. If</span>
<span class=sd>            `None`, will remove the members nickname.</span>

<span class=sd>            Requires the `CHANGE_NICKNAME` permission.</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.Member</span>
<span class=sd>            Object of the member that was updated.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing a permission to do an action.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Edit the current user's member in a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to edit the member in. This may be the object or the ID of an existing guild.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><p><strong>nickname</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[str]): If provided, the new nickname for the member. If <code>None</code>, will remove the members nickname.</p> <p>Requires the <code>CHANGE_NICKNAME</code> permission. If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../guilds.html#Member>hikari.guilds.Member</a></strong>: Object of the member that was updated.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing a permission to do an action.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.edit_my_nick><div class="attr function"><a class=headerlink href=#RESTClient.edit_my_nick>#  </a><div class=decorator>@deprecation.deprecated('2.0.0.dev104', "Use `edit_my_member`'s `nick` argument instead.")</div><div class=decorator>@abc.abstractmethod</div><span class=def>def </span><span class=name>edit_my_nick</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#Guild>hikari.guilds.Guild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   nick: Optional[str],<br>   *,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@deprecation</span><span class=o>.</span><span class=n>deprecated</span><span class=p>(</span><span class=s2>"2.0.0.dev104"</span><span class=p>,</span> <span class=s2>"Use `edit_my_member`'s `nick` argument instead."</span><span class=p>)</span>
    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_my_nick</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>Guild</span><span class=p>],</span>
        <span class=n>nick</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=nb>str</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Edit the associated token's member nick.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>
<span class=sd>        nick : typing.Optional[str]</span>
<span class=sd>            The new nick. If `None`,</span>
<span class=sd>            will remove the nick.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `CHANGE_NICKNAME` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Edit the associated token's member nick.<p><em>Deprecated since version 2.0.0.dev104:</em> Use <code><a href=#RESTClient.edit_my_member>edit_my_member</a></code>'s <code>nick</code> argument instead.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to edit. This may be the object or the ID of an existing guild.<li><strong>nick</strong> (typing.Optional[str]): The new nick. If <code>None</code>, will remove the nick.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>CHANGE_NICKNAME</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.edit_my_user><div class="attr function"><a class=headerlink href=#RESTClient.edit_my_user>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>edit_my_user</span><span class=signature>(<br>   self,<br>   *,<br>   username: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   avatar: Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED<br>) -> <a href=../users.html#OwnUser>hikari.users.OwnUser</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_my_user</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>username</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>avatar</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>users</span><span class=o>.</span><span class=n>OwnUser</span><span class=p>:</span>
        <span class=sd>"""Edit the token's associated user.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        username : undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new username.</span>
<span class=sd>        avatar : undefined.UndefinedNoneOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the new avatar. If `None`,</span>
<span class=sd>            the avatar will be removed.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.users.OwnUser</span>
<span class=sd>            The edited token's associated user.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>

<span class=sd>            Discord also returns this on a rate limit:</span>
<span class=sd>            &LThttps://github.com/discord/discord-api-docs/issues/1462></span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Edit the token's associated user.<h6 id=other-parameters>Other Parameters</h6><ul><li><strong>username</strong> (undefined.UndefinedOr[str]): If provided, the new username.<li><strong>avatar</strong> (undefined.UndefinedNoneOr[<a href=../files.html#Resourceish>hikari.files.Resourceish</a>]): If provided, the new avatar. If <code>None</code>, the avatar will be removed.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../users.html#OwnUser>hikari.users.OwnUser</a></strong>: The edited token's associated user.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.</ul><p>Discord also returns this on a rate limit: <a href=https://github.com/discord/discord-api-docs/issues/1462>https://github.com/discord/discord-api-docs/issues/1462</a><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.edit_my_voice_state><div class="attr function"><a class=headerlink href=#RESTClient.edit_my_voice_state>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>edit_my_voice_state</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   channel: Union[<a href=../channels.html#GuildStageChannel>hikari.channels.GuildStageChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   suppress: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   request_to_speak: Union[<a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, bool, datetime.datetime] = UNDEFINED<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_my_voice_state</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildStageChannel</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>suppress</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>request_to_speak</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedType</span><span class=p>,</span> <span class=nb>bool</span><span class=p>,</span> <span class=n>datetime</span><span class=o>.</span><span class=n>datetime</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Edit the current user's voice state in a stage channel.</span>

<span class=sd>        .. note::</span>
<span class=sd>            The current user has to have already joined the target stage channel</span>
<span class=sd>            before any calls can be made to this endpoint.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or Id of the guild to edit a voice state in.</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildStageChannel]</span>
<span class=sd>            Object or Id of the channel to edit a voice state in.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        suppress : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If specified, whether the user should be allowed to become a speaker</span>
<span class=sd>            in the target stage channel with `builtin.True` suppressing them from</span>
<span class=sd>            becoming one.</span>
<span class=sd>        request_to_speak : typing.Union[hikari.undefined.UndefinedType, bool, datetime.datetime]</span>
<span class=sd>            Whether to request to speak. This may be one of the following:</span>

<span class=sd>            * `True` to indicate that the bot wants to speak.</span>
<span class=sd>            * `False` to remove any previously set request to speak.</span>
<span class=sd>            * `datetime.datetime` to specify when they want their request to</span>
<span class=sd>                speak timestamp to be set to. If a datetime from the past is</span>
<span class=sd>                passed then Discord will use the current time instead.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If you try to target a non-staging channel.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MUTE_MEMBERS` permission in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel, message or voice state is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Edit the current user's voice state in a stage channel.<p><em>Note:</em> The current user has to have already joined the target stage channel before any calls can be made to this endpoint.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): Object or Id of the guild to edit a voice state in.<li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildStageChannel>hikari.channels.GuildStageChannel</a>]): Object or Id of the channel to edit a voice state in.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>suppress</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If specified, whether the user should be allowed to become a speaker in the target stage channel with <code>builtin.True</code> suppressing them from becoming one.<li><p><strong>request_to_speak</strong> (typing.Union[<a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, bool, datetime.datetime]): Whether to request to speak. This may be one of the following:</p> <ul><li><code>True</code> to indicate that the bot wants to speak.<li><code>False</code> to remove any previously set request to speak.<li><code>datetime.datetime</code> to specify when they want their request to speak timestamp to be set to. If a datetime from the past is passed then Discord will use the current time instead.</ul></ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If you try to target a non-staging channel.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MUTE_MEMBERS</code> permission in the channel.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel, message or voice state is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.edit_permission_overwrites><div class="attr function"><a class=headerlink href=#RESTClient.edit_permission_overwrites>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>edit_permission_overwrites</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#GuildChannel>hikari.channels.GuildChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   target: Union[<a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>, <a href=../channels.html#PermissionOverwrite>hikari.channels.PermissionOverwrite</a>],<br>   *,<br>   target_type: Union[<a href=../channels.html#PermissionOverwriteType>hikari.channels.PermissionOverwriteType</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   allow: Union[<a href=../permissions.html#Permissions>hikari.permissions.Permissions</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   deny: Union[<a href=../permissions.html#Permissions>hikari.permissions.Permissions</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_permission_overwrites</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>],</span>
        <span class=n>target</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>Snowflakeish</span><span class=p>,</span> <span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>,</span> <span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>,</span> <span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwrite</span>
        <span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>target_type</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PermissionOverwriteType</span><span class=p>,</span> <span class=nb>int</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>allow</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>permissions_</span><span class=o>.</span><span class=n>Permissions</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>deny</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>permissions_</span><span class=o>.</span><span class=n>Permissions</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Edit permissions for a specific entity in the given guild channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]</span>
<span class=sd>            The channel to edit a permission overwrite in. This may be the</span>
<span class=sd>            object, or the ID of an existing channel.</span>
<span class=sd>        target : typing.Union[hikari.users.PartialUser, hikari.guilds.PartialRole, hikari.channels.PermissionOverwrite, hikari.snowflakes.Snowflakeish]</span>
<span class=sd>            The channel overwrite to edit. This may be the object or the ID of an</span>
<span class=sd>            existing overwrite.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        target_type : hikari.undefined.UndefinedOr[typing.Union[hikari.channels.PermissionOverwriteType, int]]</span>
<span class=sd>            If provided, the type of the target to update. If unset, will attempt to get</span>
<span class=sd>            the type from `target`.</span>
<span class=sd>        allow : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]</span>
<span class=sd>            If provided, the new vale of all allowed permissions.</span>
<span class=sd>        deny : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]</span>
<span class=sd>            If provided, the new vale of all disallowed permissions.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        TypeError</span>
<span class=sd>            If `target_type` is unset and we were unable to determine the type</span>
<span class=sd>            from `target`.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_PERMISSIONS` permission in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found or the target is not found if it is</span>
<span class=sd>            a role.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>
</pre></div></details><div class=docstring><p>Edit permissions for a specific entity in the given guild channel.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildChannel>hikari.channels.GuildChannel</a>]): The channel to edit a permission overwrite in. This may be the object, or the ID of an existing channel.<li><strong>target</strong> (typing.Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>, <a href=../channels.html#PermissionOverwrite>hikari.channels.PermissionOverwrite</a>, <a href=../snowflakes.html#Snowflakeish>hikari.snowflakes.Snowflakeish</a>]): The channel overwrite to edit. This may be the object or the ID of an existing overwrite.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>target_type</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Union[<a href=../channels.html#PermissionOverwriteType>hikari.channels.PermissionOverwriteType</a>, int]]): If provided, the type of the target to update. If unset, will attempt to get the type from <code>target</code>.<li><strong>allow</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../permissions.html#Permissions>hikari.permissions.Permissions</a>]): If provided, the new vale of all allowed permissions.<li><strong>deny</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../permissions.html#Permissions>hikari.permissions.Permissions</a>]): If provided, the new vale of all disallowed permissions.<li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=raises>Raises</h6><ul><li><strong>TypeError</strong>: If <code>target_type</code> is unset and we were unable to determine the type from <code>target</code>.<li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_PERMISSIONS</code> permission in the channel.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel is not found or the target is not found if it is a role.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.edit_role><div class="attr function"><a class=headerlink href=#RESTClient.edit_role>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>edit_role</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   role: Union[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   name: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   permissions: Union[<a href=../permissions.html#Permissions>hikari.permissions.Permissions</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   color: Union[<a href=../colors.html#Color>hikari.colors.Color</a>, SupportsInt, Tuple[SupportsInt, SupportsInt, SupportsInt], Tuple[SupportsFloat, SupportsFloat, SupportsFloat], Sequence[SupportsInt], Sequence[SupportsFloat], str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   colour: Union[<a href=../colors.html#Color>hikari.colors.Color</a>, SupportsInt, Tuple[SupportsInt, SupportsInt, SupportsInt], Tuple[SupportsFloat, SupportsFloat, SupportsFloat], Sequence[SupportsInt], Sequence[SupportsFloat], str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   hoist: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   icon: Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   unicode_emoji: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   mentionable: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../guilds.html#Role>hikari.guilds.Role</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_role</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>role</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>permissions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>permissions_</span><span class=o>.</span><span class=n>Permissions</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>color</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>colors</span><span class=o>.</span><span class=n>Colorish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>colour</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>colors</span><span class=o>.</span><span class=n>Colorish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>hoist</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>icon</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>unicode_emoji</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mentionable</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>Role</span><span class=p>:</span>
        <span class=sd>"""Edit a role.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit the role in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]</span>
<span class=sd>            The role to edit. This may be the object or the</span>
<span class=sd>            ID of an existing role.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new name for the role.</span>
<span class=sd>        permissions : hikari.undefined.UndefinedOr[hikari.permissions.Permissions]</span>
<span class=sd>            If provided, the new permissions for the role.</span>
<span class=sd>        color : hikari.undefined.UndefinedOr[hikari.colors.Colorish]</span>
<span class=sd>            If provided, the new color for the role.</span>
<span class=sd>        colour : hikari.undefined.UndefinedOr[hikari.colors.Colorish]</span>
<span class=sd>            An alias for `color`.</span>
<span class=sd>        hoist : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to hoist the role.</span>
<span class=sd>        icon : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the new role icon. Must be a 64x64 image</span>
<span class=sd>            under 256kb.</span>
<span class=sd>        unicode_emoji : hikari.undefined.UndefinedNoneOr[str]</span>
<span class=sd>            If provided, the new unicode emoji to set as the role icon.</span>
<span class=sd>        mentionable : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to make the role mentionable.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.Role</span>
<span class=sd>            The edited role.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        TypeError</span>
<span class=sd>            If both `color` and `colour` are specified or if both `icon` and</span>
<span class=sd>            `unicode_emoji` are specified.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_ROLES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or role are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Edit a role.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to edit the role in. This may be the object or the ID of an existing guild.<li><strong>role</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>]): The role to edit. This may be the object or the ID of an existing role.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>name</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the new name for the role.<li><strong>permissions</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../permissions.html#Permissions>hikari.permissions.Permissions</a>]): If provided, the new permissions for the role.<li><strong>color</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../colors.html#Colorish>hikari.colors.Colorish</a>]): If provided, the new color for the role.<li><strong>colour</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../colors.html#Colorish>hikari.colors.Colorish</a>]): An alias for <code>color</code>.<li><strong>hoist</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, whether to hoist the role.<li><strong>icon</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[<a href=../files.html#Resourceish>hikari.files.Resourceish</a>]): If provided, the new role icon. Must be a 64x64 image under 256kb.<li><strong>unicode_emoji</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[str]): If provided, the new unicode emoji to set as the role icon.<li><strong>mentionable</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, whether to make the role mentionable.<li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../guilds.html#Role>hikari.guilds.Role</a></strong>: The edited role.</ul><h6 id=raises>Raises</h6><ul><li><strong>TypeError</strong>: If both <code>color</code> and <code>colour</code> are specified or if both <code>icon</code> and <code>unicode_emoji</code> are specified.<li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_ROLES</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild or role are not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.edit_sticker><div class="attr function"><a class=headerlink href=#RESTClient.edit_sticker>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>edit_sticker</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   sticker: Union[<a href=../stickers.html#PartialSticker>hikari.stickers.PartialSticker</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   name: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   description: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   tag: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../stickers.html#GuildSticker>hikari.stickers.GuildSticker</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_sticker</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>sticker</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>stickers</span><span class=o>.</span><span class=n>PartialSticker</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>tag</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>stickers</span><span class=o>.</span><span class=n>GuildSticker</span><span class=p>:</span>
        <span class=sd>"""Edit a sticker in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit the sticker on. This can be a guild object or the</span>
<span class=sd>            ID of an existing guild.</span>
<span class=sd>        sticker : hikari.snowflakes.SnowflakeishOr[hikari.stickers.PartialSticker]</span>
<span class=sd>            The sticker to edit. This can be a sticker object or the ID of an</span>
<span class=sd>            existing sticker.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new name for the sticker.</span>
<span class=sd>        description : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new description for the sticker.</span>
<span class=sd>        tag : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new sticker tag.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.stickers.GuildSticker</span>
<span class=sd>            The edited sticker.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing `MANAGE_EMOJIS_AND_STICKERS` in the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the sticker are not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Edit a sticker in a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to edit the sticker on. This can be a guild object or the ID of an existing guild.<li><strong>sticker</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../stickers.html#PartialSticker>hikari.stickers.PartialSticker</a>]): The sticker to edit. This can be a sticker object or the ID of an existing sticker.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>name</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the new name for the sticker.<li><strong>description</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the new description for the sticker.<li><strong>tag</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the new sticker tag.<li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../stickers.html#GuildSticker>hikari.stickers.GuildSticker</a></strong>: The edited sticker.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing <code>MANAGE_EMOJIS_AND_STICKERS</code> in the server.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild or the sticker are not found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.edit_template><div class="attr function"><a class=headerlink href=#RESTClient.edit_template>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>edit_template</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   template: Union[<a href=../templates.html#Template>hikari.templates.Template</a>, str],<br>   *,<br>   name: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   description: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED<br>) -> <a href=../templates.html#Template>hikari.templates.Template</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_template</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>template</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>,</span> <span class=nb>str</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>:</span>
        <span class=sd>"""Modify a guild template.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit a template in.</span>
<span class=sd>        template : typing.Union[str, hikari.templates.Template]</span>
<span class=sd>            Object or string code of the template to modify.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            The name to set for this template.</span>
<span class=sd>        description : hikari.undefined.UndefinedNoneOr[str]</span>
<span class=sd>            The description to set for the template.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.templates.Template</span>
<span class=sd>            The object of the edited template.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found or you are missing the `MANAGE_GUILD`</span>
<span class=sd>            permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Modify a guild template.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to edit a template in.<li><strong>template</strong> (typing.Union[str, <a href=../templates.html#Template>hikari.templates.Template</a>]): Object or string code of the template to modify.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>name</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): The name to set for this template.<li><strong>description</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[str]): The description to set for the template.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../templates.html#Template>hikari.templates.Template</a></strong>: The object of the edited template.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are not part of the guild.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found or you are missing the <code>MANAGE_GUILD</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.edit_voice_state><div class="attr function"><a class=headerlink href=#RESTClient.edit_voice_state>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>edit_voice_state</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   channel: Union[<a href=../channels.html#GuildStageChannel>hikari.channels.GuildStageChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   user: Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   suppress: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_voice_state</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildStageChannel</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>suppress</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Edit an existing voice state in a stage channel.</span>

<span class=sd>        .. note::</span>
<span class=sd>            The target user must already be present in the stage channel before</span>
<span class=sd>            any calls are made to this endpoint.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or Id of the guild to edit a voice state in.</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildStageChannel]</span>
<span class=sd>            Object or Id of the channel to edit a voice state in.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            Object or Id of the user to to edit the voice state of.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        suppress : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If defined, whether the user should be allowed to become a speaker</span>
<span class=sd>            in the target stage channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If you try to target a non-staging channel.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MUTE_MEMBERS` permission in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel, message or voice state is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Edit an existing voice state in a stage channel.<p><em>Note:</em> The target user must already be present in the stage channel before any calls are made to this endpoint.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): Object or Id of the guild to edit a voice state in.<li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildStageChannel>hikari.channels.GuildStageChannel</a>]): Object or Id of the channel to edit a voice state in.<li><strong>user</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>]): Object or Id of the user to to edit the voice state of.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>suppress</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If defined, whether the user should be allowed to become a speaker in the target stage channel.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If you try to target a non-staging channel.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MUTE_MEMBERS</code> permission in the channel.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel, message or voice state is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.edit_webhook><div class="attr function"><a class=headerlink href=#RESTClient.edit_webhook>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>edit_webhook</span><span class=signature>(<br>   self,<br>   webhook: Union[<a href=../webhooks.html#PartialWebhook>hikari.webhooks.PartialWebhook</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   token: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   name: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   avatar: Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   channel: Union[<a href=../channels.html#GuildTextChannel>hikari.channels.GuildTextChannel</a>, <a href=../channels.html#GuildNewsChannel>hikari.channels.GuildNewsChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../webhooks.html#PartialWebhook>hikari.webhooks.PartialWebhook</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_webhook</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>webhook</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>PartialWebhook</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>token</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>avatar</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>WebhookChannelT</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>webhooks</span><span class=o>.</span><span class=n>PartialWebhook</span><span class=p>:</span>
        <span class=sd>"""Edit a webhook.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.PartialWebhook]</span>
<span class=sd>            The webhook to edit. This may be the object or the</span>
<span class=sd>            ID of an existing webhook.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        token : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the webhoook token that will be used to edit</span>
<span class=sd>            the webhook instead of the token the client was initialized with.</span>
<span class=sd>        name : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the new webhook name.</span>
<span class=sd>        avatar : hikari.undefined.UndefinedNoneOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the new webhook avatar. If `None`, will</span>
<span class=sd>            remove the webhook avatar.</span>
<span class=sd>        channel : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT]]</span>
<span class=sd>            If provided, the text channel to move the webhook to.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.webhooks.PartialWebhook</span>
<span class=sd>            The edited webhook.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_WEBHOOKS` permission when not</span>
<span class=sd>            using a token.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the webhook is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Edit a webhook.<h6 id=parameters>Parameters</h6><ul><li><strong>webhook</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../webhooks.html#PartialWebhook>hikari.webhooks.PartialWebhook</a>]): The webhook to edit. This may be the object or the ID of an existing webhook.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>token</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the webhoook token that will be used to edit the webhook instead of the token the client was initialized with.<li><strong>name</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the new webhook name.<li><strong>avatar</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[<a href=../files.html#Resourceish>hikari.files.Resourceish</a>]): If provided, the new webhook avatar. If <code>None</code>, will remove the webhook avatar.<li><strong>channel</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#WebhookChannelT>hikari.channels.WebhookChannelT</a>]]): If provided, the text channel to move the webhook to.<li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../webhooks.html#PartialWebhook>hikari.webhooks.PartialWebhook</a></strong>: The edited webhook.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_WEBHOOKS</code> permission when not using a token.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the webhook is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.edit_webhook_message><div class="attr function"><a class=headerlink href=#RESTClient.edit_webhook_message>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>edit_webhook_message</span><span class=signature>(<br>   self,<br>   webhook: Union[<a href=../webhooks.html#ExecutableWebhook>hikari.webhooks.ExecutableWebhook</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   token: str,<br>   message: Union[<a href=../messages.html#Message>hikari.messages.Message</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   content: Union[Any, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   *,<br>   attachment: Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   attachments: Union[Sequence[Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO]], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   component: Union[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   components: Union[Sequence[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   embed: Union[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   embeds: Union[Sequence[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   replace_attachments: bool = False,<br>   mentions_everyone: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   user_mentions: Union[Sequence[Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]], bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   role_mentions: Union[Sequence[Union[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]], bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../messages.html#Message>hikari.messages.Message</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_webhook_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=c1># MyPy might not say this but SnowflakeishOr[ExecutableWebhook] isn't valid as ExecutableWebhook isn't Unique</span>
        <span class=n>webhook</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>ExecutableWebhook</span><span class=p>,</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>Snowflakeish</span><span class=p>],</span>
        <span class=n>token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>],</span>
        <span class=n>content</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Any</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>attachment</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachments</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>component</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>components</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embed</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embeds</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>replace_attachments</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
        <span class=n>mentions_everyone</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>role_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Edit a message sent by a webhook.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        Mentioning everyone, roles, or users in message edits currently</span>
<span class=sd>        will not send a push notification showing a new mention to people</span>
<span class=sd>        on Discord. It will still highlight in their chat as if they</span>
<span class=sd>        were mentioned, however.</span>

<span class=sd>        Also important to note that if you specify a text `content`, `mentions_everyone`,</span>
<span class=sd>        `mentions_reply`, `user_mentions`, and `role_mentions` will default</span>
<span class=sd>        to `False` as the message will be re-parsed for mentions. This will</span>
<span class=sd>        also occur if only one of the four are specified</span>

<span class=sd>        This is a limitation of Discord's design. If in doubt, specify all</span>
<span class=sd>        four of them each time.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        webhook : typing.Union[hikari.snowflakes.Snowflakeish, hikari.webhooks.ExecutableWebhook]</span>
<span class=sd>            The webhook to execute. This may be the object</span>
<span class=sd>            or the ID of an existing webhook.</span>
<span class=sd>        token: str</span>
<span class=sd>            The webhook token.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete. This may be the object or the ID of</span>
<span class=sd>            an existing message.</span>
<span class=sd>        content : hikari.undefined.UndefinedOr[typing.Any]</span>
<span class=sd>            If provided, the message content to update with. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then the content will not</span>
<span class=sd>            be changed. If `None`, then the content will be removed.</span>

<span class=sd>            Any other value will be cast to a `str` before sending.</span>

<span class=sd>            If this is a `hikari.embeds.Embed` and neither the</span>
<span class=sd>            `embed` or `embeds` kwargs are provided or if this is a</span>
<span class=sd>            `hikari.files.Resourceish` and neither the `attachment` or</span>
<span class=sd>            `attachments` kwargs are provided, the values will be overwritten.</span>
<span class=sd>            This allows for simpler syntax when sending an embed or an</span>
<span class=sd>            attachment alone.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish]</span>
<span class=sd>            If provided, the attachment to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous attachment, if</span>
<span class=sd>            present, is not changed. If this is `None`, then the</span>
<span class=sd>            attachment is removed, if present. Otherwise, the new attachment</span>
<span class=sd>            that was provided will be attached.</span>
<span class=sd>        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]]</span>
<span class=sd>            If provided, the attachments to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous attachments, if</span>
<span class=sd>            present, are not changed. If this is `None`, then the</span>
<span class=sd>            attachments is removed, if present. Otherwise, the new attachments</span>
<span class=sd>            that were provided will be attached.</span>
<span class=sd>        component : hikari.undefined.UndefinedNoneOr[hikari.api.special_endpoints.ComponentBuilder]</span>
<span class=sd>            If provided, builder object of the component to set for this message.</span>
<span class=sd>            This component will replace any previously set components and passing</span>
<span class=sd>            `None` will remove all components.</span>
<span class=sd>        components : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]</span>
<span class=sd>            If provided, a sequence of the component builder objects set for</span>
<span class=sd>            this message. These components will replace any previously set</span>
<span class=sd>            components and passing `None` or an empty sequence will</span>
<span class=sd>            remove all components.</span>
<span class=sd>        embed : hikari.undefined.UndefinedNoneOr[hikari.embeds.Embed]</span>
<span class=sd>            If provided, the embed to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.</span>
<span class=sd>            If this is `None` then any present embeds are removed.</span>
<span class=sd>            Otherwise, the new embed that was provided will be used as the</span>
<span class=sd>            replacement.</span>
<span class=sd>        embeds : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.embeds.Embed]]</span>
<span class=sd>            If provided, the embeds to set on the message. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, the previous embed(s) are not changed.</span>
<span class=sd>            If this is `None` then any present embeds are removed.</span>
<span class=sd>            Otherwise, the new embeds that were provided will be used as the</span>
<span class=sd>            replacement.</span>
<span class=sd>        replace_attachments: bool</span>
<span class=sd>            Whether to replace the attachments with the provided ones. Defaults</span>
<span class=sd>            to `False`.</span>

<span class=sd>            Note this will also overwrite the embed attachments.</span>
<span class=sd>        mentions_everyone : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, sanitation for `@everyone` mentions. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then the previous setting is</span>
<span class=sd>            not changed. If `True`, then `@everyone`/`@here` mentions</span>
<span class=sd>            in the message content will show up as mentioning everyone that can</span>
<span class=sd>            view the chat.</span>
<span class=sd>        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], bool]]</span>
<span class=sd>            If provided, and `True`, all user mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all user mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.users.PartialUser` derivatives to enforce mentioning</span>
<span class=sd>            specific users.</span>
<span class=sd>        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], bool]]</span>
<span class=sd>            If provided, and `True`, all role mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all role mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.guilds.PartialRole` derivatives to enforce mentioning</span>
<span class=sd>            specific roles.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The edited message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        ValueError</span>
<span class=sd>            If both `attachment` and `attachments`, `component` and `components`</span>
<span class=sd>            or `embed` and `embeds` are specified.</span>
<span class=sd>        TypeError</span>
<span class=sd>            If `attachments`, `components` or `embeds` is passed but is not a</span>
<span class=sd>            sequence.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            This may be raised in several discrete situations, such as messages</span>
<span class=sd>            being empty with no attachments or embeds; messages with more than</span>
<span class=sd>            2000 characters in them, embeds that exceed one of the many embed</span>
<span class=sd>            limits; too many attachments; attachments that are too large;</span>
<span class=sd>            invalid image URLs in embeds; too many components.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the webhook or the message are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>
</pre></div></details><div class=docstring><p>Edit a message sent by a webhook.<h6 id=notes>Notes</h6><p>Mentioning everyone, roles, or users in message edits currently will not send a push notification showing a new mention to people on Discord. It will still highlight in their chat as if they were mentioned, however.<p>Also important to note that if you specify a text <code>content</code>, <code>mentions_everyone</code>, <code>mentions_reply</code>, <code>user_mentions</code>, and <code>role_mentions</code> will default to <code>False</code> as the message will be re-parsed for mentions. This will also occur if only one of the four are specified<p>This is a limitation of Discord's design. If in doubt, specify all four of them each time.<h6 id=parameters>Parameters</h6><ul><li><strong>webhook</strong> (typing.Union[<a href=../snowflakes.html#Snowflakeish>hikari.snowflakes.Snowflakeish</a>, <a href=../webhooks.html#ExecutableWebhook>hikari.webhooks.ExecutableWebhook</a>]): The webhook to execute. This may be the object or the ID of an existing webhook.<li><strong>token</strong> (str): The webhook token.<li><strong>message</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>]): The message to delete. This may be the object or the ID of an existing message.<li><p><strong>content</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Any]): If provided, the message content to update with. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, then the content will not be changed. If <code>None</code>, then the content will be removed.</p> <p>Any other value will be cast to a <code>str</code> before sending.</p> <p>If this is a <code><a href=../embeds.html#Embed>hikari.embeds.Embed</a></code> and neither the <code>embed</code> or <code>embeds</code> kwargs are provided or if this is a <code><a href=../files.html#Resourceish>hikari.files.Resourceish</a></code> and neither the <code>attachment</code> or <code>attachments</code> kwargs are provided, the values will be overwritten. This allows for simpler syntax when sending an embed or an attachment alone.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>attachment</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../files.html#Resourceish>hikari.files.Resourceish</a>]): If provided, the attachment to set on the message. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, the previous attachment, if present, is not changed. If this is <code>None</code>, then the attachment is removed, if present. Otherwise, the new attachment that was provided will be attached.<li><strong>attachments</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Sequence[<a href=../files.html#Resourceish>hikari.files.Resourceish</a>]]): If provided, the attachments to set on the message. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, the previous attachments, if present, are not changed. If this is <code>None</code>, then the attachments is removed, if present. Otherwise, the new attachments that were provided will be attached.<li><strong>component</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>]): If provided, builder object of the component to set for this message. This component will replace any previously set components and passing <code>None</code> will remove all components.<li><strong>components</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[typing.Sequence[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>]]): If provided, a sequence of the component builder objects set for this message. These components will replace any previously set components and passing <code>None</code> or an empty sequence will remove all components.<li><strong>embed</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>]): If provided, the embed to set on the message. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, the previous embed(s) are not changed. If this is <code>None</code> then any present embeds are removed. Otherwise, the new embed that was provided will be used as the replacement.<li><strong>embeds</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[typing.Sequence[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>]]): If provided, the embeds to set on the message. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, the previous embed(s) are not changed. If this is <code>None</code> then any present embeds are removed. Otherwise, the new embeds that were provided will be used as the replacement.<li><p><strong>replace_attachments</strong> (bool): Whether to replace the attachments with the provided ones. Defaults to <code>False</code>.</p> <p>Note this will also overwrite the embed attachments.<li><strong>mentions_everyone</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, sanitation for <code>@everyone</code> mentions. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, then the previous setting is not changed. If <code>True</code>, then <code>@everyone</code>/<code>@here</code> mentions in the message content will show up as mentioning everyone that can view the chat.<li><strong>user_mentions</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Union[<a href=../snowflakes.html#SnowflakeishSequence>hikari.snowflakes.SnowflakeishSequence</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>], bool]]): If provided, and <code>True</code>, all user mentions will be detected. If provided, and <code>False</code>, all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of <code><a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a></code>, or <code><a href=../users.html#PartialUser>hikari.users.PartialUser</a></code> derivatives to enforce mentioning specific users.<li><strong>role_mentions</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Union[<a href=../snowflakes.html#SnowflakeishSequence>hikari.snowflakes.SnowflakeishSequence</a>[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>], bool]]): If provided, and <code>True</code>, all role mentions will be detected. If provided, and <code>False</code>, all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of <code><a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a></code>, or <code><a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a></code> derivatives to enforce mentioning specific roles.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../messages.html#Message>hikari.messages.Message</a></strong>: The edited message.</ul><h6 id=raises>Raises</h6><ul><li><strong>ValueError</strong>: If both <code>attachment</code> and <code>attachments</code>, <code>component</code> and <code>components</code> or <code>embed</code> and <code>embeds</code> are specified.<li><strong>TypeError</strong>: If <code>attachments</code>, <code>components</code> or <code>embeds</code> is passed but is not a sequence.<li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the webhook or the message are not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.edit_welcome_screen><div class="attr function"><a class=headerlink href=#RESTClient.edit_welcome_screen>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>edit_welcome_screen</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   description: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   enabled: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   channels: Union[Sequence[<a href=../guilds.html#WelcomeChannel>hikari.guilds.WelcomeChannel</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED<br>) -> <a href=../guilds.html#WelcomeScreen>hikari.guilds.WelcomeScreen</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_welcome_screen</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>enabled</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>channels</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>WelcomeChannel</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>WelcomeScreen</span><span class=p>:</span>
        <span class=sd>"""Edit the welcome screen of a community guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            ID or object of the guild to edit the welcome screen for.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        description : undefined.UndefinedNoneOr[str]</span>
<span class=sd>            If provided, the description to set for the guild's welcome screen.</span>
<span class=sd>            This may be `None` to unset the description.</span>
<span class=sd>        enabled : undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, Whether the guild's welcome screen should be enabled.</span>
<span class=sd>        channels : hikari.undefined.UndefinedNoneOr[typing.Sequence[hikari.guilds.WelcomeChannel]]</span>
<span class=sd>            If provided, a sequence of up to 5 public channels to set in this</span>
<span class=sd>            guild's welcome screen. This may be passed as `None` to</span>
<span class=sd>            remove all welcome channels</span>

<span class=sd>            .. note::</span>
<span class=sd>                Custom emojis may only be included in a guild's welcome channels</span>
<span class=sd>                if it's boost status is tier 2 or above.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.WelcomeScreen</span>
<span class=sd>            The edited guild welcome screen.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If more than 5 welcome channels are provided or if a custom emoji</span>
<span class=sd>            is included on a welcome channel in a guild that doesn't have tier</span>
<span class=sd>            2 of above boost status or if a private channel is included as a</span>
<span class=sd>            welcome channel.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_GUILD` permission, are not part of</span>
<span class=sd>            the guild or the guild doesn't have access to the community welcome</span>
<span class=sd>            screen feature.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Edit the welcome screen of a community guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): ID or object of the guild to edit the welcome screen for.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>description</strong> (undefined.UndefinedNoneOr[str]): If provided, the description to set for the guild's welcome screen. This may be <code>None</code> to unset the description.<li><strong>enabled</strong> (undefined.UndefinedOr[bool]): If provided, Whether the guild's welcome screen should be enabled.<li><p><strong>channels</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[typing.Sequence[<a href=../guilds.html#WelcomeChannel>hikari.guilds.WelcomeChannel</a>]]): If provided, a sequence of up to 5 public channels to set in this guild's welcome screen. This may be passed as <code>None</code> to remove all welcome channels</p> <p><em>Note:</em> Custom emojis may only be included in a guild's welcome channels if it's boost status is tier 2 or above.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../guilds.html#WelcomeScreen>hikari.guilds.WelcomeScreen</a></strong>: The edited guild welcome screen.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If more than 5 welcome channels are provided or if a custom emoji is included on a welcome channel in a guild that doesn't have tier 2 of above boost status or if a private channel is included as a welcome channel.<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_GUILD</code> permission, are not part of the guild or the guild doesn't have access to the community welcome screen feature.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.edit_widget><div class="attr function"><a class=headerlink href=#RESTClient.edit_widget>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>edit_widget</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   channel: Union[<a href=../channels.html#GuildChannel>hikari.channels.GuildChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, NoneType] = UNDEFINED,<br>   enabled: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../guilds.html#GuildWidget>hikari.guilds.GuildWidget</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>edit_widget</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedNoneOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>enabled</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>GuildWidget</span><span class=p>:</span>
        <span class=sd>"""Fetch a guilds's widget.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to edit the widget in. This can be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        channel : hikari.undefined.UndefinedNoneOr[hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]]</span>
<span class=sd>            If provided, the channel to set the widget to. If `None`,</span>
<span class=sd>            will not set to any.</span>
<span class=sd>        enabled : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether to enable the widget.</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.GuildWidget</span>
<span class=sd>            The edited guild widget.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_GUILD` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch a guilds's widget.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to edit the widget in. This can be the object or the ID of an existing guild.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>channel</strong> (<a href=../undefined.html#UndefinedNoneOr>hikari.undefined.UndefinedNoneOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildChannel>hikari.channels.GuildChannel</a>]]): If provided, the channel to set the widget to. If <code>None</code>, will not set to any.<li><strong>enabled</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, whether to enable the widget.<li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../guilds.html#GuildWidget>hikari.guilds.GuildWidget</a></strong>: The edited guild widget.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_GUILD</code> permission.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.estimate_guild_prune_count><div class="attr function"><a class=headerlink href=#RESTClient.estimate_guild_prune_count>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>estimate_guild_prune_count</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   days: Union[int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   include_roles: Union[Sequence[Union[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> int:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>estimate_guild_prune_count</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>days</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>int</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>include_roles</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=nb>int</span><span class=p>:</span>
        <span class=sd>"""Estimate the guild prune count.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to estimate the guild prune count for. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        days : hikari.undefined.UndefinedOr[int]</span>
<span class=sd>            If provided, number of days to count prune for.</span>
<span class=sd>        include_roles : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole]]]</span>
<span class=sd>            If provided, the role(s) to include. By default, this endpoint will</span>
<span class=sd>            not count users with roles. Providing roles using this attribute</span>
<span class=sd>            will make members with the specified roles also get included into</span>
<span class=sd>            the count.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        int</span>
<span class=sd>            The estimated guild prune count.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `KICK_MEMBERS` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Estimate the guild prune count.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to estimate the guild prune count for. This may be the object or the ID of an existing guild.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>days</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[int]): If provided, number of days to count prune for.<li><strong>include_roles</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishSequence>hikari.snowflakes.SnowflakeishSequence</a>[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>]]]): If provided, the role(s) to include. By default, this endpoint will not count users with roles. Providing roles using this attribute will make members with the specified roles also get included into the count.</ul><h6 id=returns>Returns</h6><ul><li><strong>int</strong>: The estimated guild prune count.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>KICK_MEMBERS</code> permission.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.execute_webhook><div class="attr function"><a class=headerlink href=#RESTClient.execute_webhook>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>execute_webhook</span><span class=signature>(<br>   self,<br>   webhook: Union[<a href=../webhooks.html#ExecutableWebhook>hikari.webhooks.ExecutableWebhook</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   token: str,<br>   content: Union[Any, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   *,<br>   username: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   avatar_url: Union[<a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, str, <a href=../files.html#URL>hikari.files.URL</a>] = UNDEFINED,<br>   attachment: Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   attachments: Union[Sequence[Union[<a href=../files.html#Resource>hikari.files.Resource</a>[Any], os.PathLike, str, bytes, bytearray, memoryview, _io.BytesIO, _io.StringIO]], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   component: Union[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   components: Union[Sequence[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   embed: Union[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   embeds: Union[Sequence[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   tts: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   mentions_everyone: Union[bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   user_mentions: Union[Sequence[Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]], bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   role_mentions: Union[Sequence[Union[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]], bool, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   flags: Union[<a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, int, <a href=../messages.html#MessageFlag>hikari.messages.MessageFlag</a>] = UNDEFINED<br>) -> <a href=../messages.html#Message>hikari.messages.Message</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>execute_webhook</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=c1># MyPy might not say this but SnowflakeishOr[ExecutableWebhook] isn't valid as ExecutableWebhook isn't Unique</span>
        <span class=n>webhook</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>ExecutableWebhook</span><span class=p>,</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>Snowflakeish</span><span class=p>],</span>
        <span class=n>token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>content</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Any</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>username</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>avatar_url</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedType</span><span class=p>,</span> <span class=nb>str</span><span class=p>,</span> <span class=n>files</span><span class=o>.</span><span class=n>URL</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachment</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>attachments</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>files</span><span class=o>.</span><span class=n>Resourceish</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>component</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>components</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>ComponentBuilder</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embed</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>embeds</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>embeds_</span><span class=o>.</span><span class=n>Embed</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>tts</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>mentions_everyone</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>bool</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>role_mentions</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishSequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span> <span class=nb>bool</span><span class=p>]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>flags</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedType</span><span class=p>,</span> <span class=nb>int</span><span class=p>,</span> <span class=n>messages_</span><span class=o>.</span><span class=n>MessageFlag</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Execute a webhook.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            As of writing, `username` and `avatar_url` are ignored for</span>
<span class=sd>            interaction webhooks.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        webhook : typing.Union[hikari.snowflakes.Snowflakeish, hikari.webhooks.ExecutableWebhook]</span>
<span class=sd>            The webhook to execute. This may be the object</span>
<span class=sd>            or the ID of an existing webhook.</span>
<span class=sd>        token: str</span>
<span class=sd>            The webhook token.</span>
<span class=sd>        content : hikari.undefined.UndefinedOr[typing.Any]</span>
<span class=sd>            If provided, the message contents. If</span>
<span class=sd>            `hikari.undefined.UNDEFINED`, then nothing will be sent</span>
<span class=sd>            in the content. Any other value here will be cast to a</span>
<span class=sd>            `str`.</span>

<span class=sd>            If this is a `hikari.embeds.Embed` and no `embed` nor</span>
<span class=sd>            no `embeds` kwarg is provided, then this will instead</span>
<span class=sd>            update the embed. This allows for simpler syntax when</span>
<span class=sd>            sending an embed alone.</span>

<span class=sd>            Likewise, if this is a `hikari.files.Resource`, then the</span>
<span class=sd>            content is instead treated as an attachment if no `attachment` and</span>
<span class=sd>            no `attachments` kwargs are provided.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        username : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the username to override the webhook's username</span>
<span class=sd>            for this request.</span>
<span class=sd>        avatar_url : typing.Union[hikari.undefined.UndefinedType, hikari.files.URL, str]</span>
<span class=sd>            If provided, the url of an image to override the webhook's</span>
<span class=sd>            avatar with for this request.</span>
<span class=sd>        attachment : hikari.undefined.UndefinedOr[hikari.files.Resourceish],</span>
<span class=sd>            If provided, the message attachment. This can be a resource,</span>
<span class=sd>            or string of a path on your computer or a URL.</span>

<span class=sd>            Attachments can be passed as many different things, to aid in</span>
<span class=sd>            convenience.</span>

<span class=sd>            - If a `pathlib.PurePath` or `str` to a valid URL, the</span>
<span class=sd>                resource at the given URL will be streamed to Discord when</span>
<span class=sd>                sending the message. Subclasses of</span>
<span class=sd>                `hikari.files.WebResource` such as</span>
<span class=sd>                `hikari.files.URL`,</span>
<span class=sd>                `hikari.messages.Attachment`,</span>
<span class=sd>                `hikari.emojis.Emoji`,</span>
<span class=sd>                `EmbedResource`, etc will also be uploaded this way.</span>
<span class=sd>                This will use bit-inception, so only a small percentage of the</span>
<span class=sd>                resource will remain in memory at any one time, thus aiding in</span>
<span class=sd>                scalability.</span>
<span class=sd>            - If a `hikari.files.Bytes` is passed, or a `str`</span>
<span class=sd>                that contains a valid data URI is passed, then this is uploaded</span>
<span class=sd>                with a randomized file name if not provided.</span>
<span class=sd>            - If a `hikari.files.File`, `pathlib.PurePath` or</span>
<span class=sd>                `str` that is an absolute or relative path to a file</span>
<span class=sd>                on your file system is passed, then this resource is uploaded</span>
<span class=sd>                as an attachment using non-blocking code internally and streamed</span>
<span class=sd>                using bit-inception where possible. This depends on the</span>
<span class=sd>                type of `concurrent.futures.Executor` that is being used for</span>
<span class=sd>                the application (default is a thread pool which supports this</span>
<span class=sd>                behaviour).</span>
<span class=sd>        attachments : hikari.undefined.UndefinedOr[typing.Sequence[hikari.files.Resourceish]],</span>
<span class=sd>            If provided, the message attachments. These can be resources, or</span>
<span class=sd>            strings consisting of paths on your computer or URLs.</span>
<span class=sd>        component : hikari.undefined.UndefinedOr[hikari.api.special_endpoints.ComponentBuilder]</span>
<span class=sd>            If provided, builder object of the component to include in this message.</span>
<span class=sd>        components : hikari.undefined.UndefinedOr[typing.Sequence[hikari.api.special_endpoints.ComponentBuilder]]</span>
<span class=sd>            If provided, a sequence of the component builder objects to include</span>
<span class=sd>            in this message.</span>
<span class=sd>        embed : hikari.undefined.UndefinedOr[hikari.embeds.Embed]</span>
<span class=sd>            If provided, the message embed.</span>
<span class=sd>        embeds : hikari.undefined.UndefinedOr[typing.Sequence[hikari.embeds.Embed]]</span>
<span class=sd>            If provided, the message embeds.</span>
<span class=sd>        tts : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the message will be read out by a screen</span>
<span class=sd>            reader using Discord's TTS (text-to-speech) system.</span>
<span class=sd>        mentions_everyone : hikari.undefined.UndefinedOr[bool]</span>
<span class=sd>            If provided, whether the message should parse @everyone/@here</span>
<span class=sd>            mentions.</span>
<span class=sd>        user_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.users.PartialUser], bool]]</span>
<span class=sd>            If provided, and `True`, all user mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all user mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.users.PartialUser` derivatives to enforce mentioning</span>
<span class=sd>            specific users.</span>
<span class=sd>        role_mentions : hikari.undefined.UndefinedOr[typing.Union[hikari.snowflakes.SnowflakeishSequence[hikari.guilds.PartialRole], bool]]</span>
<span class=sd>            If provided, and `True`, all role mentions will be detected.</span>
<span class=sd>            If provided, and `False`, all role mentions will be ignored</span>
<span class=sd>            if appearing in the message body.</span>
<span class=sd>            Alternatively this may be a collection of</span>
<span class=sd>            `hikari.snowflakes.Snowflake`, or</span>
<span class=sd>            `hikari.guilds.PartialRole` derivatives to enforce mentioning</span>
<span class=sd>            specific roles.</span>
<span class=sd>        flags : typing.Union[hikari.undefined.UndefinedType, int, hikari.messages.MessageFlag]</span>
<span class=sd>            The flags to set for this webhook message.</span>

<span class=sd>            .. warning::</span>
<span class=sd>                As of writing this can only be set for interaction webhooks</span>
<span class=sd>                and the only settable flag is EPHEMERAL; this field is just</span>
<span class=sd>                ignored for non-interaction webhooks.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The created message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        ValueError</span>
<span class=sd>            If more than 100 unique objects/entities are passed for</span>
<span class=sd>            `role_mentions` or `user_mentions` or if both `attachment` and</span>
<span class=sd>            `attachments` or `embed` and `embeds` are specified.</span>
<span class=sd>        TypeError</span>
<span class=sd>            If `attachments`, or `embeds` is passed but is not a sequence.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            This may be raised in several discrete situations, such as messages</span>
<span class=sd>            being empty with no attachments or embeds; messages with more than</span>
<span class=sd>            2000 characters in them, embeds that exceed one of the many embed</span>
<span class=sd>            limits; too many attachments; attachments that are too large;</span>
<span class=sd>            invalid image URLs in embeds; too many components.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the webhook is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>
</pre></div></details><div class=docstring><p>Execute a webhook.<p><em>Warning:</em> As of writing, <code>username</code> and <code>avatar_url</code> are ignored for interaction webhooks.<h6 id=parameters>Parameters</h6><ul><li><strong>webhook</strong> (typing.Union[<a href=../snowflakes.html#Snowflakeish>hikari.snowflakes.Snowflakeish</a>, <a href=../webhooks.html#ExecutableWebhook>hikari.webhooks.ExecutableWebhook</a>]): The webhook to execute. This may be the object or the ID of an existing webhook.<li><strong>token</strong> (str): The webhook token.<li><p><strong>content</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Any]): If provided, the message contents. If <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code>, then nothing will be sent in the content. Any other value here will be cast to a <code>str</code>.</p> <p>If this is a <code><a href=../embeds.html#Embed>hikari.embeds.Embed</a></code> and no <code>embed</code> nor no <code>embeds</code> kwarg is provided, then this will instead update the embed. This allows for simpler syntax when sending an embed alone.</p> <p>Likewise, if this is a <code><a href=../files.html#Resource>hikari.files.Resource</a></code>, then the content is instead treated as an attachment if no <code>attachment</code> and no <code>attachments</code> kwargs are provided.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>username</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the username to override the webhook's username for this request.<li><strong>avatar_url</strong> (typing.Union[<a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, <a href=../files.html#URL>hikari.files.URL</a>, str]): If provided, the url of an image to override the webhook's avatar with for this request.<li><p><strong>attachment</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../files.html#Resourceish>hikari.files.Resourceish</a>],): If provided, the message attachment. This can be a resource, or string of a path on your computer or a URL.</p> <p>Attachments can be passed as many different things, to aid in convenience.</p> <ul><li>If a <code>pathlib.PurePath</code> or <code>str</code> to a valid URL, the resource at the given URL will be streamed to Discord when sending the message. Subclasses of <code><a href=../files.html#WebResource>hikari.files.WebResource</a></code> such as <code><a href=../files.html#URL>hikari.files.URL</a></code>, <code><a href=../messages.html#Attachment>hikari.messages.Attachment</a></code>, <code><a href=../emojis.html#Emoji>hikari.emojis.Emoji</a></code>, <code>EmbedResource</code>, etc will also be uploaded this way. This will use bit-inception, so only a small percentage of the resource will remain in memory at any one time, thus aiding in scalability.<li>If a <code><a href=../files.html#Bytes>hikari.files.Bytes</a></code> is passed, or a <code>str</code> that contains a valid data URI is passed, then this is uploaded with a randomized file name if not provided.<li>If a <code><a href=../files.html#File>hikari.files.File</a></code>, <code>pathlib.PurePath</code> or <code>str</code> that is an absolute or relative path to a file on your file system is passed, then this resource is uploaded as an attachment using non-blocking code internally and streamed using bit-inception where possible. This depends on the type of <code>concurrent.futures.Executor</code> that is being used for the application (default is a thread pool which supports this behaviour).</ul><li><strong>attachments</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Sequence[<a href=../files.html#Resourceish>hikari.files.Resourceish</a>]],): If provided, the message attachments. These can be resources, or strings consisting of paths on your computer or URLs.<li><strong>component</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>]): If provided, builder object of the component to include in this message.<li><strong>components</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Sequence[<a href=special_endpoints.html#ComponentBuilder>hikari.api.special_endpoints.ComponentBuilder</a>]]): If provided, a sequence of the component builder objects to include in this message.<li><strong>embed</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>]): If provided, the message embed.<li><strong>embeds</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Sequence[<a href=../embeds.html#Embed>hikari.embeds.Embed</a>]]): If provided, the message embeds.<li><strong>tts</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, whether the message will be read out by a screen reader using Discord's TTS (text-to-speech) system.<li><strong>mentions_everyone</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[bool]): If provided, whether the message should parse @everyone/@here mentions.<li><strong>user_mentions</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Union[<a href=../snowflakes.html#SnowflakeishSequence>hikari.snowflakes.SnowflakeishSequence</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>], bool]]): If provided, and <code>True</code>, all user mentions will be detected. If provided, and <code>False</code>, all user mentions will be ignored if appearing in the message body. Alternatively this may be a collection of <code><a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a></code>, or <code><a href=../users.html#PartialUser>hikari.users.PartialUser</a></code> derivatives to enforce mentioning specific users.<li><strong>role_mentions</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Union[<a href=../snowflakes.html#SnowflakeishSequence>hikari.snowflakes.SnowflakeishSequence</a>[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>], bool]]): If provided, and <code>True</code>, all role mentions will be detected. If provided, and <code>False</code>, all role mentions will be ignored if appearing in the message body. Alternatively this may be a collection of <code><a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a></code>, or <code><a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a></code> derivatives to enforce mentioning specific roles.<li><p><strong>flags</strong> (typing.Union[<a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>, int, <a href=../messages.html#MessageFlag>hikari.messages.MessageFlag</a>]): The flags to set for this webhook message.</p> <p><em>Warning:</em> As of writing this can only be set for interaction webhooks and the only settable flag is EPHEMERAL; this field is just ignored for non-interaction webhooks.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../messages.html#Message>hikari.messages.Message</a></strong>: The created message.</ul><h6 id=raises>Raises</h6><ul><li><strong>ValueError</strong>: If more than 100 unique objects/entities are passed for <code>role_mentions</code> or <code>user_mentions</code> or if both <code>attachment</code> and <code>attachments</code> or <code>embed</code> and <code>embeds</code> are specified.<li><strong>TypeError</strong>: If <code>attachments</code>, or <code>embeds</code> is passed but is not a sequence.<li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: This may be raised in several discrete situations, such as messages being empty with no attachments or embeds; messages with more than 2000 characters in them, embeds that exceed one of the many embed limits; too many attachments; attachments that are too large; invalid image URLs in embeds; too many components.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the webhook is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_application><div class="attr function"><a class=headerlink href=#RESTClient.fetch_application>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_application</span><span class=signature>(self) -> <a href=../applications.html#Application>hikari.applications.Application</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_application</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>applications</span><span class=o>.</span><span class=n>Application</span><span class=p>:</span>
        <span class=sd>"""Fetch the token's associated application.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            This endpoint can only be used with a Bot token. Using this with a</span>
<span class=sd>            Bearer token will result in a `hikari.errors.UnauthorizedError`.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.applications.Application</span>
<span class=sd>            The token's associated application.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the token's associated application.<p><em>Warning:</em> This endpoint can only be used with a Bot token. Using this with a Bearer token will result in a <code><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></code>.<h6 id=returns>Returns</h6><ul><li><strong><a href=../applications.html#Application>hikari.applications.Application</a></strong>: The token's associated application.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_application_command><div class="attr function"><a class=headerlink href=#RESTClient.fetch_application_command>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_application_command</span><span class=signature>(<br>   self,<br>   application: Union[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   command: Union[<a href=../commands.html#PartialCommand>hikari.commands.PartialCommand</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../commands.html#PartialCommand>hikari.commands.PartialCommand</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_application_command</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>command</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>:</span>
        <span class=sd>"""Fetch a command set for an application.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to fetch a command for.</span>
<span class=sd>        command: hikari.snowflakes.SnowflakeishOr[hikari.commands.PartialCommand]</span>
<span class=sd>            Object or ID of the command to fetch.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or ID of the guild to fetch the command for. If left as</span>
<span class=sd>            `hikari.undefined.UNDEFINED` then this will return a global command,</span>
<span class=sd>            otherwise this will return a command made for the specified guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.commands.PartialCommand</span>
<span class=sd>            Object of the fetched command.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the target command.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the command isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch a command set for an application.<h6 id=parameters>Parameters</h6><ul><li><strong>application</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>]): Object or ID of the application to fetch a command for.<li><strong>command</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../commands.html#PartialCommand>hikari.commands.PartialCommand</a>]): Object or ID of the command to fetch.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>guild</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): Object or ID of the guild to fetch the command for. If left as <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code> then this will return a global command, otherwise this will return a command made for the specified guild.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../commands.html#PartialCommand>hikari.commands.PartialCommand</a></strong>: Object of the fetched command.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you cannot access the target command.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the command isn't found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_application_command_permissions><div class="attr function"><a class=headerlink href=#RESTClient.fetch_application_command_permissions>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_application_command_permissions</span><span class=signature>(<br>   self,<br>   application: Union[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   command: Union[<a href=../commands.html#PartialCommand>hikari.commands.PartialCommand</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> <a href=../commands.html#GuildCommandPermissions>hikari.commands.GuildCommandPermissions</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_application_command_permissions</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>command</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>commands</span><span class=o>.</span><span class=n>GuildCommandPermissions</span><span class=p>:</span>
        <span class=sd>"""Fetch the permissions registered for a specific command in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to fetch the command permissions for.</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]]</span>
<span class=sd>            Object or ID of the guild to fetch the command permissions for.</span>
<span class=sd>        command: hikari.snowflakes.SnowflakeishOr[hikari.commands.PartialCommand]</span>
<span class=sd>            Objecr or ID of the command to fetch the command permissions for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.commands.GuildCommandPermissions</span>
<span class=sd>            Object of the command permissions set for the specified command.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands or guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application or command isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the permissions registered for a specific command in a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>application</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>]): Object or ID of the application to fetch the command permissions for.<li><strong>guild</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]]): Object or ID of the guild to fetch the command permissions for.<li><strong>command</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../commands.html#PartialCommand>hikari.commands.PartialCommand</a>]): Objecr or ID of the command to fetch the command permissions for.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../commands.html#GuildCommandPermissions>hikari.commands.GuildCommandPermissions</a></strong>: Object of the command permissions set for the specified command.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you cannot access the provided application's commands or guild.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the provided application or command isn't found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_application_commands><div class="attr function"><a class=headerlink href=#RESTClient.fetch_application_commands>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_application_commands</span><span class=signature>(<br>   self,<br>   application: Union[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> Sequence[<a href=../commands.html#PartialCommand>hikari.commands.PartialCommand</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_application_commands</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>]:</span>
        <span class=sd>"""Fetch the commands set for an application.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to fetch the commands for.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or ID of the guild to fetch the commands for. If left as</span>
<span class=sd>            `hikari.undefined.UNDEFINED` then this will only return the global</span>
<span class=sd>            commands, otherwise this will only return the commands set exclusively</span>
<span class=sd>            for the specific guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.commands.PartialCommand]</span>
<span class=sd>            A sequence of the commands declared for the provided application.</span>
<span class=sd>            This will exclusively either contain the commands set for a specific</span>
<span class=sd>            guild if `guild` is provided or the global commands if not.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the target guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the commands set for an application.<h6 id=parameters>Parameters</h6><ul><li><strong>application</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>]): Object or ID of the application to fetch the commands for.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>guild</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): Object or ID of the guild to fetch the commands for. If left as <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code> then this will only return the global commands, otherwise this will only return the commands set exclusively for the specific guild.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.Sequence[<a href=../commands.html#PartialCommand>hikari.commands.PartialCommand</a>]</strong>: A sequence of the commands declared for the provided application. This will exclusively either contain the commands set for a specific guild if <code>guild</code> is provided or the global commands if not.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you cannot access the target guild.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the provided application isn't found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_application_guild_commands_permissions><div class="attr function"><a class=headerlink href=#RESTClient.fetch_application_guild_commands_permissions>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_application_guild_commands_permissions</span><span class=signature>(<br>   self,<br>   application: Union[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> Sequence[<a href=../commands.html#GuildCommandPermissions>hikari.commands.GuildCommandPermissions</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_application_guild_commands_permissions</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>GuildCommandPermissions</span><span class=p>]:</span>
        <span class=sd>"""Fetch the command permissions registered in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to fetch the command permissions for.</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]]</span>
<span class=sd>            Object or ID of the guild to fetch the command permissions for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.commands.GuildCommandPermissions]</span>
<span class=sd>            Sequence of the guild command permissions set for the specified guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands or guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the command permissions registered in a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>application</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>]): Object or ID of the application to fetch the command permissions for.<li><strong>guild</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]]): Object or ID of the guild to fetch the command permissions for.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.Sequence[<a href=../commands.html#GuildCommandPermissions>hikari.commands.GuildCommandPermissions</a>]</strong>: Sequence of the guild command permissions set for the specified guild.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you cannot access the provided application's commands or guild.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the provided application isn't found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_audit_log><div class="attr function"><a class=headerlink href=#RESTClient.fetch_audit_log>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>def </span><span class=name>fetch_audit_log</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   before: Union[<a href=../snowflakes.html#Unique>hikari.snowflakes.Unique</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, datetime.datetime, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   user: Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   event_type: Union[<a href=../audit_logs.html#AuditLogEventType>hikari.audit_logs.AuditLogEventType</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../iterators.html#LazyIterator>hikari.iterators.LazyIterator</a>[<a href=../audit_logs.html#AuditLog>hikari.audit_logs.AuditLog</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>fetch_audit_log</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>before</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SearchableSnowflakeishOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>Unique</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>event_type</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>audit_logs</span><span class=o>.</span><span class=n>AuditLogEventType</span><span class=p>,</span> <span class=nb>int</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>iterators</span><span class=o>.</span><span class=n>LazyIterator</span><span class=p>[</span><span class=n>audit_logs</span><span class=o>.</span><span class=n>AuditLog</span><span class=p>]:</span>
        <span class=sd>"""Fetch the guild's audit log.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        This call is not a coroutine function, it returns a special type of</span>
<span class=sd>        lazy iterator that will perform API calls as you iterate across it,</span>
<span class=sd>        thus any errors documented below will happen then.</span>

<span class=sd>        See `hikari.iterators` for the full API for this iterator type.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the audit logs from. This can be a</span>
<span class=sd>            guild object or the ID of an existing guild.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        before : hikari.undefined.UndefinedOr[hikari.snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]</span>
<span class=sd>            If provided, filter to only actions before this snowflake. If you provide</span>
<span class=sd>            a datetime object, it will be transformed into a snowflake. This</span>
<span class=sd>            may be any other Discord entity that has an ID. In this case, the</span>
<span class=sd>            date the object was first created will be used.</span>
<span class=sd>        user : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]]</span>
<span class=sd>            If provided, the user to filter for.</span>
<span class=sd>        event_type : hikari.undefined.UndefinedOr[typing.Union[hikari.audit_logs.AuditLogEventType, int]]</span>
<span class=sd>            If provided, the event type to filter for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.iterators.LazyIterator[hikari.audit_logs.AuditLog]</span>
<span class=sd>            The guild's audit log.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `VIEW_AUDIT_LOG` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the guild's audit log.<h6 id=notes>Notes</h6><p>This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it, thus any errors documented below will happen then.<p>See <code><a href=../iterators.html>hikari.iterators</a></code> for the full API for this iterator type.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to fetch the audit logs from. This can be a guild object or the ID of an existing guild.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>before</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SearchableSnowflakeishOr>hikari.snowflakes.SearchableSnowflakeishOr</a>[<a href=../snowflakes.html#Unique>hikari.snowflakes.Unique</a>]]): If provided, filter to only actions before this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used.<li><strong>user</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>]]): If provided, the user to filter for.<li><strong>event_type</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[typing.Union[<a href=../audit_logs.html#AuditLogEventType>hikari.audit_logs.AuditLogEventType</a>, int]]): If provided, the event type to filter for.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../iterators.html#LazyIterator>hikari.iterators.LazyIterator</a>[<a href=../audit_logs.html#AuditLog>hikari.audit_logs.AuditLog</a>]</strong>: The guild's audit log.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>VIEW_AUDIT_LOG</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_authorization><div class="attr function"><a class=headerlink href=#RESTClient.fetch_authorization>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_authorization</span><span class=signature>(self) -> <a href=../applications.html#AuthorizationInformation>hikari.applications.AuthorizationInformation</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_authorization</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>applications</span><span class=o>.</span><span class=n>AuthorizationInformation</span><span class=p>:</span>
        <span class=sd>"""Fetch the token's authorization information.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            This endpoint can only be used with a Bearer token. Using this</span>
<span class=sd>            with a Bot token will result in a `hikari.errors.UnauthorizedError`.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.applications.AuthorizationInformation</span>
<span class=sd>            The token's authorization information.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the token's authorization information.<p><em>Warning:</em> This endpoint can only be used with a Bearer token. Using this with a Bot token will result in a <code><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></code>.<h6 id=returns>Returns</h6><ul><li><strong><a href=../applications.html#AuthorizationInformation>hikari.applications.AuthorizationInformation</a></strong>: The token's authorization information.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_available_sticker_packs><div class="attr function"><a class=headerlink href=#RESTClient.fetch_available_sticker_packs>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_available_sticker_packs</span><span class=signature>(self) -> Sequence[<a href=../stickers.html#StickerPack>hikari.stickers.StickerPack</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_available_sticker_packs</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>stickers</span><span class=o>.</span><span class=n>StickerPack</span><span class=p>]:</span>
        <span class=sd>"""Fetch the available sticker packs.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.stickers.StickerPack]</span>
<span class=sd>            The available sticker packs.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the available sticker packs.<h6 id=returns>Returns</h6><ul><li><strong>typing.Sequence[<a href=../stickers.html#StickerPack>hikari.stickers.StickerPack</a>]</strong>: The available sticker packs.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_ban><div class="attr function"><a class=headerlink href=#RESTClient.fetch_ban>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_ban</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   user: Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> <a href=../guilds.html#GuildBan>hikari.guilds.GuildBan</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_ban</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>GuildBan</span><span class=p>:</span>
        <span class=sd>"""Fetch the guild's ban info for a user.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the ban from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to fetch the ban of. This may be the</span>
<span class=sd>            object or the ID of an existing user.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.GuildBan</span>
<span class=sd>            The requested ban info.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `BAN_MEMBERS` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or user are not found or if the user</span>
<span class=sd>            is not banned.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the guild's ban info for a user.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to fetch the ban from. This may be the object or the ID of an existing guild.<li><strong>user</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>]): The user to fetch the ban of. This may be the object or the ID of an existing user.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../guilds.html#GuildBan>hikari.guilds.GuildBan</a></strong>: The requested ban info.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>BAN_MEMBERS</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild or user are not found or if the user is not banned.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_bans><div class="attr function"><a class=headerlink href=#RESTClient.fetch_bans>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_bans</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> Sequence[<a href=../guilds.html#GuildBan>hikari.guilds.GuildBan</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_bans</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>GuildBan</span><span class=p>]:</span>
        <span class=sd>"""Fetch the bans of a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the bans from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.guilds.GuildBan]</span>
<span class=sd>            The requested bans.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `BAN_MEMBERS` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the bans of a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to fetch the bans from. This may be the object or the ID of an existing guild.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.Sequence[<a href=../guilds.html#GuildBan>hikari.guilds.GuildBan</a>]</strong>: The requested bans.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>BAN_MEMBERS</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_channel><div class="attr function"><a class=headerlink href=#RESTClient.fetch_channel>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_channel</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#PartialChannel>hikari.channels.PartialChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> <a href=../channels.html#PartialChannel>hikari.channels.PartialChannel</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>PartialChannel</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>PartialChannel</span><span class=p>:</span>
        <span class=sd>"""Fetch a channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.PartialChannel]</span>
<span class=sd>            The channel to fetch. This may be the object or the ID of an</span>
<span class=sd>            existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.PartialChannel</span>
<span class=sd>            The channel. This will be a _derivative_ of</span>
<span class=sd>            `hikari.channels.PartialChannel`, depending on the type of</span>
<span class=sd>            channel you request for.</span>

<span class=sd>            This means that you may get one of</span>
<span class=sd>            `hikari.channels.DMChannel`,</span>
<span class=sd>            `hikari.channels.GroupDMChannel`,</span>
<span class=sd>            `hikari.channels.GuildTextChannel`,</span>
<span class=sd>            `hikari.channels.GuildVoiceChannel`,</span>
<span class=sd>            `hikari.channels.GuildStoreChannel`,</span>
<span class=sd>            `hikari.channels.GuildNewsChannel`.</span>

<span class=sd>            Likewise, the `hikari.channels.GuildChannel` can be used to</span>
<span class=sd>            determine if a channel is guild-bound, and</span>
<span class=sd>            `hikari.channels.TextableChannel` can be used to determine</span>
<span class=sd>            if the channel provides textual functionality to the application.</span>

<span class=sd>            You can check for these using the `isinstance`</span>
<span class=sd>            builtin function.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `READ_MESSAGES` permission in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch a channel.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#PartialChannel>hikari.channels.PartialChannel</a>]): The channel to fetch. This may be the object or the ID of an existing channel.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../channels.html#PartialChannel>hikari.channels.PartialChannel</a></strong>: The channel. This will be a _derivative_ of <code><a href=../channels.html#PartialChannel>hikari.channels.PartialChannel</a></code>, depending on the type of channel you request for.</ul><p>This means that you may get one of <code><a href=../channels.html#DMChannel>hikari.channels.DMChannel</a></code>, <code><a href=../channels.html#GroupDMChannel>hikari.channels.GroupDMChannel</a></code>, <code><a href=../channels.html#GuildTextChannel>hikari.channels.GuildTextChannel</a></code>, <code><a href=../channels.html#GuildVoiceChannel>hikari.channels.GuildVoiceChannel</a></code>, <code><a href=../channels.html#GuildStoreChannel>hikari.channels.GuildStoreChannel</a></code>, <code><a href=../channels.html#GuildNewsChannel>hikari.channels.GuildNewsChannel</a></code>.<p>Likewise, the <code><a href=../channels.html#GuildChannel>hikari.channels.GuildChannel</a></code> can be used to determine if a channel is guild-bound, and <code><a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a></code> can be used to determine if the channel provides textual functionality to the application.<p>You can check for these using the <code>isinstance</code> builtin function.<h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>READ_MESSAGES</code> permission in the channel.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_channel_invites><div class="attr function"><a class=headerlink href=#RESTClient.fetch_channel_invites>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_channel_invites</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#GuildChannel>hikari.channels.GuildChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> Sequence[<a href=../invites.html#InviteWithMetadata>hikari.invites.InviteWithMetadata</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_channel_invites</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>invites</span><span class=o>.</span><span class=n>InviteWithMetadata</span><span class=p>]:</span>
        <span class=sd>"""Fetch all invites pointing to the given guild channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]</span>
<span class=sd>            The channel to fetch the invites from. This may be a channel</span>
<span class=sd>            object, or the ID of an existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.invites.InviteWithMetadata]</span>
<span class=sd>            The invites pointing to the given guild channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found in any guilds you are a member of.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch all invites pointing to the given guild channel.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildChannel>hikari.channels.GuildChannel</a>]): The channel to fetch the invites from. This may be a channel object, or the ID of an existing channel.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.Sequence[<a href=../invites.html#InviteWithMetadata>hikari.invites.InviteWithMetadata</a>]</strong>: The invites pointing to the given guild channel.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_CHANNEL</code> permission in the channel.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel is not found in any guilds you are a member of.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_channel_webhooks><div class="attr function"><a class=headerlink href=#RESTClient.fetch_channel_webhooks>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_channel_webhooks</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#GuildTextChannel>hikari.channels.GuildTextChannel</a>, <a href=../channels.html#GuildNewsChannel>hikari.channels.GuildNewsChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> Sequence[<a href=../webhooks.html#PartialWebhook>hikari.webhooks.PartialWebhook</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_channel_webhooks</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>WebhookChannelT</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>PartialWebhook</span><span class=p>]:</span>
        <span class=sd>"""Fetch all channel webhooks.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.WebhookChannelT]</span>
<span class=sd>            The channel to fetch the webhooks for. This may be an instance of any</span>
<span class=sd>            of the classes which are valid for `hikari.channels.WebhookChannelT`</span>
<span class=sd>            or the ID of an existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.webhooks.PartialWebhook]</span>
<span class=sd>            The fetched webhooks.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_WEBHOOKS` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch all channel webhooks.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#WebhookChannelT>hikari.channels.WebhookChannelT</a>]): The channel to fetch the webhooks for. This may be an instance of any of the classes which are valid for <code><a href=../channels.html#WebhookChannelT>hikari.channels.WebhookChannelT</a></code> or the ID of an existing channel.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.Sequence[<a href=../webhooks.html#PartialWebhook>hikari.webhooks.PartialWebhook</a>]</strong>: The fetched webhooks.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_WEBHOOKS</code> permission.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_emoji><div class="attr function"><a class=headerlink href=#RESTClient.fetch_emoji>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_emoji</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   emoji: Union[<a href=../emojis.html#CustomEmoji>hikari.emojis.CustomEmoji</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> <a href=../emojis.html#KnownCustomEmoji>hikari.emojis.KnownCustomEmoji</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_emoji</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>emojis</span><span class=o>.</span><span class=n>KnownCustomEmoji</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild emoji.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the emoji from. This can be a</span>
<span class=sd>            guild object or the ID of an existing guild.</span>
<span class=sd>        emoji : hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]</span>
<span class=sd>            The emoji to fetch. This can be a `hikari.emojis.CustomEmoji`</span>
<span class=sd>            or the ID of an existing emoji.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.emojis.KnownCustomEmoji</span>
<span class=sd>            The requested emoji.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the emoji are not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch a guild emoji.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to fetch the emoji from. This can be a guild object or the ID of an existing guild.<li><strong>emoji</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../emojis.html#CustomEmoji>hikari.emojis.CustomEmoji</a>]): The emoji to fetch. This can be a <code><a href=../emojis.html#CustomEmoji>hikari.emojis.CustomEmoji</a></code> or the ID of an existing emoji.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../emojis.html#KnownCustomEmoji>hikari.emojis.KnownCustomEmoji</a></strong>: The requested emoji.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild or the emoji are not found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_gateway_bot_info><div class="attr function"><a class=headerlink href=#RESTClient.fetch_gateway_bot_info>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_gateway_bot_info</span><span class=signature>(self) -> <a href=../sessions.html#GatewayBotInfo>hikari.sessions.GatewayBotInfo</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_gateway_bot_info</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>sessions</span><span class=o>.</span><span class=n>GatewayBotInfo</span><span class=p>:</span>
        <span class=sd>"""Fetch the gateway gateway info for the bot.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.sessions.GatewayBotInfo</span>
<span class=sd>            The gateway bot information.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the gateway gateway info for the bot.<h6 id=returns>Returns</h6><ul><li><strong><a href=../sessions.html#GatewayBotInfo>hikari.sessions.GatewayBotInfo</a></strong>: The gateway bot information.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_gateway_url><div class="attr function"><a class=headerlink href=#RESTClient.fetch_gateway_url>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_gateway_url</span><span class=signature>(self) -> str:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_gateway_url</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>
        <span class=sd>"""Fetch the gateway url.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This endpoint does not require any valid authorization.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the gateway url.<p><em>Note:</em> This endpoint does not require any valid authorization.<h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_guild><div class="attr function"><a class=headerlink href=#RESTClient.fetch_guild>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_guild</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> <a href=../guilds.html#RESTGuild>hikari.guilds.RESTGuild</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>])</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>RESTGuild</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch. This can be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.RESTGuild</span>
<span class=sd>            The requested guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to fetch. This can be the object or the ID of an existing guild.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../guilds.html#RESTGuild>hikari.guilds.RESTGuild</a></strong>: The requested guild.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are not part of the guild.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_guild_channels><div class="attr function"><a class=headerlink href=#RESTClient.fetch_guild_channels>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_guild_channels</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> Sequence[<a href=../channels.html#GuildChannel>hikari.channels.GuildChannel</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_channels</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>]:</span>
        <span class=sd>"""Fetch the channels in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the channels from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.channels.GuildChannel]</span>
<span class=sd>            The requested channels.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the channels in a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to fetch the channels from. This may be the object or the ID of an existing guild.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.Sequence[<a href=../channels.html#GuildChannel>hikari.channels.GuildChannel</a>]</strong>: The requested channels.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_guild_emojis><div class="attr function"><a class=headerlink href=#RESTClient.fetch_guild_emojis>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_guild_emojis</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> Sequence[<a href=../emojis.html#KnownCustomEmoji>hikari.emojis.KnownCustomEmoji</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_emojis</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>KnownCustomEmoji</span><span class=p>]:</span>
        <span class=sd>"""Fetch the emojis of a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the emojis from. This can be a</span>
<span class=sd>            guild object or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.emojis.KnownCustomEmoji]</span>
<span class=sd>            The requested emojis.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the emojis of a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to fetch the emojis from. This can be a guild object or the ID of an existing guild.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.Sequence[<a href=../emojis.html#KnownCustomEmoji>hikari.emojis.KnownCustomEmoji</a>]</strong>: The requested emojis.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_guild_invites><div class="attr function"><a class=headerlink href=#RESTClient.fetch_guild_invites>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_guild_invites</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> Sequence[<a href=../invites.html#InviteWithMetadata>hikari.invites.InviteWithMetadata</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_invites</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>invites</span><span class=o>.</span><span class=n>InviteWithMetadata</span><span class=p>]:</span>
        <span class=sd>"""Fetch the guild's invites.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the invites for. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.invites.InviteWithMetadata]</span>
<span class=sd>            The invites for the guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_GUILD` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the guild's invites.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to fetch the invites for. This may be the object or the ID of an existing guild.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.Sequence[<a href=../invites.html#InviteWithMetadata>hikari.invites.InviteWithMetadata</a>]</strong>: The invites for the guild.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_GUILD</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_guild_preview><div class="attr function"><a class=headerlink href=#RESTClient.fetch_guild_preview>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_guild_preview</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> <a href=../guilds.html#GuildPreview>hikari.guilds.GuildPreview</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_preview</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>])</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>GuildPreview</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild preview.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This will only work for guilds you are a part of or are public.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the preview of. This can be a</span>
<span class=sd>            guild object or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.GuildPreview</span>
<span class=sd>            The requested guild preview.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found or you are not part of the guild.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch a guild preview.<p><em>Note:</em> This will only work for guilds you are a part of or are public.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to fetch the preview of. This can be a guild object or the ID of an existing guild.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../guilds.html#GuildPreview>hikari.guilds.GuildPreview</a></strong>: The requested guild preview.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found or you are not part of the guild.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_guild_sticker><div class="attr function"><a class=headerlink href=#RESTClient.fetch_guild_sticker>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_guild_sticker</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   sticker: Union[<a href=../stickers.html#PartialSticker>hikari.stickers.PartialSticker</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> <a href=../stickers.html#GuildSticker>hikari.stickers.GuildSticker</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_sticker</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>sticker</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>stickers</span><span class=o>.</span><span class=n>PartialSticker</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>stickers</span><span class=o>.</span><span class=n>GuildSticker</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild sticker.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : snowflakes.SnowflakeishOr[stickers.PartialGuild]</span>
<span class=sd>            The guild the sticker is in. This can be a guild object or the</span>
<span class=sd>            ID of an existing guild.</span>
<span class=sd>        sticker : snowflakes.SnowflakeishOr[stickers.PartialSticker]</span>
<span class=sd>            The sticker to fetch. This can be a sticker object or the</span>
<span class=sd>            ID of an existing sticker.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.stickers.GuildSticker</span>
<span class=sd>            The requested sticker.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the sticker are not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch a guild sticker.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (snowflakes.SnowflakeishOr[stickers.PartialGuild]): The guild the sticker is in. This can be a guild object or the ID of an existing guild.<li><strong>sticker</strong> (snowflakes.SnowflakeishOr[stickers.PartialSticker]): The sticker to fetch. This can be a sticker object or the ID of an existing sticker.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../stickers.html#GuildSticker>hikari.stickers.GuildSticker</a></strong>: The requested sticker.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are not part of the server.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild or the sticker are not found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_guild_stickers><div class="attr function"><a class=headerlink href=#RESTClient.fetch_guild_stickers>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_guild_stickers</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> Sequence[<a href=../stickers.html#GuildSticker>hikari.stickers.GuildSticker</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_stickers</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>stickers</span><span class=o>.</span><span class=n>GuildSticker</span><span class=p>]:</span>
        <span class=sd>"""Fetch a standard sticker.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : snowflakes.SnowflakeishOr[stickers.PartialGuild]</span>
<span class=sd>            The guild to request stickers for. This can be a guild object or the</span>
<span class=sd>            ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.stickers.GuildSticker]</span>
<span class=sd>            The requested stickers.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the server.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch a standard sticker.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (snowflakes.SnowflakeishOr[stickers.PartialGuild]): The guild to request stickers for. This can be a guild object or the ID of an existing guild.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.Sequence[<a href=../stickers.html#GuildSticker>hikari.stickers.GuildSticker</a>]</strong>: The requested stickers.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are not part of the server.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_guild_templates><div class="attr function"><a class=headerlink href=#RESTClient.fetch_guild_templates>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_guild_templates</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> Sequence[<a href=../templates.html#Template>hikari.templates.Template</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_templates</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>]:</span>
        <span class=sd>"""Fetch the templates for a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The object or ID of the guild to get the templates for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.templates.Template]</span>
<span class=sd>            A sequence of the found template objects.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found or are missing the `MANAGE_GUILD`</span>
<span class=sd>            permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the templates for a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The object or ID of the guild to get the templates for.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.Sequence[<a href=../templates.html#Template>hikari.templates.Template</a>]</strong>: A sequence of the found template objects.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are not part of the guild.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found or are missing the <code>MANAGE_GUILD</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_guild_voice_regions><div class="attr function"><a class=headerlink href=#RESTClient.fetch_guild_voice_regions>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_guild_voice_regions</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> Sequence[<a href=../voices.html#VoiceRegion>hikari.voices.VoiceRegion</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_voice_regions</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>voices</span><span class=o>.</span><span class=n>VoiceRegion</span><span class=p>]:</span>
        <span class=sd>"""Fetch the available voice regions for a guild.</span>

<span class=sd>        .. note::</span>
<span class=sd>            Unlike `RESTClient.fetch_voice_regions`, this will</span>
<span class=sd>            return the VIP regions if the guild has access to them.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the voice regions for. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.voices.VoiceRegion]</span>
<span class=sd>            The available voice regions for the guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the available voice regions for a guild.<p><em>Note:</em> Unlike <code><a href=#RESTClient.fetch_voice_regions>RESTClient.fetch_voice_regions</a></code>, this will return the VIP regions if the guild has access to them.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to fetch the voice regions for. This may be the object or the ID of an existing guild.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.Sequence[<a href=../voices.html#VoiceRegion>hikari.voices.VoiceRegion</a>]</strong>: The available voice regions for the guild.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_guild_webhooks><div class="attr function"><a class=headerlink href=#RESTClient.fetch_guild_webhooks>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_guild_webhooks</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> Sequence[<a href=../webhooks.html#PartialWebhook>hikari.webhooks.PartialWebhook</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_guild_webhooks</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>PartialWebhook</span><span class=p>]:</span>
        <span class=sd>"""Fetch all guild webhooks.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the webhooks for. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.webhooks.PartialWebhook]</span>
<span class=sd>            The fetched webhooks.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_WEBHOOKS` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch all guild webhooks.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to fetch the webhooks for. This may be the object or the ID of an existing guild.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.Sequence[<a href=../webhooks.html#PartialWebhook>hikari.webhooks.PartialWebhook</a>]</strong>: The fetched webhooks.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_WEBHOOKS</code> permission.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_integrations><div class="attr function"><a class=headerlink href=#RESTClient.fetch_integrations>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_integrations</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> Sequence[<a href=../guilds.html#Integration>hikari.guilds.Integration</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_integrations</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>Integration</span><span class=p>]:</span>
        <span class=sd>"""Fetch the guild's integrations.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the integrations for. This may be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.guilds.Integration]</span>
<span class=sd>            The integrations for the guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_GUILD` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the guild's integrations.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to fetch the integrations for. This may be the object or the ID of an existing guild.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.Sequence[<a href=../guilds.html#Integration>hikari.guilds.Integration</a>]</strong>: The integrations for the guild.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_GUILD</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_interaction_response><div class="attr function"><a class=headerlink href=#RESTClient.fetch_interaction_response>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_interaction_response</span><span class=signature>(<br>   self,<br>   application: Union[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   token: str<br>) -> <a href=../messages.html#Message>hikari.messages.Message</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_interaction_response</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span> <span class=n>token</span><span class=p>:</span> <span class=nb>str</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Fetch the initial response for an interaction.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to fetch a command for.</span>
<span class=sd>        token: str</span>
<span class=sd>            Token of the interaction to get the initial response for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            Message object of the initial response.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the target interaction.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the initial response isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the initial response for an interaction.<h6 id=parameters>Parameters</h6><ul><li><strong>application</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>]): Object or ID of the application to fetch a command for.<li><strong>token</strong> (str): Token of the interaction to get the initial response for.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../messages.html#Message>hikari.messages.Message</a></strong>: Message object of the initial response.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you cannot access the target interaction.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the initial response isn't found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_invite><div class="attr function"><a class=headerlink href=#RESTClient.fetch_invite>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_invite</span><span class=signature>(<br>   self,<br>   invite: Union[<a href=../invites.html#InviteCode>hikari.invites.InviteCode</a>, str]<br>) -> <a href=../invites.html#Invite>hikari.invites.Invite</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_invite</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>invite</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>invites</span><span class=o>.</span><span class=n>InviteCode</span><span class=p>,</span> <span class=nb>str</span><span class=p>])</span> <span class=o>-></span> <span class=n>invites</span><span class=o>.</span><span class=n>Invite</span><span class=p>:</span>
        <span class=sd>"""Fetch an existing invite.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        invite : typing.Union[hikari.invites.InviteCode, str]</span>
<span class=sd>            The invite to fetch. This may be an invite object or</span>
<span class=sd>            the code of an existing invite.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.invites.Invite</span>
<span class=sd>            The requested invite.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the invite is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch an existing invite.<h6 id=parameters>Parameters</h6><ul><li><strong>invite</strong> (typing.Union[<a href=../invites.html#InviteCode>hikari.invites.InviteCode</a>, str]): The invite to fetch. This may be an invite object or the code of an existing invite.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../invites.html#Invite>hikari.invites.Invite</a></strong>: The requested invite.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the invite is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_member><div class="attr function"><a class=headerlink href=#RESTClient.fetch_member>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_member</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   user: Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> <a href=../guilds.html#Member>hikari.guilds.Member</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>Member</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild member.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to get the member from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to get the member for. This may be the</span>
<span class=sd>            object or the ID of an existing user.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.Member</span>
<span class=sd>            The requested member.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or the user are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch a guild member.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to get the member from. This may be the object or the ID of an existing guild.<li><strong>user</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>]): The user to get the member for. This may be the object or the ID of an existing user.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../guilds.html#Member>hikari.guilds.Member</a></strong>: The requested member.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild or the user are not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_members><div class="attr function"><a class=headerlink href=#RESTClient.fetch_members>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>def </span><span class=name>fetch_members</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> <a href=../iterators.html#LazyIterator>hikari.iterators.LazyIterator</a>[<a href=../guilds.html#Member>hikari.guilds.Member</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>fetch_members</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>iterators</span><span class=o>.</span><span class=n>LazyIterator</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>Member</span><span class=p>]:</span>
        <span class=sd>"""Fetch the members from a guild.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            This endpoint requires the `GUILD_MEMBERS` intent to be enabled in</span>
<span class=sd>            the dashboard, not necessarily authenticated with it if using the</span>
<span class=sd>            gateway. If you don't have the intents you can use `search_members`</span>
<span class=sd>            which doesn't require any intents.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        This call is not a coroutine function, it returns a special type of</span>
<span class=sd>        lazy iterator that will perform API calls as you iterate across it,</span>
<span class=sd>        thus any errors documented below will happen then.</span>

<span class=sd>        See `hikari.iterators` for the full API for this iterator type.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the members of. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.iterators.LazyIterator[hikari.guilds.Member]</span>
<span class=sd>            An iterator to fetch the members.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the members from a guild.<p><em>Warning:</em> This endpoint requires the <code>GUILD_MEMBERS</code> intent to be enabled in the dashboard, not necessarily authenticated with it if using the gateway. If you don't have the intents you can use <code><a href=#RESTClient.search_members>search_members</a></code> which doesn't require any intents.<h6 id=notes>Notes</h6><p>This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it, thus any errors documented below will happen then.<p>See <code><a href=../iterators.html>hikari.iterators</a></code> for the full API for this iterator type.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to fetch the members of. This may be the object or the ID of an existing guild.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../iterators.html#LazyIterator>hikari.iterators.LazyIterator</a>[<a href=../guilds.html#Member>hikari.guilds.Member</a>]</strong>: An iterator to fetch the members.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_message><div class="attr function"><a class=headerlink href=#RESTClient.fetch_message>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_message</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   message: Union[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> <a href=../messages.html#Message>hikari.messages.Message</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Fetch a specific message in the given text channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to fetch messages in. This may be the object or</span>
<span class=sd>            the ID of an existing message.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to fetch. This may be the object or the ID of an</span>
<span class=sd>            existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The requested message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `READ_MESSAGE_HISTORY` in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found or the message is not found in the</span>
<span class=sd>            given text channel.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch a specific message in the given text channel.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>]): The channel to fetch messages in. This may be the object or the ID of an existing message.<li><strong>message</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>]): The message to fetch. This may be the object or the ID of an existing channel.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../messages.html#Message>hikari.messages.Message</a></strong>: The requested message.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>READ_MESSAGE_HISTORY</code> in the channel.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel is not found or the message is not found in the given text channel.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_messages><div class="attr function"><a class=headerlink href=#RESTClient.fetch_messages>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>def </span><span class=name>fetch_messages</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   before: Union[<a href=../snowflakes.html#Unique>hikari.snowflakes.Unique</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, datetime.datetime, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   after: Union[<a href=../snowflakes.html#Unique>hikari.snowflakes.Unique</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, datetime.datetime, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED,<br>   around: Union[<a href=../snowflakes.html#Unique>hikari.snowflakes.Unique</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, datetime.datetime, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../iterators.html#LazyIterator>hikari.iterators.LazyIterator</a>[<a href=../messages.html#Message>hikari.messages.Message</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>fetch_messages</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>before</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SearchableSnowflakeishOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>Unique</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>after</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SearchableSnowflakeishOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>Unique</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
        <span class=n>around</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SearchableSnowflakeishOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>Unique</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>iterators</span><span class=o>.</span><span class=n>LazyIterator</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>]:</span>
        <span class=sd>"""Browse the message history for a given text channel.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        This call is not a coroutine function, it returns a special type of</span>
<span class=sd>        lazy iterator that will perform API calls as you iterate across it,</span>
<span class=sd>        thus any errors documented below will happen then.</span>

<span class=sd>        See `hikari.iterators` for the full API for this iterator type.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to fetch messages in. This may be the object or</span>
<span class=sd>            the ID of an existing channel.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        before : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]</span>
<span class=sd>            If provided, fetch messages before this snowflake. If you provide</span>
<span class=sd>            a datetime object, it will be transformed into a snowflake. This</span>
<span class=sd>            may be any other Discord entity that has an ID. In this case, the</span>
<span class=sd>            date the object was first created will be used.</span>
<span class=sd>        after : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]</span>
<span class=sd>            If provided, fetch messages after this snowflake. If you provide</span>
<span class=sd>            a datetime object, it will be transformed into a snowflake. This</span>
<span class=sd>            may be any other Discord entity that has an ID. In this case, the</span>
<span class=sd>            date the object was first created will be used.</span>
<span class=sd>        around : hikari.undefined.UndefinedOr[snowflakes.SearchableSnowflakeishOr[hikari.snowflakes.Unique]]</span>
<span class=sd>            If provided, fetch messages around this snowflake. If you provide</span>
<span class=sd>            a datetime object, it will be transformed into a snowflake. This</span>
<span class=sd>            may be any other Discord entity that has an ID. In this case, the</span>
<span class=sd>            date the object was first created will be used.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.iterators.LazyIterator[hikari.messages.Message]</span>
<span class=sd>            An iterator to fetch the messages.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        TypeError</span>
<span class=sd>            If you specify more than one of `before`, `after`, `about`.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `READ_MESSAGE_HISTORY` in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Browse the message history for a given text channel.<h6 id=notes>Notes</h6><p>This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it, thus any errors documented below will happen then.<p>See <code><a href=../iterators.html>hikari.iterators</a></code> for the full API for this iterator type.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>]): The channel to fetch messages in. This may be the object or the ID of an existing channel.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>before</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[snowflakes.SearchableSnowflakeishOr[<a href=../snowflakes.html#Unique>hikari.snowflakes.Unique</a>]]): If provided, fetch messages before this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used.<li><strong>after</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[snowflakes.SearchableSnowflakeishOr[<a href=../snowflakes.html#Unique>hikari.snowflakes.Unique</a>]]): If provided, fetch messages after this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used.<li><strong>around</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[snowflakes.SearchableSnowflakeishOr[<a href=../snowflakes.html#Unique>hikari.snowflakes.Unique</a>]]): If provided, fetch messages around this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may be any other Discord entity that has an ID. In this case, the date the object was first created will be used.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../iterators.html#LazyIterator>hikari.iterators.LazyIterator</a>[<a href=../messages.html#Message>hikari.messages.Message</a>]</strong>: An iterator to fetch the messages.</ul><h6 id=raises>Raises</h6><ul><li><strong>TypeError</strong>: If you specify more than one of <code>before</code>, <code>after</code>, <code>about</code>.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>READ_MESSAGE_HISTORY</code> in the channel.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_my_connections><div class="attr function"><a class=headerlink href=#RESTClient.fetch_my_connections>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_my_connections</span><span class=signature>(self) -> Sequence[<a href=../applications.html#OwnConnection>hikari.applications.OwnConnection</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_my_connections</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>applications</span><span class=o>.</span><span class=n>OwnConnection</span><span class=p>]:</span>
        <span class=sd>"""Fetch the token's associated connections.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.applications.OwnConnection</span>
<span class=sd>            The token's associated connections.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the token's associated connections.<h6 id=returns>Returns</h6><ul><li><strong><a href=../applications.html#OwnConnection>hikari.applications.OwnConnection</a></strong>: The token's associated connections.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_my_guilds><div class="attr function"><a class=headerlink href=#RESTClient.fetch_my_guilds>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>def </span><span class=name>fetch_my_guilds</span><span class=signature>(<br>   self,<br>   *,<br>   newest_first: bool = False,<br>   start_at: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, datetime.datetime, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../iterators.html#LazyIterator>hikari.iterators.LazyIterator</a>[<a href=../applications.html#OwnGuild>hikari.applications.OwnGuild</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>fetch_my_guilds</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>newest_first</span><span class=p>:</span> <span class=nb>bool</span> <span class=o>=</span> <span class=kc>False</span><span class=p>,</span>
        <span class=n>start_at</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SearchableSnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>iterators</span><span class=o>.</span><span class=n>LazyIterator</span><span class=p>[</span><span class=n>applications</span><span class=o>.</span><span class=n>OwnGuild</span><span class=p>]:</span>
        <span class=sd>"""Fetch the token's associated guilds.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        This call is not a coroutine function, it returns a special type of</span>
<span class=sd>        lazy iterator that will perform API calls as you iterate across it,</span>
<span class=sd>        thus any errors documented below will happen then.</span>

<span class=sd>        See `hikari.iterators` for the full API for this iterator type.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        newest_first : bool</span>
<span class=sd>            Whether to fetch the newest first or the olders first.</span>
<span class=sd>            Defaults to `False`.</span>
<span class=sd>        start_at : hikari.undefined.UndefinedOr[hikari.snowflakes.SearchableSnowflakeishOr[hikari.guilds.PartialGuild]]</span>
<span class=sd>            If provided, will start at this snowflake. If you provide</span>
<span class=sd>            a datetime object, it will be transformed into a snowflake. This</span>
<span class=sd>            may also be a guild object. In this case, the</span>
<span class=sd>            date the object was first created will be used.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.iterators.LazyIterator[hikari.applications.OwnGuild]</span>
<span class=sd>            The token's associated guilds.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the token's associated guilds.<h6 id=notes>Notes</h6><p>This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it, thus any errors documented below will happen then.<p>See <code><a href=../iterators.html>hikari.iterators</a></code> for the full API for this iterator type.<h6 id=other-parameters>Other Parameters</h6><ul><li><strong>newest_first</strong> (bool): Whether to fetch the newest first or the olders first. Defaults to <code>False</code>.<li><strong>start_at</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SearchableSnowflakeishOr>hikari.snowflakes.SearchableSnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]]): If provided, will start at this snowflake. If you provide a datetime object, it will be transformed into a snowflake. This may also be a guild object. In this case, the date the object was first created will be used.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../iterators.html#LazyIterator>hikari.iterators.LazyIterator</a>[<a href=../applications.html#OwnGuild>hikari.applications.OwnGuild</a>]</strong>: The token's associated guilds.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_my_member><div class="attr function"><a class=headerlink href=#RESTClient.fetch_my_member>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_my_member</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> <a href=../guilds.html#Member>hikari.guilds.Member</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_my_member</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>])</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>Member</span><span class=p>:</span>
        <span class=sd>"""Fetch the Oauth token's associated member in a guild.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            This endpoint can only be used with a Bearer token. Using this</span>
<span class=sd>            with a Bot token will result in a `hikari.errors.UnauthorizedError`.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.Member</span>
<span class=sd>            The associated guild member.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the Oauth token's associated member in a guild.<p><em>Warning:</em> This endpoint can only be used with a Bearer token. Using this with a Bot token will result in a <code><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></code>.<h6 id=returns>Returns</h6><ul><li><strong><a href=../guilds.html#Member>hikari.guilds.Member</a></strong>: The associated guild member.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_my_user><div class="attr function"><a class=headerlink href=#RESTClient.fetch_my_user>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_my_user</span><span class=signature>(self) -> <a href=../users.html#OwnUser>hikari.users.OwnUser</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_my_user</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>users</span><span class=o>.</span><span class=n>OwnUser</span><span class=p>:</span>
        <span class=sd>"""Fetch the token's associated user.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.users.OwnUser</span>
<span class=sd>            The token's associated user.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the token's associated user.<h6 id=returns>Returns</h6><ul><li><strong><a href=../users.html#OwnUser>hikari.users.OwnUser</a></strong>: The token's associated user.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_pins><div class="attr function"><a class=headerlink href=#RESTClient.fetch_pins>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_pins</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> Sequence[<a href=../messages.html#Message>hikari.messages.Message</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_pins</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>]:</span>
        <span class=sd>"""Fetch the pinned messages in this text channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to fetch pins from. This may be the object or</span>
<span class=sd>            the ID of an existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.messages.Message]</span>
<span class=sd>            The pinned messages in this text channel.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `READ_MESSAGES` in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the pinned messages in this text channel.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>]): The channel to fetch pins from. This may be the object or the ID of an existing channel.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.Sequence[<a href=../messages.html#Message>hikari.messages.Message</a>]</strong>: The pinned messages in this text channel.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>READ_MESSAGES</code> in the channel.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_reactions_for_emoji><div class="attr function"><a class=headerlink href=#RESTClient.fetch_reactions_for_emoji>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>def </span><span class=name>fetch_reactions_for_emoji</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   message: Union[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   emoji: Union[str, <a href=../emojis.html#Emoji>hikari.emojis.Emoji</a>],<br>   emoji_id: Union[<a href=../emojis.html#CustomEmoji>hikari.emojis.CustomEmoji</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../iterators.html#LazyIterator>hikari.iterators.LazyIterator</a>[<a href=../users.html#User>hikari.users.User</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>fetch_reactions_for_emoji</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
        <span class=n>emoji</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>emojis</span><span class=o>.</span><span class=n>Emoji</span><span class=p>],</span>
        <span class=n>emoji_id</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>emojis</span><span class=o>.</span><span class=n>CustomEmoji</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>iterators</span><span class=o>.</span><span class=n>LazyIterator</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>User</span><span class=p>]:</span>
        <span class=sd>"""Fetch reactions for an emoji from a message.</span>

<span class=sd>        Notes</span>
<span class=sd>        -----</span>
<span class=sd>        This call is not a coroutine function, it returns a special type of</span>
<span class=sd>        lazy iterator that will perform API calls as you iterate across it,</span>
<span class=sd>        thus any errors documented below will happen then.</span>

<span class=sd>        See `hikari.iterators` for the full API for this iterator type.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel where the message to delete all reactions from is.</span>
<span class=sd>            This may be the object or the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to delete all reaction from. This may be the</span>
<span class=sd>            object or the ID of an existing message.</span>
<span class=sd>        emoji : typing.Union[str, hikari.emojis.Emoji]</span>
<span class=sd>            Object or name of the emoji to get the reactions for.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        emoji_id : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.emojis.CustomEmoji]]</span>
<span class=sd>            ID of the custom emoji to get the reactions for.</span>
<span class=sd>            This should only be provided when a custom emoji's name is passed</span>
<span class=sd>            for `emoji`.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.iterators.LazyIterator[hikari.users.User]</span>
<span class=sd>            An iterator to fetch the users.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid unicode emoji is given, or if the given custom emoji</span>
<span class=sd>            does not exist.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel or message is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch reactions for an emoji from a message.<h6 id=notes>Notes</h6><p>This call is not a coroutine function, it returns a special type of lazy iterator that will perform API calls as you iterate across it, thus any errors documented below will happen then.<p>See <code><a href=../iterators.html>hikari.iterators</a></code> for the full API for this iterator type.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>]): The channel where the message to delete all reactions from is. This may be the object or the ID of an existing channel.<li><strong>message</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>]): The message to delete all reaction from. This may be the object or the ID of an existing message.<li><strong>emoji</strong> (typing.Union[str, <a href=../emojis.html#Emoji>hikari.emojis.Emoji</a>]): Object or name of the emoji to get the reactions for.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>emoji_id</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../emojis.html#CustomEmoji>hikari.emojis.CustomEmoji</a>]]): ID of the custom emoji to get the reactions for. This should only be provided when a custom emoji's name is passed for <code>emoji</code>.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../iterators.html#LazyIterator>hikari.iterators.LazyIterator</a>[<a href=../users.html#User>hikari.users.User</a>]</strong>: An iterator to fetch the users.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If an invalid unicode emoji is given, or if the given custom emoji does not exist.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel or message is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_roles><div class="attr function"><a class=headerlink href=#RESTClient.fetch_roles>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_roles</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> Sequence[<a href=../guilds.html#Role>hikari.guilds.Role</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_roles</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>Role</span><span class=p>]:</span>
        <span class=sd>"""Fetch the roles of a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the roles from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.guilds.Role]</span>
<span class=sd>            The requested roles.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch the roles of a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to fetch the roles from. This may be the object or the ID of an existing guild.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.Sequence[<a href=../guilds.html#Role>hikari.guilds.Role</a>]</strong>: The requested roles.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_sticker><div class="attr function"><a class=headerlink href=#RESTClient.fetch_sticker>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_sticker</span><span class=signature>(<br>   self,<br>   sticker: Union[<a href=../stickers.html#PartialSticker>hikari.stickers.PartialSticker</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> Union[<a href=../stickers.html#GuildSticker>hikari.stickers.GuildSticker</a>, <a href=../stickers.html#StandardSticker>hikari.stickers.StandardSticker</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_sticker</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>sticker</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>stickers</span><span class=o>.</span><span class=n>PartialSticker</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>stickers</span><span class=o>.</span><span class=n>GuildSticker</span><span class=p>,</span> <span class=n>stickers</span><span class=o>.</span><span class=n>StandardSticker</span><span class=p>]:</span>
        <span class=sd>"""Fetch a sticker.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        sticker : snowflakes.SnowflakeishOr[stickers.PartialSticker]</span>
<span class=sd>            The sticker to fetch. This can be a sticker object or the</span>
<span class=sd>            ID of an existing sticker.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Union[hikari.stickers.GuildSticker, hikari.stickers.StandardSticker]</span>
<span class=sd>            The requested sticker.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the sticker is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch a sticker.<h6 id=parameters>Parameters</h6><ul><li><strong>sticker</strong> (snowflakes.SnowflakeishOr[stickers.PartialSticker]): The sticker to fetch. This can be a sticker object or the ID of an existing sticker.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.Union[<a href=../stickers.html#GuildSticker>hikari.stickers.GuildSticker</a>, <a href=../stickers.html#StandardSticker>hikari.stickers.StandardSticker</a>]</strong>: The requested sticker.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the sticker is not found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_template><div class="attr function"><a class=headerlink href=#RESTClient.fetch_template>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_template</span><span class=signature>(<br>   self,<br>   template: Union[str, <a href=../templates.html#Template>hikari.templates.Template</a>]<br>) -> <a href=../templates.html#Template>hikari.templates.Template</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_template</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>template</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>])</span> <span class=o>-></span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild template.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        template : typing.Union[str, hikari.templates.Template]</span>
<span class=sd>            The object or string code of the template to fetch.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.templates.Template</span>
<span class=sd>            The object of the found template.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the template was not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch a guild template.<h6 id=parameters>Parameters</h6><ul><li><strong>template</strong> (typing.Union[str, <a href=../templates.html#Template>hikari.templates.Template</a>]): The object or string code of the template to fetch.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../templates.html#Template>hikari.templates.Template</a></strong>: The object of the found template.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the template was not found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_user><div class="attr function"><a class=headerlink href=#RESTClient.fetch_user>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_user</span><span class=signature>(<br>   self,<br>   user: Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> <a href=../users.html#User>hikari.users.User</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_user</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>])</span> <span class=o>-></span> <span class=n>users</span><span class=o>.</span><span class=n>User</span><span class=p>:</span>
        <span class=sd>"""Fetch a user.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to fetch. This can be the object</span>
<span class=sd>            or the ID of an existing user.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.users.User</span>
<span class=sd>            The requested user</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the user is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch a user.<h6 id=parameters>Parameters</h6><ul><li><strong>user</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>]): The user to fetch. This can be the object or the ID of an existing user.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../users.html#User>hikari.users.User</a></strong>: The requested user</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the user is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_vanity_url><div class="attr function"><a class=headerlink href=#RESTClient.fetch_vanity_url>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_vanity_url</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> <a href=../invites.html#VanityURL>hikari.invites.VanityURL</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_vanity_url</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>])</span> <span class=o>-></span> <span class=n>invites</span><span class=o>.</span><span class=n>VanityURL</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild's vanity url.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the vanity url from. This can</span>
<span class=sd>            be the object or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.invites.VanityURL</span>
<span class=sd>            The requested invite.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch a guild's vanity url.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to fetch the vanity url from. This can be the object or the ID of an existing guild.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../invites.html#VanityURL>hikari.invites.VanityURL</a></strong>: The requested invite.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are not part of the guild.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_voice_regions><div class="attr function"><a class=headerlink href=#RESTClient.fetch_voice_regions>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_voice_regions</span><span class=signature>(self) -> Sequence[<a href=../voices.html#VoiceRegion>hikari.voices.VoiceRegion</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_voice_regions</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>voices</span><span class=o>.</span><span class=n>VoiceRegion</span><span class=p>]:</span>
        <span class=sd>"""Fetch available voice regions.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This endpoint doesn't return VIP voice regions.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.voices.VoiceRegion]</span>
<span class=sd>            The available voice regions.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch available voice regions.<p><em>Note:</em> This endpoint doesn't return VIP voice regions.<h6 id=returns>Returns</h6><ul><li><strong>typing.Sequence[<a href=../voices.html#VoiceRegion>hikari.voices.VoiceRegion</a>]</strong>: The available voice regions.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_webhook><div class="attr function"><a class=headerlink href=#RESTClient.fetch_webhook>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_webhook</span><span class=signature>(<br>   self,<br>   webhook: Union[<a href=../webhooks.html#PartialWebhook>hikari.webhooks.PartialWebhook</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   token: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../webhooks.html#PartialWebhook>hikari.webhooks.PartialWebhook</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_webhook</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>webhook</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>PartialWebhook</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>token</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>webhooks</span><span class=o>.</span><span class=n>PartialWebhook</span><span class=p>:</span>
        <span class=sd>"""Fetch an existing webhook.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        webhook : hikari.snowflakes.SnowflakeishOr[hikari.webhooks.PartialWebhook]</span>
<span class=sd>            The webhook to fetch. This may be the object or the ID</span>
<span class=sd>            of an existing webhook.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        token : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the webhoook token that will be used to fetch</span>
<span class=sd>            the webhook instead of the token the client was initialized with.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.webhooks.PartialWebhook</span>
<span class=sd>            The requested webhook.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_WEBHOOKS` permission when not</span>
<span class=sd>            using a token.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the webhook is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch an existing webhook.<h6 id=parameters>Parameters</h6><ul><li><strong>webhook</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../webhooks.html#PartialWebhook>hikari.webhooks.PartialWebhook</a>]): The webhook to fetch. This may be the object or the ID of an existing webhook.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>token</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the webhoook token that will be used to fetch the webhook instead of the token the client was initialized with.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../webhooks.html#PartialWebhook>hikari.webhooks.PartialWebhook</a></strong>: The requested webhook.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_WEBHOOKS</code> permission when not using a token.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the webhook is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_webhook_message><div class="attr function"><a class=headerlink href=#RESTClient.fetch_webhook_message>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_webhook_message</span><span class=signature>(<br>   self,<br>   webhook: Union[<a href=../webhooks.html#ExecutableWebhook>hikari.webhooks.ExecutableWebhook</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   token: str,<br>   message: Union[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> <a href=../messages.html#Message>hikari.messages.Message</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_webhook_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=c1># MyPy might not say this but SnowflakeishOr[ExecutableWebhook] isn't valid as ExecutableWebhook isn't Unique</span>
        <span class=n>webhook</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>webhooks</span><span class=o>.</span><span class=n>ExecutableWebhook</span><span class=p>,</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>Snowflakeish</span><span class=p>],</span>
        <span class=n>token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>messages_</span><span class=o>.</span><span class=n>Message</span><span class=p>:</span>
        <span class=sd>"""Fetch an old message sent by the webhook.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        webhook : typing.Union[hikari.snowflakes.Snowflakeish, hikari.webhooks.ExecutableWebhook]</span>
<span class=sd>            The webhook to execute. This may be the object</span>
<span class=sd>            or the ID of an existing webhook.</span>
<span class=sd>        token: str</span>
<span class=sd>            The webhook token.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to fetch. This may be the object or the ID of an</span>
<span class=sd>            existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.messages.Message</span>
<span class=sd>            The requested message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the webhook is not found or the webhook's message wasn't found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch an old message sent by the webhook.<h6 id=parameters>Parameters</h6><ul><li><strong>webhook</strong> (typing.Union[<a href=../snowflakes.html#Snowflakeish>hikari.snowflakes.Snowflakeish</a>, <a href=../webhooks.html#ExecutableWebhook>hikari.webhooks.ExecutableWebhook</a>]): The webhook to execute. This may be the object or the ID of an existing webhook.<li><strong>token</strong> (str): The webhook token.<li><strong>message</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>]): The message to fetch. This may be the object or the ID of an existing channel.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../messages.html#Message>hikari.messages.Message</a></strong>: The requested message.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the webhook is not found or the webhook's message wasn't found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_welcome_screen><div class="attr function"><a class=headerlink href=#RESTClient.fetch_welcome_screen>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_welcome_screen</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> <a href=../guilds.html#WelcomeScreen>hikari.guilds.WelcomeScreen</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_welcome_screen</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>])</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>WelcomeScreen</span><span class=p>:</span>
        <span class=sd>"""Fetch a guild's welcome screen.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or ID of the guild to fetch the welcome screen for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.WelcomeScreen</span>
<span class=sd>            The requested welcome screen.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found or the welcome screen has never been set</span>
<span class=sd>            for this guild (if the welcome screen has been set for a guild</span>
<span class=sd>            before and then disabled you should still be able to fetch it).</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch a guild's welcome screen.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): Object or ID of the guild to fetch the welcome screen for.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../guilds.html#WelcomeScreen>hikari.guilds.WelcomeScreen</a></strong>: The requested welcome screen.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found or the welcome screen has never been set for this guild (if the welcome screen has been set for a guild before and then disabled you should still be able to fetch it).<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.fetch_widget><div class="attr function"><a class=headerlink href=#RESTClient.fetch_widget>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>fetch_widget</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> <a href=../guilds.html#GuildWidget>hikari.guilds.GuildWidget</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_widget</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>])</span> <span class=o>-></span> <span class=n>guilds</span><span class=o>.</span><span class=n>GuildWidget</span><span class=p>:</span>
        <span class=sd>"""Fetch a guilds's widget.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to fetch the widget from. This can be the object</span>
<span class=sd>            or the ID of an existing guild.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.guilds.GuildWidget</span>
<span class=sd>            The requested guild widget.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_GUILD` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Fetch a guilds's widget.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to fetch the widget from. This can be the object or the ID of an existing guild.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../guilds.html#GuildWidget>hikari.guilds.GuildWidget</a></strong>: The requested guild widget.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_GUILD</code> permission.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.follow_channel><div class="attr function"><a class=headerlink href=#RESTClient.follow_channel>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>follow_channel</span><span class=signature>(<br>   self,<br>   news_channel: Union[<a href=../channels.html#GuildNewsChannel>hikari.channels.GuildNewsChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   target_channel: Union[<a href=../channels.html#GuildChannel>hikari.channels.GuildChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> <a href=../channels.html#ChannelFollow>hikari.channels.ChannelFollow</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>follow_channel</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>news_channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildNewsChannel</span><span class=p>],</span>
        <span class=n>target_channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>channels_</span><span class=o>.</span><span class=n>ChannelFollow</span><span class=p>:</span>
        <span class=sd>"""Follow a news channel to send messages to a target channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        news_channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildNewsChannel]</span>
<span class=sd>            The object or ID of the news channel to follow.</span>
<span class=sd>        target_channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]</span>
<span class=sd>            The object or ID of the channel to target.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.channels.ChannelFollow</span>
<span class=sd>            Information about the new relationship that was made.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If you try to follow a channel that's not a news channel or if the</span>
<span class=sd>            target channel has reached it's webhook limit, which is 10 at the</span>
<span class=sd>            time of writing.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_WEBHOOKS` permission in the target</span>
<span class=sd>            channel or are missing the `VIEW_CHANNEL` permission in the origin</span>
<span class=sd>            channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the origin or target channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Follow a news channel to send messages to a target channel.<h6 id=parameters>Parameters</h6><ul><li><strong>news_channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildNewsChannel>hikari.channels.GuildNewsChannel</a>]): The object or ID of the news channel to follow.<li><strong>target_channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildChannel>hikari.channels.GuildChannel</a>]): The object or ID of the channel to target.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../channels.html#ChannelFollow>hikari.channels.ChannelFollow</a></strong>: Information about the new relationship that was made.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If you try to follow a channel that's not a news channel or if the target channel has reached it's webhook limit, which is 10 at the time of writing.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_WEBHOOKS</code> permission in the target channel or are missing the <code>VIEW_CHANNEL</code> permission in the origin channel.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the origin or target channel is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.guild_builder><div class="attr function"><a class=headerlink href=#RESTClient.guild_builder>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>def </span><span class=name>guild_builder</span><span class=signature>(self, name: str, /) -> <a href=special_endpoints.html#GuildBuilder>hikari.api.special_endpoints.GuildBuilder</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>guild_builder</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=o>/</span><span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>GuildBuilder</span><span class=p>:</span>
        <span class=sd>"""Make a guild builder to create a guild with.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This endpoint can only be used by bots in less than 10 guilds.</span>

<span class=sd>        .. note::</span>
<span class=sd>            The exceptions on this endpoint will only be raised once</span>
<span class=sd>            `hikari.api.special_endpoints.GuildBuilder.create` is called.</span>
<span class=sd>            Invoking this function itself will not raise any of</span>
<span class=sd>            the above types.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        name : str</span>
<span class=sd>            The new guilds name.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.GuildBuilder</span>
<span class=sd>            The guild builder to use. This will allow to create a guild</span>
<span class=sd>            later with `hikari.api.special_endpoints.GuildBuilder.create`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value or if you</span>
<span class=sd>            call this as a bot that's in more than 10 guilds.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>

<span class=sd>        See Also</span>
<span class=sd>        --------</span>
<span class=sd>        `hikari.api.special_endpoints.GuildBuilder`</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Make a guild builder to create a guild with.<p><em>Note:</em> This endpoint can only be used by bots in less than 10 guilds.<p><em>Note:</em> The exceptions on this endpoint will only be raised once <code><a href=special_endpoints.html#GuildBuilder.create>hikari.api.special_endpoints.GuildBuilder.create</a></code> is called. Invoking this function itself will not raise any of the above types.<h6 id=parameters>Parameters</h6><ul><li><strong>name</strong> (str): The new guilds name.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=special_endpoints.html#GuildBuilder>hikari.api.special_endpoints.GuildBuilder</a></strong>: The guild builder to use. This will allow to create a guild later with <code><a href=special_endpoints.html#GuildBuilder.create>hikari.api.special_endpoints.GuildBuilder.create</a></code>.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value or if you call this as a bot that's in more than 10 guilds.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul><h6 id=see-also>See Also</h6><p><code><a href=special_endpoints.html#GuildBuilder>hikari.api.special_endpoints.GuildBuilder</a></code></div></div><div id=RESTClient.interaction_autocomplete_builder><div class="attr function"><a class=headerlink href=#RESTClient.interaction_autocomplete_builder>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>def </span><span class=name>interaction_autocomplete_builder</span><span class=signature>(<br>   self,<br>   choices: Sequence[<a href=../commands.html#CommandChoice>hikari.commands.CommandChoice</a>]<br>) -> <a href=special_endpoints.html#InteractionAutocompleteBuilder>hikari.api.special_endpoints.InteractionAutocompleteBuilder</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>interaction_autocomplete_builder</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>choices</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandChoice</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>InteractionAutocompleteBuilder</span><span class=p>:</span>
        <span class=sd>"""Create a builder for an autocomplete interaction response.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.InteractionAutocompleteBuilder</span>
<span class=sd>            The autocomplete interaction response builder object.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Create a builder for an autocomplete interaction response.<h6 id=returns>Returns</h6><ul><li><strong><a href=special_endpoints.html#InteractionAutocompleteBuilder>hikari.api.special_endpoints.InteractionAutocompleteBuilder</a></strong>: The autocomplete interaction response builder object.</ul></div></div><div id=RESTClient.interaction_deferred_builder><div class="attr function"><a class=headerlink href=#RESTClient.interaction_deferred_builder>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>def </span><span class=name>interaction_deferred_builder</span><span class=signature>(<br>   self,<br>   type: Union[<a href=../interactions/base_interactions.html#ResponseType>hikari.interactions.base_interactions.ResponseType</a>, int],<br>   /<br>) -> <a href=special_endpoints.html#InteractionDeferredBuilder>hikari.api.special_endpoints.InteractionDeferredBuilder</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>interaction_deferred_builder</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=nb>type</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>base_interactions</span><span class=o>.</span><span class=n>ResponseType</span><span class=p>,</span> <span class=nb>int</span><span class=p>],</span> <span class=o>/</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>InteractionDeferredBuilder</span><span class=p>:</span>
        <span class=sd>"""Create a builder for a deferred message interaction response.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        type: typing.Union[hikari.interactions.base_interactions.ResponseType, int]</span>
<span class=sd>            The type of deferred message response this builder is for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.InteractionDeferredBuilder</span>
<span class=sd>            The deferred message interaction response builder object.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Create a builder for a deferred message interaction response.<h6 id=parameters>Parameters</h6><ul><li><strong>type</strong> (typing.Union[<a href=../interactions/base_interactions.html#ResponseType>hikari.interactions.base_interactions.ResponseType</a>, int]): The type of deferred message response this builder is for.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=special_endpoints.html#InteractionDeferredBuilder>hikari.api.special_endpoints.InteractionDeferredBuilder</a></strong>: The deferred message interaction response builder object.</ul></div></div><div id=RESTClient.interaction_message_builder><div class="attr function"><a class=headerlink href=#RESTClient.interaction_message_builder>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>def </span><span class=name>interaction_message_builder</span><span class=signature>(<br>   self,<br>   type: Union[<a href=../interactions/base_interactions.html#ResponseType>hikari.interactions.base_interactions.ResponseType</a>, int],<br>   /<br>) -> <a href=special_endpoints.html#InteractionMessageBuilder>hikari.api.special_endpoints.InteractionMessageBuilder</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>interaction_message_builder</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=nb>type</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>base_interactions</span><span class=o>.</span><span class=n>ResponseType</span><span class=p>,</span> <span class=nb>int</span><span class=p>],</span> <span class=o>/</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>InteractionMessageBuilder</span><span class=p>:</span>
        <span class=sd>"""Create a builder for a message interaction response.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        type : typing.Union[hikari.interactions.base_interactions.ResponseType, int]</span>
<span class=sd>            The type of message response this builder is for.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.InteractionMessageBuilder</span>
<span class=sd>            The interaction message response builder object.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Create a builder for a message interaction response.<h6 id=parameters>Parameters</h6><ul><li><strong>type</strong> (typing.Union[<a href=../interactions/base_interactions.html#ResponseType>hikari.interactions.base_interactions.ResponseType</a>, int]): The type of message response this builder is for.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=special_endpoints.html#InteractionMessageBuilder>hikari.api.special_endpoints.InteractionMessageBuilder</a></strong>: The interaction message response builder object.</ul></div></div><div id=RESTClient.kick_member><div class="attr function"><a class=headerlink href=#RESTClient.kick_member>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>kick_member</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   user: Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>kick_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Alias of `hikari.impl.rest.RESTClient.kick_user`."""</span>
</pre></div></details><div class=docstring><p>Alias of <code><a href=../impl/rest.html#RESTClient.kick_user>hikari.impl.rest.RESTClient.kick_user</a></code>.</div></div><div id=RESTClient.kick_user><div class="attr function"><a class=headerlink href=#RESTClient.kick_user>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>kick_user</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   user: Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>kick_user</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Kick a member from a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to kick the member from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to kick. This may be the object</span>
<span class=sd>            or the ID of an existing user.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `KICK_MEMBERS` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or user are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Kick a member from a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to kick the member from. This may be the object or the ID of an existing guild.<li><strong>user</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>]): The user to kick. This may be the object or the ID of an existing user.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>KICK_MEMBERS</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild or user are not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.leave_guild><div class="attr function"><a class=headerlink href=#RESTClient.leave_guild>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>leave_guild</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   /<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>leave_guild</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span> <span class=o>/</span><span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Leave a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to leave. This may be the object or</span>
<span class=sd>            the ID of an existing guild.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found or you own the guild.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Leave a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to leave. This may be the object or the ID of an existing guild.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found or you own the guild.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.pin_message><div class="attr function"><a class=headerlink href=#RESTClient.pin_message>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>pin_message</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   message: Union[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>pin_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Pin an existing message in the given text channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to pin a message in. This may be the object or</span>
<span class=sd>            the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to pin. This may be the object or the ID</span>
<span class=sd>            of an existing message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_MESSAGES` in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found, or if the message does not exist in</span>
<span class=sd>            the given channel.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Pin an existing message in the given text channel.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>]): The channel to pin a message in. This may be the object or the ID of an existing channel.<li><strong>message</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>]): The message to pin. This may be the object or the ID of an existing message.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_MESSAGES</code> in the channel.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel is not found, or if the message does not exist in the given channel.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.refresh_access_token><div class="attr function"><a class=headerlink href=#RESTClient.refresh_access_token>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>refresh_access_token</span><span class=signature>(<br>   self,<br>   client: Union[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   client_secret: str,<br>   refresh_token: str,<br>   *,<br>   scopes: Union[Sequence[Union[<a href=../applications.html#OAuth2Scope>hikari.applications.OAuth2Scope</a>, str]], <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> <a href=../applications.html#OAuth2AuthorizationToken>hikari.applications.OAuth2AuthorizationToken</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>refresh_access_token</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>client</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>client_secret</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>refresh_token</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>scopes</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span>
            <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>applications</span><span class=o>.</span><span class=n>OAuth2Scope</span><span class=p>,</span> <span class=nb>str</span><span class=p>]]</span>
        <span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>applications</span><span class=o>.</span><span class=n>OAuth2AuthorizationToken</span><span class=p>:</span>
        <span class=sd>"""Refresh an access token.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            As of writing this Discord currently ignores any passed scopes,</span>
<span class=sd>            therefore you should use</span>
<span class=sd>            `hikari.applications.OAuth2AuthorizationToken.scopes` to validate</span>
<span class=sd>            that the expected scopes were actually authorized here.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        client : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to authorize with.</span>
<span class=sd>        client_secret : str</span>
<span class=sd>            Secret of the application to authorize with.</span>
<span class=sd>        refresh_token : str</span>
<span class=sd>            The refresh token to use.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        scopes : typing.Sequence[typing.Union[hikari.applications.OAuth2Scope, str]]</span>
<span class=sd>            The scope of the access request.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.applications.OAuth2AuthorizationToken</span>
<span class=sd>            Object of the authorized OAuth2 token.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If an invalid redirect uri or refresh_token is passed.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            When an client or client secret is passed.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Refresh an access token.<p><em>Warning:</em> As of writing this Discord currently ignores any passed scopes, therefore you should use <code><a href=../applications.html#OAuth2AuthorizationToken.scopes>hikari.applications.OAuth2AuthorizationToken.scopes</a></code> to validate that the expected scopes were actually authorized here.<h6 id=parameters>Parameters</h6><ul><li><strong>client</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>]): Object or ID of the application to authorize with.<li><strong>client_secret</strong> (str): Secret of the application to authorize with.<li><strong>refresh_token</strong> (str): The refresh token to use.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>scopes</strong> (typing.Sequence[typing.Union[<a href=../applications.html#OAuth2Scope>hikari.applications.OAuth2Scope</a>, str]]): The scope of the access request.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../applications.html#OAuth2AuthorizationToken>hikari.applications.OAuth2AuthorizationToken</a></strong>: Object of the authorized OAuth2 token.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If an invalid redirect uri or refresh_token is passed.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: When an client or client secret is passed.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.remove_role_from_member><div class="attr function"><a class=headerlink href=#RESTClient.remove_role_from_member>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>remove_role_from_member</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   user: Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   role: Union[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>remove_role_from_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=n>role</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Remove a role from a member.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild where the member is in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to remove the role from. This may be the</span>
<span class=sd>            object or the ID of an existing user.</span>
<span class=sd>        role : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]</span>
<span class=sd>            The role to remove. This may be the object or the</span>
<span class=sd>            ID of an existing role.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_ROLES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild, user or role are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Remove a role from a member.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild where the member is in. This may be the object or the ID of an existing guild.<li><strong>user</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>]): The user to remove the role from. This may be the object or the ID of an existing user.<li><strong>role</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>]): The role to remove. This may be the object or the ID of an existing role.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_ROLES</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild, user or role are not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.reposition_channels><div class="attr function"><a class=headerlink href=#RESTClient.reposition_channels>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>reposition_channels</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   positions: Mapping[int, Union[<a href=../channels.html#GuildChannel>hikari.channels.GuildChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]]<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>reposition_channels</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>positions</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Mapping</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>GuildChannel</span><span class=p>]],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Reposition the channels in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to reposition the channels in. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        positions : typing.Mapping[int, hikari.snowflakes.SnowflakeishOr[hikari.channels.GuildChannel]]</span>
<span class=sd>            A mapping of of the object or the ID of an existing channel to</span>
<span class=sd>            the new position, relative to their parent category, if any.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_CHANNEL` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Reposition the channels in a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to reposition the channels in. This may be the object or the ID of an existing guild.<li><strong>positions</strong> (typing.Mapping[int, <a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#GuildChannel>hikari.channels.GuildChannel</a>]]): A mapping of of the object or the ID of an existing channel to the new position, relative to their parent category, if any.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_CHANNEL</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.reposition_roles><div class="attr function"><a class=headerlink href=#RESTClient.reposition_roles>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>reposition_roles</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   positions: Mapping[int, Union[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]]<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>reposition_roles</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>positions</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Mapping</span><span class=p>[</span><span class=nb>int</span><span class=p>,</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialRole</span><span class=p>]],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Reposition the roles in a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to reposition the roles in. This may be</span>
<span class=sd>            the object or the ID of an existing guild.</span>
<span class=sd>        positions : typing.Mapping[int, hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialRole]]</span>
<span class=sd>            A mapping of the position to the role.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_ROLES` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Reposition the roles in a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to reposition the roles in. This may be the object or the ID of an existing guild.<li><strong>positions</strong> (typing.Mapping[int, <a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialRole>hikari.guilds.PartialRole</a>]]): A mapping of the position to the role.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_ROLES</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.revoke_access_token><div class="attr function"><a class=headerlink href=#RESTClient.revoke_access_token>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>revoke_access_token</span><span class=signature>(<br>   self,<br>   client: Union[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   client_secret: str,<br>   token: Union[str, <a href=../applications.html#PartialOAuth2Token>hikari.applications.PartialOAuth2Token</a>]<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>revoke_access_token</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>client</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>client_secret</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>token</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>applications</span><span class=o>.</span><span class=n>PartialOAuth2Token</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Revoke an OAuth2 token.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        client : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to authorize with.</span>
<span class=sd>        client_secret : str</span>
<span class=sd>            Secret of the application to authorize with.</span>
<span class=sd>        token : typing.Union[str, hikari.applications.PartialOAuth2Token]</span>
<span class=sd>            Object or string of the access token to revoke.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            When an client or client secret is passed.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Revoke an OAuth2 token.<h6 id=parameters>Parameters</h6><ul><li><strong>client</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>]): Object or ID of the application to authorize with.<li><strong>client_secret</strong> (str): Secret of the application to authorize with.<li><strong>token</strong> (typing.Union[str, <a href=../applications.html#PartialOAuth2Token>hikari.applications.PartialOAuth2Token</a>]): Object or string of the access token to revoke.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: When an client or client secret is passed.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.search_members><div class="attr function"><a class=headerlink href=#RESTClient.search_members>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>search_members</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   name: str<br>) -> Sequence[<a href=../guilds.html#Member>hikari.guilds.Member</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>search_members</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>Member</span><span class=p>]:</span>
        <span class=sd>"""Search the members in a guild by nickname and username.</span>

<span class=sd>        .. note::</span>
<span class=sd>            Unlike `RESTClient.fetch_members` this endpoint isn't paginated and</span>
<span class=sd>            therefore will return all the members in one go rather than needing</span>
<span class=sd>            to be asynchronously iterated over.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The object or ID of the guild to search members in.</span>
<span class=sd>        name : str</span>
<span class=sd>            The query to match username(s) and nickname(s) against.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.guilds.Member]</span>
<span class=sd>            A sequence of the members who matched the provided `name`.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Search the members in a guild by nickname and username.<p><em>Note:</em> Unlike <code><a href=#RESTClient.fetch_members>RESTClient.fetch_members</a></code> this endpoint isn't paginated and therefore will return all the members in one go rather than needing to be asynchronously iterated over.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The object or ID of the guild to search members in.<li><strong>name</strong> (str): The query to match username(s) and nickname(s) against.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.Sequence[<a href=../guilds.html#Member>hikari.guilds.Member</a>]</strong>: A sequence of the members who matched the provided <code>name</code>.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.set_application_command_permissions><div class="attr function"><a class=headerlink href=#RESTClient.set_application_command_permissions>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>set_application_command_permissions</span><span class=signature>(<br>   self,<br>   application: Union[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   command: Union[<a href=../commands.html#PartialCommand>hikari.commands.PartialCommand</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   permissions: Sequence[<a href=../commands.html#CommandPermission>hikari.commands.CommandPermission</a>]<br>) -> <a href=../commands.html#GuildCommandPermissions>hikari.commands.GuildCommandPermissions</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>set_application_command_permissions</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>command</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>],</span>
        <span class=n>permissions</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandPermission</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>commands</span><span class=o>.</span><span class=n>GuildCommandPermissions</span><span class=p>:</span>
        <span class=sd>"""Set permissions for a specific command.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This overwrites any previously set permissions.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to set the command permissions for.</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]]</span>
<span class=sd>            Object or ID of the guild to set the command permissions for.</span>
<span class=sd>        command : hikari.snowflakes.SnowflakeishOr[hikari.commands.PartialCommand]</span>
<span class=sd>            Object or ID of the command to set the permissions for.</span>
<span class=sd>        permissions : typing.Sequence[hikari.commands.CommandPermission]</span>
<span class=sd>            Sequence of up to 10 of the permission objects to set.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.commands.GuildCommandPermissions</span>
<span class=sd>            Object of the set permissions.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands or guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application or command isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Set permissions for a specific command.<p><em>Note:</em> This overwrites any previously set permissions.<h6 id=parameters>Parameters</h6><ul><li><strong>application</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>]): Object or ID of the application to set the command permissions for.<li><strong>guild</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]]): Object or ID of the guild to set the command permissions for.<li><strong>command</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../commands.html#PartialCommand>hikari.commands.PartialCommand</a>]): Object or ID of the command to set the permissions for.<li><strong>permissions</strong> (typing.Sequence[<a href=../commands.html#CommandPermission>hikari.commands.CommandPermission</a>]): Sequence of up to 10 of the permission objects to set.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../commands.html#GuildCommandPermissions>hikari.commands.GuildCommandPermissions</a></strong>: Object of the set permissions.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you cannot access the provided application's commands or guild.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the provided application or command isn't found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.set_application_commands><div class="attr function"><a class=headerlink href=#RESTClient.set_application_commands>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>set_application_commands</span><span class=signature>(<br>   self,<br>   application: Union[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   commands: Sequence[<a href=special_endpoints.html#CommandBuilder>hikari.api.special_endpoints.CommandBuilder</a>],<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> Sequence[<a href=../commands.html#PartialCommand>hikari.commands.PartialCommand</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>set_application_commands</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>commands</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>special_endpoints</span><span class=o>.</span><span class=n>CommandBuilder</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>]]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>]:</span>
        <span class=sd>"""Set the commands for an application.</span>

<span class=sd>        .. warning::</span>
<span class=sd>            Any existing commands not included in the provided commands array</span>
<span class=sd>            will be deleted.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to create a command for.</span>
<span class=sd>        commands: typing.Sequence[hikari.api.special_endpoints.CommandBuilder]</span>
<span class=sd>            A sequence of up to 100 initialised command builder objects of the</span>
<span class=sd>            commands to set for this the application.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            Object or ID of the specific guild to set the commands for.</span>
<span class=sd>            If left as `hikari.undefined.UNDEFINED` then this set the global</span>
<span class=sd>            commands rather than guild specific commands.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.commands.PartialCommand]</span>
<span class=sd>            A sequence of the set command objects.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application isn't found.</span>
<span class=sd>        hikari.errors.BadRequestError</span>
<span class=sd>            If any of the fields that are passed have an invalid value.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Set the commands for an application.<p><em>Warning:</em> Any existing commands not included in the provided commands array will be deleted.<h6 id=parameters>Parameters</h6><ul><li><strong>application</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>]): Object or ID of the application to create a command for.<li><strong>commands</strong> (typing.Sequence[<a href=special_endpoints.html#CommandBuilder>hikari.api.special_endpoints.CommandBuilder</a>]): A sequence of up to 100 initialised command builder objects of the commands to set for this the application.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>guild</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): Object or ID of the specific guild to set the commands for. If left as <code><a href=../undefined.html#UNDEFINED>hikari.undefined.UNDEFINED</a></code> then this set the global commands rather than guild specific commands.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.Sequence[<a href=../commands.html#PartialCommand>hikari.commands.PartialCommand</a>]</strong>: A sequence of the set command objects.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you cannot access the provided application's commands.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the provided application isn't found.<li><strong><a href=../errors.html#BadRequestError>hikari.errors.BadRequestError</a></strong>: If any of the fields that are passed have an invalid value.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.set_application_guild_commands_permissions><div class="attr function"><a class=headerlink href=#RESTClient.set_application_guild_commands_permissions>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>set_application_guild_commands_permissions</span><span class=signature>(<br>   self,<br>   application: Union[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   permissions: Mapping[Union[<a href=../commands.html#PartialCommand>hikari.commands.PartialCommand</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int], Sequence[<a href=../commands.html#CommandPermission>hikari.commands.CommandPermission</a>]]<br>) -> Sequence[<a href=../commands.html#GuildCommandPermissions>hikari.commands.GuildCommandPermissions</a>]:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>set_application_guild_commands_permissions</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>application</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialApplication</span><span class=p>],</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>permissions</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Mapping</span><span class=p>[</span>
            <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>PartialCommand</span><span class=p>],</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>CommandPermission</span><span class=p>]</span>
        <span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=n>commands</span><span class=o>.</span><span class=n>GuildCommandPermissions</span><span class=p>]:</span>
        <span class=sd>"""Set permissions in a guild for multiple commands.</span>

<span class=sd>        .. note::</span>
<span class=sd>            This overwrites any previously set permissions for the specified</span>
<span class=sd>            commands.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        application: hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialApplication]</span>
<span class=sd>            Object or ID of the application to set the command permissions for.</span>
<span class=sd>        guild : hikari.undefined.UndefinedOr[hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]]</span>
<span class=sd>            Object or ID of the guild to set the command permissions for.</span>
<span class=sd>        permissions : typing.Mapping[hikari.snowflakes.SnowflakeishOr[hikari.commands.PartialCommand], typing.Sequence[hikari.commands.CommandPermission]]</span>
<span class=sd>            Mapping of objects and/or IDs of commands to sequences of the commands</span>
<span class=sd>            to set for the specified guild.</span>

<span class=sd>            .. warning::</span>
<span class=sd>                Only a maximum of up to 10 permissions can be set per command.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        typing.Sequence[hikari.commands.GuildCommandPermissions]</span>
<span class=sd>            Sequence of the set guild command permissions.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you cannot access the provided application's commands or guild.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the provided application or command isn't found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>  <span class=c1># noqa: E501 - Line too long</span>
</pre></div></details><div class=docstring><p>Set permissions in a guild for multiple commands.<p><em>Note:</em> This overwrites any previously set permissions for the specified commands.<h6 id=parameters>Parameters</h6><ul><li><strong>application</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialApplication>hikari.guilds.PartialApplication</a>]): Object or ID of the application to set the command permissions for.<li><strong>guild</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]]): Object or ID of the guild to set the command permissions for.<li><p><strong>permissions</strong> (typing.Mapping[<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../commands.html#PartialCommand>hikari.commands.PartialCommand</a>], typing.Sequence[<a href=../commands.html#CommandPermission>hikari.commands.CommandPermission</a>]]): Mapping of objects and/or IDs of commands to sequences of the commands to set for the specified guild.</p> <p><em>Warning:</em> Only a maximum of up to 10 permissions can be set per command.</ul><h6 id=returns>Returns</h6><ul><li><strong>typing.Sequence[<a href=../commands.html#GuildCommandPermissions>hikari.commands.GuildCommandPermissions</a>]</strong>: Sequence of the set guild command permissions.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you cannot access the provided application's commands or guild.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the provided application or command isn't found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.slash_command_builder><div class="attr function"><a class=headerlink href=#RESTClient.slash_command_builder>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>def </span><span class=name>slash_command_builder</span><span class=signature>(<br>   self,<br>   name: str,<br>   description: str<br>) -> <a href=special_endpoints.html#SlashCommandBuilder>hikari.api.special_endpoints.SlashCommandBuilder</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>slash_command_builder</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>name</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
        <span class=n>description</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>SlashCommandBuilder</span><span class=p>:</span>
        <span class=sa>r</span><span class=sd>"""Create a command builder for use in `RESTClient.set_application_commands`.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        name : str</span>
<span class=sd>            The command's name. This should match the regex `^[\w-]{1,32}$` in</span>
<span class=sd>            Unicode mode and be lowercase.</span>
<span class=sd>        description : str</span>
<span class=sd>            The description to set for the command if this is a slash command.</span>
<span class=sd>            This should be inclusively between 1-100 characters in length.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.SlashCommandBuilder</span>
<span class=sd>            The created command builder object.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Create a command builder for use in <code><a href=#RESTClient.set_application_commands>RESTClient.set_application_commands</a></code>.<h6 id=parameters>Parameters</h6><ul><li><strong>name</strong> (str): The command's name. This should match the regex <code>^[\w-]{1,32}$</code> in Unicode mode and be lowercase.<li><strong>description</strong> (str): The description to set for the command if this is a slash command. This should be inclusively between 1-100 characters in length.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=special_endpoints.html#SlashCommandBuilder>hikari.api.special_endpoints.SlashCommandBuilder</a></strong>: The created command builder object.</ul></div></div><div id=RESTClient.sync_guild_template><div class="attr function"><a class=headerlink href=#RESTClient.sync_guild_template>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>sync_guild_template</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   template: Union[str, <a href=../templates.html#Template>hikari.templates.Template</a>]<br>) -> <a href=../templates.html#Template>hikari.templates.Template</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>sync_guild_template</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>template</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>templates</span><span class=o>.</span><span class=n>Template</span><span class=p>:</span>
        <span class=sd>"""Create a guild template.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to sync a template in.</span>
<span class=sd>        template : typing.Union[str, hikari.templates.Template]</span>
<span class=sd>            Object or code of the template to sync.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.templates.Template</span>
<span class=sd>            The object of the synced template.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are not part of the guild or are missing the `MANAGE_GUILD`</span>
<span class=sd>            permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or template is not found.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Create a guild template.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to sync a template in.<li><strong>template</strong> (typing.Union[str, <a href=../templates.html#Template>hikari.templates.Template</a>]): Object or code of the template to sync.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=../templates.html#Template>hikari.templates.Template</a></strong>: The object of the synced template.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are not part of the guild or are missing the <code>MANAGE_GUILD</code> permission.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild or template is not found.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.trigger_typing><div class="attr function"><a class=headerlink href=#RESTClient.trigger_typing>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>def </span><span class=name>trigger_typing</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> <a href=special_endpoints.html#TypingIndicator>hikari.api.special_endpoints.TypingIndicator</a>:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>trigger_typing</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span> <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>]</span>
    <span class=p>)</span> <span class=o>-></span> <span class=n>special_endpoints</span><span class=o>.</span><span class=n>TypingIndicator</span><span class=p>:</span>
        <span class=sd>"""Trigger typing in a text channel.</span>

<span class=sd>        .. note::</span>
<span class=sd>            The result of this call can be awaited to trigger typing once, or</span>
<span class=sd>            can be used as an async context manager to continually type until the</span>
<span class=sd>            context manager is left. Any errors documented below will happen then.</span>

<span class=sd>        Examples</span>
<span class=sd>        --------</span>
<span class=sd>        ```py</span>
<span class=sd>        # Trigger typing just once.</span>
<span class=sd>        await rest.trigger_typing(channel)</span>

<span class=sd>        # Trigger typing repeatedly for 1 minute.</span>
<span class=sd>        async with rest.trigger_typing(channel):</span>
<span class=sd>            await asyncio.sleep(60)</span>
<span class=sd>        ```</span>

<span class=sd>        .. warning::</span>
<span class=sd>            Sending a message to the channel will cause the typing indicator</span>
<span class=sd>            to disappear until it is re-triggered.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to trigger typing in. This may be the object or</span>
<span class=sd>            the ID of an existing channel.</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        hikari.api.special_endpoints.TypingIndicator</span>
<span class=sd>            A typing indicator to use.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `SEND_MESSAGES` in the channel.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Trigger typing in a text channel.<p><em>Note:</em> The result of this call can be awaited to trigger typing once, or can be used as an async context manager to continually type until the context manager is left. Any errors documented below will happen then.<h6 id=examples>Examples</h6><div class=codehilite><pre><span></span><code><span class=c1># Trigger typing just once.</span>
<span class=k>await</span> <span class=n>rest</span><span class=o>.</span><span class=n>trigger_typing</span><span class=p>(</span><span class=n>channel</span><span class=p>)</span>

<span class=c1># Trigger typing repeatedly for 1 minute.</span>
<span class=k>async</span> <span class=k>with</span> <span class=n>rest</span><span class=o>.</span><span class=n>trigger_typing</span><span class=p>(</span><span class=n>channel</span><span class=p>):</span>
    <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>60</span><span class=p>)</span>
</code></pre></div><p><em>Warning:</em> Sending a message to the channel will cause the typing indicator to disappear until it is re-triggered.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>]): The channel to trigger typing in. This may be the object or the ID of an existing channel.</ul><h6 id=returns>Returns</h6><ul><li><strong><a href=special_endpoints.html#TypingIndicator>hikari.api.special_endpoints.TypingIndicator</a></strong>: A typing indicator to use.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>SEND_MESSAGES</code> in the channel.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel is not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.unban_member><div class="attr function"><a class=headerlink href=#RESTClient.unban_member>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>unban_member</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   user: Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>unban_member</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Alias of `hikari.impl.rest.RESTClient.unban_user`."""</span>
</pre></div></details><div class=docstring><p>Alias of <code><a href=../impl/rest.html#RESTClient.unban_user>hikari.impl.rest.RESTClient.unban_user</a></code>.</div></div><div id=RESTClient.unban_user><div class="attr function"><a class=headerlink href=#RESTClient.unban_user>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>unban_user</span><span class=signature>(<br>   self,<br>   guild: Union[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   user: Union[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   *,<br>   reason: Union[str, <a href=../undefined.html#UndefinedType>hikari.undefined.UndefinedType</a>] = UNDEFINED<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>unban_user</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>guild</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>guilds</span><span class=o>.</span><span class=n>PartialGuild</span><span class=p>],</span>
        <span class=n>user</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>users</span><span class=o>.</span><span class=n>PartialUser</span><span class=p>],</span>
        <span class=o>*</span><span class=p>,</span>
        <span class=n>reason</span><span class=p>:</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UndefinedOr</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=n>undefined</span><span class=o>.</span><span class=n>UNDEFINED</span><span class=p>,</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Unban a member from a guild.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        guild : hikari.snowflakes.SnowflakeishOr[hikari.guilds.PartialGuild]</span>
<span class=sd>            The guild to unban the member from. This may be the</span>
<span class=sd>            object or the ID of an existing guild.</span>
<span class=sd>        user : hikari.snowflakes.SnowflakeishOr[hikari.users.PartialUser]</span>
<span class=sd>            The user to unban. This may be the object</span>
<span class=sd>            or the ID of an existing user.</span>

<span class=sd>        Other Parameters</span>
<span class=sd>        ----------------</span>
<span class=sd>        reason : hikari.undefined.UndefinedOr[str]</span>
<span class=sd>            If provided, the reason that will be recorded in the audit logs.</span>
<span class=sd>            Maximum of 512 characters.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `BAN_MEMBERS` permission.</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the guild or user are not found.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Unban a member from a guild.<h6 id=parameters>Parameters</h6><ul><li><strong>guild</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../guilds.html#PartialGuild>hikari.guilds.PartialGuild</a>]): The guild to unban the member from. This may be the object or the ID of an existing guild.<li><strong>user</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../users.html#PartialUser>hikari.users.PartialUser</a>]): The user to unban. This may be the object or the ID of an existing user.</ul><h6 id=other-parameters>Other Parameters</h6><ul><li><strong>reason</strong> (<a href=../undefined.html#UndefinedOr>hikari.undefined.UndefinedOr</a>[str]): If provided, the reason that will be recorded in the audit logs. Maximum of 512 characters.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>BAN_MEMBERS</code> permission.<li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the guild or user are not found.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div><div id=RESTClient.unpin_message><div class="attr function"><a class=headerlink href=#RESTClient.unpin_message>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>unpin_message</span><span class=signature>(<br>   self,<br>   channel: Union[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int],<br>   message: Union[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>, <a href=../snowflakes.html#Snowflake>hikari.snowflakes.Snowflake</a>, int]<br>) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>unpin_message</span><span class=p>(</span>
        <span class=bp>self</span><span class=p>,</span>
        <span class=n>channel</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>channels_</span><span class=o>.</span><span class=n>TextableChannel</span><span class=p>],</span>
        <span class=n>message</span><span class=p>:</span> <span class=n>snowflakes</span><span class=o>.</span><span class=n>SnowflakeishOr</span><span class=p>[</span><span class=n>messages_</span><span class=o>.</span><span class=n>PartialMessage</span><span class=p>],</span>
    <span class=p>)</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Unpin a given message from a given text channel.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        channel : hikari.snowflakes.SnowflakeishOr[hikari.channels.TextableChannel]</span>
<span class=sd>            The channel to unpin a message in. This may be the object or</span>
<span class=sd>            the ID of an existing channel.</span>
<span class=sd>        message : hikari.snowflakes.SnowflakeishOr[hikari.messages.PartialMessage]</span>
<span class=sd>            The message to unpin. This may be the object or the ID of an</span>
<span class=sd>            existing message.</span>

<span class=sd>        Raises</span>
<span class=sd>        ------</span>
<span class=sd>        hikari.errors.UnauthorizedError</span>
<span class=sd>            If you are unauthorized to make the request (invalid/missing token).</span>
<span class=sd>        hikari.errors.ForbiddenError</span>
<span class=sd>            If you are missing the `MANAGE_MESSAGES` permission.</span>
<span class=sd>        hikari.errors.NotFoundError</span>
<span class=sd>            If the channel is not found or the message is not a pinned message</span>
<span class=sd>            in the given channel.</span>
<span class=sd>        hikari.errors.RateLimitTooLongError</span>
<span class=sd>            Raised in the event that a rate limit occurs that is</span>
<span class=sd>            longer than `max_rate_limit` when making a request.</span>
<span class=sd>        hikari.errors.RateLimitedError</span>
<span class=sd>            Usually, Hikari will handle and retry on hitting</span>
<span class=sd>            rate-limits automatically. This includes most bucket-specific</span>
<span class=sd>            rate-limits and global rate-limits. In some rare edge cases,</span>
<span class=sd>            however, Discord implements other undocumented rules for</span>
<span class=sd>            rate-limiting, such as limits per attribute. These cannot be</span>
<span class=sd>            detected or handled normally by Hikari due to their undocumented</span>
<span class=sd>            nature, and will trigger this exception if they occur.</span>
<span class=sd>        hikari.errors.InternalServerError</span>
<span class=sd>            If an internal error occurs on Discord while handling the request.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Unpin a given message from a given text channel.<h6 id=parameters>Parameters</h6><ul><li><strong>channel</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../channels.html#TextableChannel>hikari.channels.TextableChannel</a>]): The channel to unpin a message in. This may be the object or the ID of an existing channel.<li><strong>message</strong> (<a href=../snowflakes.html#SnowflakeishOr>hikari.snowflakes.SnowflakeishOr</a>[<a href=../messages.html#PartialMessage>hikari.messages.PartialMessage</a>]): The message to unpin. This may be the object or the ID of an existing message.</ul><h6 id=raises>Raises</h6><ul><li><strong><a href=../errors.html#UnauthorizedError>hikari.errors.UnauthorizedError</a></strong>: If you are unauthorized to make the request (invalid/missing token).<li><strong><a href=../errors.html#ForbiddenError>hikari.errors.ForbiddenError</a></strong>: If you are missing the <code>MANAGE_MESSAGES</code> permission.<li><strong><a href=../errors.html#NotFoundError>hikari.errors.NotFoundError</a></strong>: If the channel is not found or the message is not a pinned message in the given channel.<li><strong><a href=../errors.html#RateLimitTooLongError>hikari.errors.RateLimitTooLongError</a></strong>: Raised in the event that a rate limit occurs that is longer than <code>max_rate_limit</code> when making a request.<li><strong><a href=../errors.html#RateLimitedError>hikari.errors.RateLimitedError</a></strong>: Usually, Hikari will handle and retry on hitting rate-limits automatically. This includes most bucket-specific rate-limits and global rate-limits. In some rare edge cases, however, Discord implements other undocumented rules for rate-limiting, such as limits per attribute. These cannot be detected or handled normally by Hikari due to their undocumented nature, and will trigger this exception if they occur.<li><strong><a href=../errors.html#InternalServerError>hikari.errors.InternalServerError</a></strong>: If an internal error occurs on Discord while handling the request.</ul></div></div></section></section><section id=TokenStrategy><div class="attr class"><a class=headerlink href=#TokenStrategy>#  </a><span class=def>class </span><span class=name>TokenStrategy</span><wbr>(<span class=base>abc.ABC</span>):</div><details><summary>View Source</summary> <div class=codehilite><pre><span></span><span class=k>class</span> <span class=nc>TokenStrategy</span><span class=p>(</span><span class=n>abc</span><span class=o>.</span><span class=n>ABC</span><span class=p>):</span>
    <span class=sd>"""Interface of an object used for managing OAuth2 access."""</span>

    <span class=vm>__slots__</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Sequence</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span> <span class=o>=</span> <span class=p>()</span>

    <span class=nd>@property</span>
    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>token_type</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-></span> <span class=n>typing</span><span class=o>.</span><span class=n>Union</span><span class=p>[</span><span class=n>applications</span><span class=o>.</span><span class=n>TokenType</span><span class=p>,</span> <span class=nb>str</span><span class=p>]:</span>
        <span class=sd>"""Type of token this strategy returns."""</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>acquire</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>client</span><span class=p>:</span> <span class=n>RESTClient</span><span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>
        <span class=sd>"""Acquire an authorization token (including the prefix).</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        str</span>
<span class=sd>            The current authorization token to use for this client and it's</span>
<span class=sd>            prefix.</span>
<span class=sd>        """</span>

    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>invalidate</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>token</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=nb>str</span><span class=p>])</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Invalidate the cached token in this handler.</span>

<span class=sd>        .. note::</span>
<span class=sd>            `token` may be provided in-order to avoid newly generated tokens</span>
<span class=sd>            from being invalidated due to multiple calls being made by separate</span>
<span class=sd>            subroutines which are handling the same token.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        token : typing.Optional[str]</span>
<span class=sd>            The token to specifically invalidate. If provided then this will only</span>
<span class=sd>            invalidate the cached token if it matches this, otherwise it'll be</span>
<span class=sd>            invalidated regardless.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Interface of an object used for managing OAuth2 access.</div><section class=member_divisor><h5>Variables and properties</h5><div id=TokenStrategy.token_type><div class="attr variable"><a class=headerlink href=#TokenStrategy.token_type>#  </a><span class=name>token_type</span><span class=annotation>: Union[<a href=../applications.html#TokenType>hikari.applications.TokenType</a>, str]</span></div><div class=docstring><p>Type of token this strategy returns.</div></div></section><section class=member_divisor><h5>Methods</h5><div id=TokenStrategy.acquire><div class="attr function"><a class=headerlink href=#TokenStrategy.acquire>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>async def </span><span class=name>acquire</span><span class=signature>(self, client: <a href=#RESTClient>hikari.api.rest.RESTClient</a>) -> str:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>async</span> <span class=k>def</span> <span class=nf>acquire</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>client</span><span class=p>:</span> <span class=n>RESTClient</span><span class=p>)</span> <span class=o>-></span> <span class=nb>str</span><span class=p>:</span>
        <span class=sd>"""Acquire an authorization token (including the prefix).</span>

<span class=sd>        Returns</span>
<span class=sd>        -------</span>
<span class=sd>        str</span>
<span class=sd>            The current authorization token to use for this client and it's</span>
<span class=sd>            prefix.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Acquire an authorization token (including the prefix).<h6 id=returns>Returns</h6><ul><li><strong>str</strong>: The current authorization token to use for this client and it's prefix.</ul></div></div><div id=TokenStrategy.invalidate><div class="attr function"><a class=headerlink href=#TokenStrategy.invalidate>#  </a><div class=decorator>@abc.abstractmethod</div><span class=def>def </span><span class=name>invalidate</span><span class=signature>(self, token: Optional[str]) -> None:</span></div><details><summary>View Source</summary> <div class=codehilite><pre><span></span>    <span class=nd>@abc</span><span class=o>.</span><span class=n>abstractmethod</span>
    <span class=k>def</span> <span class=nf>invalidate</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>token</span><span class=p>:</span> <span class=n>typing</span><span class=o>.</span><span class=n>Optional</span><span class=p>[</span><span class=nb>str</span><span class=p>])</span> <span class=o>-></span> <span class=kc>None</span><span class=p>:</span>
        <span class=sd>"""Invalidate the cached token in this handler.</span>

<span class=sd>        .. note::</span>
<span class=sd>            `token` may be provided in-order to avoid newly generated tokens</span>
<span class=sd>            from being invalidated due to multiple calls being made by separate</span>
<span class=sd>            subroutines which are handling the same token.</span>

<span class=sd>        Parameters</span>
<span class=sd>        ----------</span>
<span class=sd>        token : typing.Optional[str]</span>
<span class=sd>            The token to specifically invalidate. If provided then this will only</span>
<span class=sd>            invalidate the cached token if it matches this, otherwise it'll be</span>
<span class=sd>            invalidated regardless.</span>
<span class=sd>        """</span>
</pre></div></details><div class=docstring><p>Invalidate the cached token in this handler.<p><em>Note:</em> <code>token</code> may be provided in-order to avoid newly generated tokens from being invalidated due to multiple calls being made by separate subroutines which are handling the same token.<h6 id=parameters>Parameters</h6><ul><li><strong>token</strong> (typing.Optional[str]): The token to specifically invalidate. If provided then this will only invalidate the cached token if it matches this, otherwise it'll be invalidated regardless.</ul></div></div></section></section></main><script src=../../../version_switcher.js></script><script>"use strict";const html=document.querySelector("html"),sidebarToggle=document.getElementById("sidebar-toggle");sidebarToggle.addEventListener("click",function(){html.classList.contains("sidebar-hidden")?html.classList.remove("sidebar-hidden"):html.classList.add("sidebar-hidden")});let firstContact=null;document.addEventListener("touchstart",function(e){firstContact={x:e.touches[0].clientX,time:Date.now()}},{passive:!0}),document.addEventListener("touchmove",function(e){if(!firstContact)return;let i=e.touches[0].clientX,t=i-firstContact.x;Date.now()-firstContact.time<300&&Math.abs(t)>=100&&(t>=0&&firstContact.x<Math.min(document.body.clientWidth,450)?(html.classList.remove("sidebar-hidden"),firstContact=null):t<0&&i<250&&(html.classList.add("sidebar-hidden"),firstContact=null))},{passive:!0});</script><script>function escapeHTML(n){return document.createElement("div").appendChild(document.createTextNode(n)).parentNode.innerHTML}const originalContent=document.querySelector("main.pdoc");let currentContent=originalContent;function setContent(n){let e;n?(e=document.createElement("main"),e.classList.add("pdoc"),e.innerHTML=n):e=originalContent,currentContent!==e&&(currentContent.replaceWith(e),currentContent=e)}function getSearchTerm(){return new URL(window.location).searchParams.get("search")}const searchBox=document.querySelector(".pdoc input[type=search]");searchBox.addEventListener("input",function(){let n=new URL(window.location);searchBox.value.trim()?(n.hash="",n.searchParams.set("search",searchBox.value)):n.searchParams.delete("search"),history.replaceState("","",n.toString()),onInput()}),window.addEventListener("popstate",onInput);let search,searchErr;async function initialize(){try{search=await new Promise((n,e)=>{const t=document.createElement("script");t.type="text/javascript",t.async=!0,t.onload=()=>n(window.pdocSearch),t.onerror=r=>e(r),t.src="../../search.js",document.getElementsByTagName("head")[0].appendChild(t)})}catch{console.error("Cannot fetch pdoc search index"),searchErr="Cannot fetch search index."}onInput(),document.querySelector("nav.pdoc").addEventListener("click",n=>{n.target.hash&&(searchBox.value="",searchBox.dispatchEvent(new Event("input")))})}function onInput(){setContent((()=>{const n=getSearchTerm();if(!n)return null;if(searchErr)return`<h3>Error: ${searchErr}</h3>`;if(!search)return"<h3>Searching...</h3>";window.scrollTo({top:0,left:0,behavior:"auto"});const e=search(n);let t;e.length===0?t=`No search results for '${escapeHTML(n)}'.`:t=`<h4>${e.length} search result${e.length>1?"s":""} for '${escapeHTML(n)}'.</h4>`;for(let r of e.slice(0,10)){let s=r.doc,l=`../../${s.modulename.replaceAll(".","/")}.html`;s.qualname&&(l+=`#${s.qualname}`);let a;switch(r.doc.type){case"function":a=`<span class="def">${s.funcdef}</span> <span class="name">${s.fullname}</span><span class="signature">${s.signature}:</span>`;break;case"class":a=`<span class="def">class</span> <span class="name">${s.fullname}</span>`,s.bases&&(a+=`<wbr>(<span class="base">${s.bases}</span>)`),a+=":";break;case"variable":a=`<span class="name">${s.fullname}</span>`,s.annotation&&(a+=`<span class="annotation">${s.annotation}</span>`),s.default_value&&(a+=`<span class="default_value">${s.default_value}</span>`);break;default:a=`<span class="name">${s.fullname}</span>`;break}t+=`
                        <section class="search-result">
                        <a href="${l}" class="attr ${s.type}">${a}</a>
                        <div class="docstring">${s.doc}</div>
                        </section>
                    `}return t})())}getSearchTerm()?(initialize(),searchBox.value=getSearchTerm(),onInput()):searchBox.addEventListener("focus",initialize,{once:!0}),searchBox.addEventListener("keydown",n=>{if(["ArrowDown","ArrowUp","Enter"].includes(n.key)){let e=currentContent.querySelector(".search-result.focused");e?n.key==="ArrowDown"&&e.nextElementSibling&&e.nextElementSibling.classList.contains("search-result")?(e.classList.remove("focused"),e.nextElementSibling.classList.add("focused"),e.nextElementSibling.scrollIntoView({behavior:"smooth",block:"nearest",inline:"nearest"})):n.key==="ArrowUp"&&e.previousElementSibling&&e.previousElementSibling.classList.contains("search-result")?(e.classList.remove("focused"),e.previousElementSibling.classList.add("focused"),e.previousElementSibling.scrollIntoView({behavior:"smooth",block:"nearest",inline:"nearest"})):n.key==="Enter"&&e.querySelector("a").click():currentContent.querySelector(".search-result").classList.add("focused")}});</script>